<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Standard Validation Classes</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guia de Referência do Programador">
<link rel="up" href="zend.validate.html" title="Zend_Validate">
<link rel="prev" href="zend.validate.introduction.html" title="Introduction">
<link rel="next" href="zend.validate.validator_chains.html" title="Validator Chains">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Standard Validation Classes</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.validate.introduction.html">Anterior</a> </td>
<th width="60%" align="center">Zend_Validate</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.validate.validator_chains.html">Próxima</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.validate.set"></a>Standard Validation Classes</h2></div></div></div>
    

    <p>
        Zend Framework comes with a standard set of validation classes, which are ready for you to
        use.
    </p>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.alnum"></a>Alnum</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Alnum</code> allows you to validate if a given value contains
        only alphabetical characters and digits. There is no length limitation for the input
        you want to validate.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alnum.options"></a>Supported options for Zend_Validate_Alnum</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Alnum</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowWhiteSpace</span></em></span>: If whitespace
                    characters are allowed. This option defaults to <code class="constant">FALSE</code>
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alnum.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            A basic example is the following one:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Alnum();
if ($validator-&gt;isValid('Abcd12')) {
    // value contains only allowed chars
} else {
    // false
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alnum.whitespace"></a>Using whitespaces</h4></div></div></div>
        

        <p>
            Per default whitespaces are not accepted because they are not part of the alphabet.
            Still, there is a way to accept them as input. This allows to validate complete
            sentences or phrases.
        </p>

        <p>
            To allow the usage of whitespaces you need to give the
            <span class="property">allowWhiteSpace</span> option. This can be done while creating an instance
            of the validator, or afterwards by using <code class="methodname">setAllowWhiteSpace()</code>.
            To get the actual state you can use <code class="methodname">getAllowWhiteSpace()</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Alnum(array('allowWhiteSpace' =&gt; true));
if ($validator-&gt;isValid('Abcd and 12')) {
    // value contains only allowed chars
} else {
    // false
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alnum.languages"></a>Using different languages</h4></div></div></div>
        

        <p>
            When using <code class="classname">Zend_Validate_Alnum</code> then the language which the user
            sets within his browser will be used to set the allowed characters. This means when your
            user sets <span class="emphasis"><em>de</em></span> for german then he can also enter characters like
            <span class="emphasis"><em>ä</em></span>, <span class="emphasis"><em>ö</em></span> and <span class="emphasis"><em>ü</em></span> additionally
            to the characters from the english alphabet.
        </p>

        <p>
            Which characters are allowed depends completly on the used language as every language
            defines it's own set of characters.
        </p>

        <p>
            There are actually 3 languages which are not accepted in their own script. These
            languages are <span class="emphasis"><em>korean</em></span>, <span class="emphasis"><em>japanese</em></span> and
            <span class="emphasis"><em>chinese</em></span> because this languages are using an alphabet where a
            single character is build by using multiple characters.
        </p>

        <p>
            In the case you are using these languages, the input will only be validated by using
            the english alphabet.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.alpha"></a>Alpha</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Alpha</code> allows you to validate if a given value contains
        only alphabetical characters. There is no length limitation for the input you want to
        validate. This validator is related to the <code class="classname">Zend_Validate_Alnum</code>
        validator with the exception that it does not accept digits.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alpha.options"></a>Supported options for Zend_Validate_Alpha</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Alpha</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowWhiteSpace</span></em></span>: If whitespace
                    characters are allowed. This option defaults to <code class="constant">FALSE</code>
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alpha.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            A basic example is the following one:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Alpha();
if ($validator-&gt;isValid('Abcd')) {
    // value contains only allowed chars
} else {
    // false
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alpha.whitespace"></a>Using whitespaces</h4></div></div></div>
        

        <p>
            Per default whitespaces are not accepted because they are not part of the alphabet.
            Still, there is a way to accept them as input. This allows to validate complete
            sentences or phrases.
        </p>

        <p>
            To allow the usage of whitespaces you need to give the
            <span class="property">allowWhiteSpace</span> option. This can be done while creating an instance
            of the validator, or afterwards by using <code class="methodname">setAllowWhiteSpace()</code>.
            To get the actual state you can use <code class="methodname">getAllowWhiteSpace()</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Alpha(array('allowWhiteSpace' =&gt; true));
if ($validator-&gt;isValid('Abcd and efg')) {
    // value contains only allowed chars
} else {
    // false
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alpha.languages"></a>Using different languages</h4></div></div></div>
        

        <p>
            When using <code class="classname">Zend_Validate_Alpha</code> then the language which the user
            sets within his browser will be used to set the allowed characters. This means when your
            user sets <span class="emphasis"><em>de</em></span> for german then he can also enter characters like
            <span class="emphasis"><em>ä</em></span>, <span class="emphasis"><em>ö</em></span> and <span class="emphasis"><em>ü</em></span> additionally
            to the characters from the english alphabet.
        </p>

        <p>
            Which characters are allowed depends completly on the used language as every language
            defines it's own set of characters.
        </p>

        <p>
            There are actually 3 languages which are not accepted in their own script. These
            languages are <span class="emphasis"><em>korean</em></span>, <span class="emphasis"><em>japanese</em></span> and
            <span class="emphasis"><em>chinese</em></span> because this languages are using an alphabet where a
            single character is build by using multiple characters.
        </p>

        <p>
            In the case you are using these languages, the input will only be validated by using
            the english alphabet.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.barcode"></a>Barcode</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Barcode</code> allows you to check if a given value can be
        represented as barcode.
    </p>

    <p>
        <code class="classname">Zend_Validate_Barcode</code> supports multiple barcode standards and can be
        extended with proprietary barcode implementations very easily. The following barcode
        standards are supported:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE25</em></span>: Often called "two of five" or "Code25 Industrial".
            </p>

            <p>
                This barcode has no length limitation. It supports only digits, and the last digit
                can be an optional checksum which is calculated with modulo 10. This standard is
                very old and nowadays not often used. Common usecases are within the industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE25INTERLEAVED</em></span>: Often called "Code 2 of 5 Interleaved".
            </p>

            <p>
                This standard is a variant of CODE25. It has no length limitation, but it must
                contain an even amount of characters. It supports only digits, and the last digit
                can be an optional checksum which is calculated with modulo 10. It is used worldwide
                and common on the market.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE39</em></span>: CODE39 is one of the oldest available codes.
            </p>

            <p>
                This barcode has a variable length. It supports digits, upper cased alphabetical
                characters and 7 special characters like whitespace, point and dollar sign. It can
                have an optional checksum which is calculated with modulo 43. This standard is used
                worldwide and common within the industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE39EXT</em></span>: CODE39EXT is an extension of CODE39.
            </p>

            <p>
                This barcode has the same properties as CODE39. Additionally it allows the usage of
                all 128 ASCII characters. This standard is used worldwide and common within the
                industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE93</em></span>: CODE93 is the successor of CODE39.
            </p>

            <p>
                This barcode has a variable length. It supports digits, alphabetical characters
                and 7 special characters. It has an optional checksum which is calculated with
                modulo 47 and contains 2 characters. This standard produces a denser code than
                CODE39 and is more secure.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE93EXT</em></span>: CODE93EXT is an extension of CODE93.
            </p>

            <p>
                This barcode has the same properties as CODE93. Additionally it allows the usage of
                all 128 ASCII characters. This standard is used worldwide and common within the
                industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN2</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                These barcode must have 2 characters. It supports only digits and does not have a
                checksum. This standard is mainly used as addition to EAN13 (ISBN) when printed on
                books.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN5</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                These barcode must have 5 characters. It supports only digits and does not have a
                checksum. This standard is mainly used as addition to EAN13 (ISBN) when printed on
                books.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN8</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                These barcode can have 7 or 8 characters. It supports only digits. When it has a
                length of 8 characters it includes a checksum. This standard is used worldwide but
                has a very limited range. It can be found on small articles where a longer barcode
                could not be printed.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN12</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                This barcode must have a length of 12 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                used within the USA and common on the market. It has been superceded by EAN13.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN13</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                This barcode must have a length of 13 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                used worldwide and common on the market.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN14</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                This barcode must have a length of 14 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                used worldwide and common on the market. It is the successor for EAN13.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN18</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                This barcode must have a length of 18 characters. It support only digits. The last
                digit is always a checksum digit which is calculated with modulo 10. This code is
                often used for the identification of shipping containers.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>GTIN12</em></span>: GTIN is the shortcut for "Global Trade Item Number".
            </p>

            <p>
                This barcode uses the same standard as EAN12 and is its successor. It's commonly
                used within the USA.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>GTIN13</em></span>: GTIN is the shortcut for "Global Trade Item Number".
            </p>

            <p>
                This barcode uses the same standard as EAN13 and is its successor. It is used
                worldwide by industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>GTIN14</em></span>: GTIN is the shortcut for "Global Trade Item Number".
            </p>

            <p>
                This barcode uses the same standard as EAN14 and is its successor. It is used
                worldwide and common on the market.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>IDENTCODE</em></span>: Identcode is used by Deutsche Post and DHL. It's an
                specialized implementation of Code25.
            </p>

            <p>
                This barcode must have a length of 12 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                mainly used by the companies DP and DHL.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>INTELLIGENTMAIL</em></span>: Intelligent Mail is a postal barcode.
            </p>

            <p>
                This barcode can have a length of 20, 25, 29 or 31 characters. It supports only
                digits, and contains no checksum. This standard is the successor of
                <acronym class="acronym">PLANET</acronym> and <acronym class="acronym">POSTNET</acronym>. It is mainly used by the
                United States Postal Services.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>ISSN</em></span>: <acronym class="acronym">ISSN</acronym> is the abbreviation for
                International Standard Serial Number.
            </p>

            <p>
                This barcode can have a length of 8 or 13 characters. It supports only digits,
                and the last digit must be a checksum digit which is calculated with modulo 11.
                It is used worldwide for printed publications.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>ITF14</em></span>: ITF14 is the GS1 implementation of an Interleaved Two
                of Five bar code.
            </p>

            <p>
                This barcode is a special variant of Interleaved 2 of 5. It must have a length of
                14 characters and is based on GTIN14. It supports only digits, and the last digit
                must be a checksum digit which is calculated with modulo 10. It is used worldwide
                and common within the market.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>LEITCODE</em></span>: Leitcode is used by Deutsche Post and DHL. It's an
                specialized implementation of Code25.
            </p>

            <p>
                This barcode must have a length of 14 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                mainly used by the companies DP and DHL.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>PLANET</em></span>: Planet is the abbreviation for Postal Alpha Numeric
                Encoding Technique.
            </p>

            <p>
                This barcode can have a length of 12 or 14 characters. It supports only digits, and
                the last digit is always a checksum. This standard is mainly used by the United
                States Postal Services.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>POSTNET</em></span>: Postnet is used by the US Postal Service.
            </p>

            <p>
                This barcode can have a length of 6, 7, 10 or 12 characters. It supports only
                digits, and the last digit is always a checksum. This standard is mainly used
                by the United States Postal Services.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>ROYALMAIL</em></span>: Royalmail is used by Royal Mail.
            </p>

            <p>
                This barcode has no defined length. It supports digits, uppercased letters, and the
                last digit is always a checksum. This standard is mainly used by Royal Mail for
                their Cleanmail Service. It is also called <acronym class="acronym">RM4SCC</acronym>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>SSCC</em></span>: SSCC is the shortcut for "Serial Shipping Container
                Code".
            </p>

            <p>
                This barcode is a variant of EAN barcode. It must have a length of 18 characters and
                supports only digits. The last digit must be a checksum digit which is calculated
                with modulo 10. It is commonly used by the transport industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>UPCA</em></span>: UPC is the shortcut for "Univeral Product Code".
            </p>

            <p>
                This barcode preceeded EAN13. It must have a length of 12 characters and supports
                only digits. The last digit must be a checksum digit which is calculated with
                modulo 10. It is commonly used within the USA.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>UPCE</em></span>: UPCE is the short variant from UPCA.
            </p>

            <p>
                This barcode is a smaller variant of UPCA. It can have a length of 6, 7 or 8
                characters and supports only digits. When the barcode is 8 chars long it includes
                a checksum which is calculated with modulo 10. It is commonly used with small
                products where a UPCA barcode would not fit.
            </p>
        </li>
</ul></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.options"></a>Supported options for Zend_Validate_Barcode</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Barcode</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">adapter</span></em></span>: Sets the barcode adapter
                    which will be used. Supported are all above noted adapters. When using a self
                    defined adapter, then you have to set the complete classname.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">checksum</span></em></span>: <code class="constant">TRUE</code>
                    when the barcode should contain a checksum. The default value depends on the
                    used adapter. Note that some adapters don't allow to set this option.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">options</span></em></span>: Defines optional options for
                    a self written adapters.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            To validate if a given string is a barcode you just need to know its type. See the
            following example for an EAN13 barcode:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Barcode('EAN13');
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.checksum"></a>Optional checksum</h4></div></div></div>
        

        <p>
            Some barcodes can be provided with an optional checksum. These barcodes would be valid
            even without checksum. Still, when you provide a checksum, then you should also validate
            it. By default, these barcode types perform no checksum validation. By using the
            <span class="property">checksum</span> option you can define if the checksum will be validated or
            ignored.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Barcode(array(
    'adapter'  =&gt; 'EAN13',
    'checksum' =&gt; false,
));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <div class="note"><table border="0" summary="Note: Reduced security by disabling checksum validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Reduced security by disabling checksum validation</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                 By switching off checksum validation you will also reduce the security of the used
                 barcodes. Additionally you should note that you can also turn off the checksum
                 validation for those barcode types which must contain a checksum value. Barcodes
                 which would not be valid could then be returned as valid even if they are not.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.custom"></a>Writing custom adapters</h4></div></div></div>
        

        <p>
            You may write custom barcode validators for usage with
            <code class="classname">Zend_Validate_Barcode</code>; this is often necessary when dealing with
            proprietary barcode types. To write your own barcode validator, you need the following
            information.
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Length</em></span>: The length your barcode must have. It can have one
                    of the following values:
                </p>

                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>Integer</em></span>: A value greater 0, which means that the
                            barcode must have this length.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>-1</em></span>: There is no limitation for the length of this
                            barcode.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>"even"</em></span>: The length of this barcode must have a
                            even amount of digits.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>"odd"</em></span>: The length of this barcode must have a
                            odd amount of digits.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>array</em></span>: An array of integer values. The length of
                            this barcode must have one of the set array values.
                        </p>
                    </li>
</ul></div>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Characters</em></span>: A string which contains all allowed characters
                    for this barcode. Also the integer value 128 is allowed, which means the first
                    128 characters of the ASCII table.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Checksum</em></span>: A string which will be used as callback for a
                    method which does the checksum validation.
                </p>
            </li>
</ul></div>

        <p>
            Your custom barcode validator must extend
            <code class="classname">Zend_Validate_Barcode_AdapterAbstract</code> or implement
            <span class="interface">Zend_Validate_Barcode_AdapterInterface</span>.
        </p>

        <p>
            As an example, let's create a validator that expects an even number of characters that
            include all digits and the letters 'ABCDE', and which requires a checksum.
        </p>

        <pre class="programlisting">
class My_Barcode_MyBar extends Zend_Validate_Barcode_AdapterAbstract
{
    protected $_length     = 'even';
    protected $_characters = '0123456789ABCDE';
    protected $_checksum   = '_mod66';

    protected function _mod66($barcode)
    {
        // do some validations and return a boolean
    }
}

$valid = new Zend_Validate_Barcode('My_Barcode_MyBar');
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.between"></a>Between</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Between</code> allows you to validate if a given value is
        between two other values.
    </p>

    <div class="note"><table border="0" summary="Note: Zend_Validate_Between supports only number validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Zend_Validate_Between supports only number validation</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            It should be noted that <code class="classname">Zend_Validate_Between</code> supports only the
            validation of numbers. Strings or dates can not be validated with this validator.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.between.options"></a>Supported options for Zend_Validate_Between</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Between</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">inclusive</span></em></span>: Defines if the validation
                    is inclusive the minimum and maximum border values or exclusive. It defaults
                    to <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">max</span></em></span>: Sets the maximum border for the
                    validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">min</span></em></span>: Sets the minimum border for the
                    validation.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.between.basic"></a>Default behaviour for Zend_Validate_Between</h4></div></div></div>
        

        <p>
            Per default this validator checks if a value is between <span class="property">min</span> and
            <span class="property">max</span> where both border values are allowed as value.
        </p>

        <pre class="programlisting">
$valid  = new Zend_Validate_Between(array('min' =&gt; 0, 'max' =&gt; 10));
$value  = 10;
$result = $valid-&gt;isValid($value);
// returns true
</pre>

        <p>
            In the above example the result is <code class="constant">TRUE</code> due to the reason that per
            default the search is inclusively the border values. This means in our case that any
            value from '0' to '10' is allowed. And values like '-1' and '11' will return
            <code class="constant">FALSE</code>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.between.inclusively"></a>Validation exclusive the border values</h4></div></div></div>
        

        <p>
            Sometimes it is useful to validate a value by excluding the border values. See the
            following example:
        </p>

        <pre class="programlisting">
$valid  = new Zend_Validate_Between(
    array(
        'min' =&gt; 0,
        'max' =&gt; 10,
        'inclusive' =&gt; false
    )
);
$value  = 10;
$result = $valid-&gt;isValid($value);
// returns false
</pre>

        <p>
            The example is almost equal to our first example but we excluded the border value. Now
            the values '0' and '10' are no longer allowed and will return
            <code class="constant">FALSE</code>.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.callback"></a>Callback</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Callback</code> allows you to provide a callback with which to
        validate a given value.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.options"></a>Supported options for Zend_Validate_Callback</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Callback</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">callback</span></em></span>: Sets the callback which will
                    be called for the validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">options</span></em></span>: Sets the additional options
                    which will be given to the callback.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            The simplest usecase is to have a single function and use it as a callback. Let's expect
            we have the following function.
        </p>

        <pre class="programlisting">
function myMethod($value)
{
    // some validation
    return true;
}
</pre>

        <p>
            To use it within <code class="classname">Zend_Validate_Callback</code> you just have to call it
            this way:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback('myMethod');
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.closure"></a>Usage with closures</h4></div></div></div>
        

        <p>
            <acronym class="acronym">PHP</acronym> 5.3 introduces <a class="ulink" href="http://php.net/functions.anonymous" target="_top">closures</a>, which are basically
            self-contained or <span class="emphasis"><em>anonymous</em></span> functions. <acronym class="acronym">PHP</acronym>
            considers closures another form of callback, and, as such, may be used with
            <code class="classname">Zend_Validate_Callback</code>. As an example:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(function($value){
    // some validation
    return true;
});

if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.class"></a>Usage with class-based callbacks</h4></div></div></div>
        

        <p>
            Of course it's also possible to use a class method as callback. Let's expect we have
            the following class method:
        </p>

        <pre class="programlisting">
class MyClass
{
    public function myMethod($value)
    {
        // some validation
        return true;
    }
}
</pre>

        <p>
            The definition of the callback is in this case almost the same. You have just to create
            an instance of the class before the method and create an array describing the callback:
        </p>

        <pre class="programlisting">
$object = new MyClass;
$valid = new Zend_Validate_Callback(array($object, 'myMethod'));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            You may also define a static method as a callback. Consider the following class
            definition and validator usage:
        </p>

        <pre class="programlisting">
class MyClass
{
    public static function test($value)
    {
        // some validation
        return true;
    }
}

$valid = new Zend_Validate_Callback(array('MyClass', 'test'));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            Finally, if you are using <acronym class="acronym">PHP</acronym> 5.3, you may define the magic method
            <code class="methodname">__invoke()</code> in your class. If you do so, simply providing an
            instance of the class as the callback will also work:
        </p>

        <pre class="programlisting">
class MyClass
{
    public function __invoke($value)
    {
        // some validation
        return true;
    }
}

$object = new MyClass();
$valid = new Zend_Validate_Callback($object);
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.options2"></a>Adding options</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Callback</code> also allows the usage of options which
            are provided as additional arguments to the callback.
        </p>

        <p>
            Consider the following class and method definition:
        </p>

        <pre class="programlisting">
class MyClass
{
    function myMethod($value, $option)
    {
        // some validation
        return true;
    }
}
</pre>

        <p>
            There are two ways to inform the validator of additional options: pass them in the
            constructor, or pass them to the <code class="methodname">setOptions()</code> method.
        </p>

        <p>
            To pass them to the constructor, you would need to pass an array containing two keys,
            "callback" and "options":
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(array(
    'callback' =&gt; array('MyClass', 'myMethod'),
    'options'  =&gt; $option,
));

if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            Otherwise, you may pass them to the validator after instantiation:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(array('MyClass', 'myMethod'));
$valid-&gt;setOptions($option);

if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            When there are additional values given to <code class="methodname">isValid()</code> then these
            values will be added immediately after <code class="varname">$value</code>.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(array('MyClass', 'myMethod'));
$valid-&gt;setOptions($option);

if ($valid-&gt;isValid($input, $additional)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            When making the call to the callback, the value to be validated will always be passed as
            the first argument to the callback followed by all other values given to
            <code class="methodname">isValid()</code>; all other options will follow it. The amount and
            type of options which can be used is not limited.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.creditcard"></a>CreditCard</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_CreditCard</code> allows you to validate if a given value
        could be a credit card number.
    </p>

    <p>
        A creditcard contains several items of metadata, including a hologram, account number, logo,
        expiration date, security code and the card holder name. The algorithms for verifying the
        combination of metadata are only known to the issuing company, and should be verified with
        them for purposes of payment. However, it's often useful to know whether or not a given
        number actually falls within the ranges of possible numbers <span class="emphasis"><em>prior</em></span> to
        performing such verification, and, as such, <code class="classname">Zend_Validate_CreditCard</code>
        simply verifies that the credit card number provided is well-formed.
    </p>

    <p>
        For those cases where you have a service that can perform comprehensive verification,
        <code class="classname">Zend_Validate_CreditCard</code> also provides the ability to attach a
        service callback to trigger once the credit card number has been deemed valid; this callback
        will then be triggered, and its return value will determine overall validity.
    </p>

    <p>
        The following issuing institutes are accepted:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <p>
                <span class="emphasis"><em>American Express</em></span>
            </p>

            <p>
                <span class="emphasis"><em>China UnionPay</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Diners Club Card Blanche</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Diners Club International</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Diners Club US &amp; Canada</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Discover Card</em></span>
            </p>

            <p>
                <span class="emphasis"><em>JCB</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Laser</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Maestro</em></span>
            </p>

            <p>
                <span class="emphasis"><em>MasterCard</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Solo</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Visa</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Visa Electron</em></span>
            </p>
        </li></ul></div>

    <div class="note"><table border="0" summary="Note: Invalid institutes">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Invalid institutes</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            The institutes <span class="emphasis"><em>Bankcard</em></span> and <span class="emphasis"><em>Diners Club
                enRoute</em></span> do not exist anymore. Therefore they are treated as invalid.
        </p>

        <p>
            <span class="emphasis"><em>Switch</em></span> has been rebranded to <span class="emphasis"><em>Visa</em></span> and is
            therefore also treated as invalid.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.options"></a>Supported options for Zend_Validate_CreditCard</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_CreditCard</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">service</span></em></span>: A callback to an online
                    service which will additionally be used for the validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span>: The type of creditcard which
                    will be validated. See the below list of institutes for details.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            There are several credit card institutes which can be validated by
            <code class="classname">Zend_Validate_CreditCard</code>. Per default, all known institutes will
            be accepted. See the folowing example:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard();
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            The above example would validate against all known credit card institutes.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.institute"></a>Accepting defined credit cards</h4></div></div></div>
        

        <p>
            Sometimes it is necessary to accept only defined credit card institutes instead of all;
            e.g., when you have a webshop which accepts only Visa and American Express cards.
            <code class="classname">Zend_Validate_CreditCard</code> allows you to do exactly this by
            limiting it to exactly these institutes.
        </p>

        <p>
            To use a limitation you can either provide specific institutes at initiation, or
            afterwards by using <code class="methodname">setType()</code>. Each can take several arguments.
        </p>

        <p>
            You can provide a single institute:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard(
    Zend_Validate_CreditCard::AMERICAN_EXPRESS
);
</pre>

        <p>
            When you want to allow multiple institutes, then you can provide them as array:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard(array(
    Zend_Validate_CreditCard::AMERICAN_EXPRESS,
    Zend_Validate_CreditCard::VISA
));
</pre>

        <p>
            And as with all validators, you can also pass an associative array of options or an
            instance of <code class="classname">Zend_Config</code>. In this case you have to provide the
            institutes with the <span class="property">type</span> array key as simulated here:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard(array(
    'type' =&gt; array(Zend_Validate_CreditCard::AMERICAN_EXPRESS)
));
</pre>

        <div class="table">
<a name="zend.validate.set.creditcard.institute.table"></a><p class="title"><b>Tabela 170. Constants for credit card institutes</b></p>
<div class="table-contents">
            

            <table class="table" summary="Constants for credit card institutes" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Institute</th>
<th>Constant</th>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>American Express</em></span></td>
<td><code class="constant">AMERICAN_EXPRESS</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>China UnionPay</em></span></td>
<td><code class="constant">UNIONPAY</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Diners Club Card Blanche</em></span></td>
<td><code class="constant">DINERS_CLUB</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Diners Club International</em></span></td>
<td><code class="constant">DINERS_CLUB</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Diners Club US &amp; Canada</em></span></td>
<td><code class="constant">DINERS_CLUB_US</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Discover Card</em></span></td>
<td><code class="constant">DISCOVER</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>JCB</em></span></td>
<td><code class="constant">JCB</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Laser</em></span></td>
<td><code class="constant">LASER</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Maestro</em></span></td>
<td><code class="constant">MAESTRO</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>MasterCard</em></span></td>
<td><code class="constant">MASTERCARD</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Solo</em></span></td>
<td><code class="constant">SOLO</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Visa</em></span></td>
<td><code class="constant">VISA</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Visa Electron</em></span></td>
<td><code class="constant">VISA</code></td>
</tr>
</tbody>
</table>
        </div>
</div>
<br class="table-break">

        <p>
            You can also set or add institutes afterward instantiation by using the methods
            <code class="methodname">setType()</code>, <code class="methodname">addType()</code> and
            <code class="methodname">getType()</code>.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard();
$valid-&gt;setType(array(
    Zend_Validate_CreditCard::AMERICAN_EXPRESS,
    Zend_Validate_CreditCard::VISA
));
</pre>

        <div class="note"><table border="0" summary="Note: Default institute">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Default institute</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                When no institute is given at initiation then <code class="constant">ALL</code> will be
                used, which sets all institutes at once.
            </p>

            <p>
                In this case the usage of <code class="methodname">addType()</code> is useless because all
                institutes are already added.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.servicecheck"></a>Validation by using foreign APIs</h4></div></div></div>
        

        <p>
            As said before <code class="classname">Zend_Validate_CreditCard</code> will only validate
            the credit card number. Fortunately, some institutes provide online
            <acronym class="acronym">API</acronym>s which can validate a credit card number by using algorithms
            which are not available to the public. Most of these services are paid services.
            Therefore, this check is deactivated per default.
        </p>

        <p>
            When you have access to such an <acronym class="acronym">API</acronym>, then you can use it as an addon
            for <code class="classname">Zend_Validate_CreditCard</code> and increase the security of the
            validation.
        </p>

        <p>
            To do so, you simply need to give a callback which will be called when the generic
            validation has passed. This prevents the <acronym class="acronym">API</acronym> from being called
            for invalid numbers, which increases the performance of the application.
        </p>

        <p>
            <code class="methodname">setService()</code> sets a new service, and
            <code class="methodname">getService()</code> returns the set service. As a configuration
            option,
            you can give the array key '<span class="property">service</span>' at initiation. For details
            about possible options take a look into <a class="link" href="zend.validate.set.html#zend.validate.set.callback" title="Callback">Callback</a>.
        </p>

        <pre class="programlisting">
// Your service class
class CcService
{
    public function checkOnline($cardnumber, $types)
    {
        // some online validation
    }
}

// The validation
$service = new CcService();
$valid   = new Zend_Validate_CreditCard(Zend_Validate_CreditCard::VISA);
$valid-&gt;setService(array($service, 'checkOnline'));
</pre>

        <p>
            As you can see the callback method will be called with the creditcard number as the
            first parameter, and the accepted types as the second parameter.
        </p>
    </div>
</div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.ccnum"></a>Ccnum</h3></div></div></div>
        

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                The <code class="classname">Ccnum</code> validator has been deprecated in favor of the
                <code class="classname">CreditCard</code> validator. For security reasons you should use
                CreditCard instead of Ccnum.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.date"></a>Date</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Date</code> allows you to validate if a given value contains
        a date. This validator validates also localized input.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.date.options"></a>Supported options for Zend_Validate_Date</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Date</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">format</span></em></span>: Sets the format which is used
                    to write the date.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: Sets the locale which will be
                    used to validate date values.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.date.basic"></a>Default date validation</h4></div></div></div>
        

        <p>
            The easiest way to validate a date is by using the default date format. It is used when
            no locale and no format has been given.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Date();

$validator-&gt;isValid('2000-10-10');   // returns true
$validator-&gt;isValid('10.10.2000'); // returns false
</pre>

        <p>
            The default date format for <code class="classname">Zend_Validate_Date</code> is 'yyyy-MM-dd'.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.date.localized"></a>Localized date validation</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Date</code> validates also dates which are given in a
            localized format. By using the <span class="property">locale</span> option you can define the
            locale which the date format should use for validation.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Date(array('locale' =&gt; 'de'));

$validator-&gt;isValid('10.Feb.2010'); // returns true
$validator-&gt;isValid('10.May.2010'); // returns false
</pre>

        <p>
            The <span class="property">locale</span> option sets the default date format. In the above
            example this is 'dd.MM.yyyy' which is defined as default date format for 'de'.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.date.formats"></a>Self defined date validation</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Date</code> supports also self defined date formats.
            When you want to validate such a date you can use the <span class="property">format</span>
            option.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Date(array('format' =&gt; 'yyyy'));

$validator-&gt;isValid('2010'); // returns true
$validator-&gt;isValid('May');  // returns false
</pre>

        <p>
            Of course you can combine <span class="property">format</span> and <span class="property">locale</span>.
            In this case you can also use localized month or daynames.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Date(array('format' =&gt; 'yyyy MMMM', 'locale' =&gt; 'de'));

$validator-&gt;isValid('2010 Dezember'); // returns true
$validator-&gt;isValid('2010 June');     // returns false
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.Db"></a>Db_RecordExists and Db_NoRecordExists</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Db_RecordExists</code> and
        <code class="classname">Zend_Validate_Db_NoRecordExists</code> provide a means to test
        whether a record exists in a given table of a database, with a given
        value.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.db.options"></a>Supported options for Zend_Validate_Db_*</h4></div></div></div>
        

        <p>
            The following options are supported for
            <code class="classname">Zend_Validate_Db_NoRecordExists</code> and
            <code class="classname">Zend_Validate_Db_RecordExists</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">adapter</span></em></span>: The database adapter which
                    will be used for the search.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">exclude</span></em></span>: Sets records which will be
                    excluded from the search.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">field</span></em></span>: The database field within this
                    table which will be searched for the record.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">schema</span></em></span>: Sets the schema which will be
                    used for the search.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">table</span></em></span>: The table which will be
                    searched for the record.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.basic-usage"></a>Basic usage</h4></div></div></div>
        

        <p>
            An example of basic usage of the validators:
        </p>

        <pre class="programlisting">
//Check that the email address exists in the database
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'emailaddress'
    )
);

if ($validator-&gt;isValid($emailaddress)) {
    // email address appears to be valid
} else {
    // email address is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            The above will test that a given email address is in the database
            table. If no record is found containing the value of
            <code class="varname">$emailaddress</code> in the specified column, then an error
            message is displayed.
        </p>

        <pre class="programlisting">
//Check that the username is not present in the database
$validator = new Zend_Validate_Db_NoRecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'username'
    )
);
if ($validator-&gt;isValid($username)) {
    // username appears to be valid
} else {
    // username is invalid; print the reason
    $messages = $validator-&gt;getMessages();
    foreach ($messages as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            The above will test that a given username is not in the database
            table. If a record is found containing the value of
            <code class="varname">$username</code> in the specified column, then an error
            message is displayed.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.excluding-records"></a>Excluding records</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Db_RecordExists</code> and
            <code class="classname">Zend_Validate_Db_NoRecordExists</code> also provide a means
            to test the database, excluding a part of the table, either by
            providing a where clause as a string, or an array with the keys
            "field" and "value".
        </p>

        <p>
            When providing an array for the exclude clause, the <span class="emphasis"><em>!=</em></span>
            operator is used, so you can check the rest of a table for a value
            before altering a record (for example on a user profile form)
        </p>

        <pre class="programlisting">
//Check no other users have the username
$user_id   = $user-&gt;getId();
$validator = new Zend_Validate_Db_NoRecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'username',
        'exclude' =&gt; array(
            'field' =&gt; 'id',
            'value' =&gt; $user_id
        )
    )
);

if ($validator-&gt;isValid($username)) {
    // username appears to be valid
} else {
    // username is invalid; print the reason
    $messages = $validator-&gt;getMessages();
    foreach ($messages as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            The above example will check the table to ensure no records other
            than the one where <span class="command"><strong>id = $user_id</strong></span> contains the value
            $username.
        </p>

        <p>
            You can also provide a string to the exclude clause so you can use
            an operator other than <span class="emphasis"><em>!=</em></span>. This can be useful for
            testing against composite keys.
        </p>

        <pre class="programlisting">
$email     = 'user@example.com';
$clause    = $db-&gt;quoteInto('email = ?', $email);
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table'   =&gt; 'users',
        'field'   =&gt; 'username',
        'exclude' =&gt; $clause
    )
);

if ($validator-&gt;isValid($username)) {
    // username appears to be valid
} else {
    // username is invalid; print the reason
    $messages = $validator-&gt;getMessages();
    foreach ($messages as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            The above example will check the 'users' table
            to ensure that only a record with both the username
            <code class="varname">$username</code> and with the email
            <code class="varname">$email</code> is valid.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.database-adapters"></a>Database Adapters</h4></div></div></div>
        

        <p>
            You can also specify an adapter. This will allow you to work with
            applications using multiple database adapters, or where you have not
            set a default adapter. As in the example below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'id',
        'adapter' =&gt; $dbAdapter
    )
);
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.database-schemas"></a>Database Schemas</h4></div></div></div>
        

        <p>
            You can specify a schema within your database for adapters such as
            PostgreSQL and DB/2 by simply supplying an array with
            <span class="property">table</span> and <span class="property">schema</span> keys. As in the example
            below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table'  =&gt; 'users',
        'schema' =&gt; 'my',
        'field'  =&gt; 'id'
    )
);
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.digits"></a>Digits</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Digits</code> validates if a given value contains only digits.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.digits.options"></a>Supported options for Zend_Validate_Digits</h4></div></div></div>
        

        <p>
            There are no additional options for <code class="classname">Zend_Validate_Digits</code>:
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.digits.basic"></a>Validating digits</h4></div></div></div>
        

        <p>
            To validate if a given value contains only digits and no other characters, simply call
            the validator like shown in this example:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Digits();

$validator-&gt;isValid("1234567890"); // returns true
$validator-&gt;isValid(1234);         // returns true
$validator-&gt;isValid('1a234');      // returns false
</pre>

        <div class="note"><table border="0" summary="Note: Validating numbers">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Validating numbers</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                When you want to validate numbers or numeric values, be aware that this validator
                only validates digits. This means that any other sign like a thousand separator or
                a comma will not pass this validator. In this case you should use
                <code class="classname">Zend_Validate_Int</code> or
                <code class="classname">Zend_Validate_Float</code>.
            </p>
        </td></tr>
</table></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.email_address"></a>EmailAddress</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_EmailAddress</code> allows you to validate an email address.
        The validator first splits the email address on local-part @ hostname and attempts to match
        these against known specifications for email addresses and hostnames.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            A basic example of usage is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
if ($validator-&gt;isValid($email)) {
    // email appears to be valid
} else {
    // email is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            This will match the email address <code class="varname">$email</code> and on failure populate
            <code class="methodname">getMessages()</code> with useful error messages.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.options"></a>Options for validating Email Addresses</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> supports several options which can
            either be set at initiation, by giving an array with the related options, or
            afterwards, by using <code class="methodname">setOptions()</code>. The following options are
            supported:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allow</span></em></span>: Defines which type of domain
                    names are accepted. This option is used in conjunction with the hostname option
                    to set the hostname validator. For more informations about possible values of
                    this option, look at <a class="link" href="zend.validate.set.html#zend.validate.set.hostname" title="Hostname">Hostname</a>
                    and possible <code class="constant">ALLOW</code>* constants. This option defaults to
                    <code class="constant">ALLOW_DNS</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">deep</span></em></span>: Defines if the servers MX
                    records should be verified by a deep check. When this option is set to
                    <code class="constant">TRUE</code> then additionally to MX records also the A, A6 and
                    <code class="constant">AAAA</code> records are used to verify if the server accepts
                    emails. This option defaults to <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">domain</span></em></span>: Defines if the domain part
                    should be checked. When this option is set to <code class="constant">FALSE</code>, then
                    only the local part of the email address will be checked. In this case the
                    hostname validator will not be called. This option defaults to
                    <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">hostname</span></em></span>: Sets the hostname validator
                    with which the domain part of the email address will be validated.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">mx</span></em></span>: Defines if the MX records from the
                    server should be detected. If this option is defined to
                    <code class="constant">TRUE</code> then the MX records are used to verify if the server
                    accepts emails. This option defaults to <code class="constant">FALSE</code>.
                </p>
            </li>
</ul></div>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
$validator-&gt;setOptions(array('domain' =&gt; false));
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.complexlocal"></a>Complex local parts</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> will match any valid email address
            according to RFC2822. For example, valid emails include
            <span class="emphasis"><em>bob@domain.com</em></span>, <span class="emphasis"><em>bob+jones@domain.us</em></span>,
            <span class="emphasis"><em>"bob@jones"@domain.com</em></span> and
            <span class="emphasis"><em>"bob jones"@domain.com</em></span>.
        </p>

        <p>
            Some obsolete email formats will not currently validate (e.g. carriage returns or a
            "\" character in an email address).
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.purelocal"></a>Validating only the local part</h4></div></div></div>
        

        <p>
            If you need <code class="classname">Zend_Validate_EmailAddress</code> to check only the local
            part of an email address, and want to disable validation of the hostname, you can
            set the <span class="property">domain</span> option to <code class="constant">FALSE</code>. This forces
            <code class="classname">Zend_Validate_EmailAddress</code> not to validate the hostname part of
            the email address.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
$validator-&gt;setOptions(array('domain' =&gt; FALSE));
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.hostnametype"></a>Validating different types of hostnames</h4></div></div></div>
        

        <p>
            The hostname part of an email address is validated against <a class="link" href="zend.validate.set.html#zend.validate.set.hostname" title="Hostname">
                <code class="classname">Zend_Validate_Hostname</code></a>. By default
            only DNS hostnames of the form <code class="filename">domain.com</code> are accepted, though if
            you wish you can accept IP addresses and Local hostnames too.
        </p>

        <p>
            To do this you need to instantiate <code class="classname">Zend_Validate_EmailAddress</code>
            passing a parameter to indicate the type of hostnames you want to accept. More details
            are included in <code class="classname">Zend_Validate_Hostname</code>, though an example of how
            to accept both DNS and Local hostnames appears below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress(
                    Zend_Validate_Hostname::ALLOW_DNS |
                    Zend_Validate_Hostname::ALLOW_LOCAL);
if ($validator-&gt;isValid($email)) {
    // email appears to be valid
} else {
    // email is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.checkacceptance"></a>Checking if the hostname actually accepts email</h4></div></div></div>
        

        <p>
            Just because an email address is in the correct format, it doesn't necessarily mean
            that email address actually exists. To help solve this problem, you can use MX
            validation to check whether an MX (email) entry exists in the DNS record for the
            email's hostname. This tells you that the hostname accepts email, but doesn't tell you
            the exact email address itself is valid.
        </p>

        <p>
            MX checking is not enabled by default. To enable MX checking you can pass a second
            parameter to the <code class="classname">Zend_Validate_EmailAddress</code> constructor.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress(
    array(
        'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
        'mx'    =&gt; true
    )
);
</pre>

        <div class="note"><table border="0" summary="Note: MX Check under Windows">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">MX Check under Windows</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Within Windows environments MX checking is only available when
                <acronym class="acronym">PHP</acronym> 5.3 or above is used. Below <acronym class="acronym">PHP</acronym> 5.3 MX
                checking will not be used even if it's activated within the options.
            </p>
        </td></tr>
</table></div>

        <p>
            Alternatively you can either pass <code class="constant">TRUE</code> or
            <code class="constant">FALSE</code> to <code class="methodname">setValidateMx()</code> to enable
            or disable MX validation.
        </p>

        <p>
            By enabling this setting network functions will be used to check for the presence of an
            MX record on the hostname of the email address you wish to validate. Please be aware
            this will likely slow your script down.
        </p>

        <p>
            Sometimes validation for MX records returns <code class="constant">FALSE</code>, even if emails
            are accepted. The reason behind this behaviour is, that servers can accept emails even
            if they do not provide a MX record. In this case they can provide A, A6 or
            <code class="constant">AAAA</code> records. To allow
            <code class="classname">Zend_Validate_EmailAddress</code> to check also for these other records,
            you need to set deep MX validation. This can be done at initiation by setting the
            <span class="property">deep</span> option or by using <code class="methodname">setOptions()</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress(
    array(
        'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
        'mx'    =&gt; true,
        'deep'  =&gt; true
    )
);
</pre>

        <div class="warning"><table border="0" summary="Warning: Performance warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Atenção]" src="images/warning.png"></td>
<th align="left">Performance warning</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                You should be aware that enabling MX check will slow down you script because of the
                used network functions. Enabling deep check will slow down your script even more as
                it searches the given server for 3 additional types.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: Disallowed IP addresses">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Disallowed IP addresses</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                You should note that MX validation is only accepted for external servers. When deep
                MX validation is enabled, then local IP addresses like <span class="command"><strong>192.168.*</strong></span>
                or <span class="command"><strong>169.254.*</strong></span> are not accepted.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.validateidn"></a>Validating International Domains Names</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> will also match international
            characters that exist in some domains. This is known as International Domain Name (IDN)
            support. This is enabled by default, though you can disable this by changing the
            setting via the internal <code class="classname">Zend_Validate_Hostname</code> object that
            exists within <code class="classname">Zend_Validate_EmailAddress</code>.
        </p>

        <pre class="programlisting">
$validator-&gt;getHostnameValidator()-&gt;setValidateIdn(false);
</pre>

        <p>
            More information on the usage of <code class="methodname">setValidateIdn()</code> appears in
            the <code class="classname">Zend_Validate_Hostname</code> documentation.
        </p>

        <p>
            Please note IDNs are only validated if you allow DNS hostnames to be validated.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.validatetld"></a>Validating Top Level Domains</h4></div></div></div>
        

        <p>
            By default a hostname will be checked against a list of known TLDs. This is enabled by
            default, though you can disable this by changing the setting via the internal
            <code class="classname">Zend_Validate_Hostname</code> object that exists within
            <code class="classname">Zend_Validate_EmailAddress</code>.
        </p>

        <pre class="programlisting">
$validator-&gt;getHostnameValidator()-&gt;setValidateTld(false);
</pre>

        <p>
            More information on the usage of <code class="methodname">setValidateTld()</code> appears in
            the <code class="classname">Zend_Validate_Hostname</code> documentation.
        </p>

        <p>
            Please note TLDs are only validated if you allow DNS hostnames to be validated.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.setmessage"></a>Setting messages</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> makes also use of
            <code class="classname">Zend_Validate_Hostname</code> to check the hostname part of a given
            email address. As with Zend Framework 1.10 you can simply set messages for
            <code class="classname">Zend_Validate_Hostname</code> from within
            <code class="classname">Zend_Validate_EmailAddress</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
$validator-&gt;setMessages(
    array(
        Zend_Validate_Hostname::UNKNOWN_TLD =&gt; "I don't know the TLD you gave"
    )
);
</pre>

        <p>
            Before Zend Framework 1.10 you had to attach the messages to your own
            <code class="classname">Zend_Validate_Hostname</code>, and then set this validator within
            <code class="classname">Zend_Validate_EmailAddress</code> to get your own messages returned.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.float"></a>Float</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Float</code> allows you to validate if a given value contains
        a floating-point value. This validator validates also localized input.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.float.options"></a>Supported options for Zend_Validate_Float</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Float</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: Sets the locale which will be
                    used to validate localized float values.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.float.basic"></a>Simple float validation</h4></div></div></div>
        

        <p>
            The simplest way to validate a float is by using the system settings. When no option
            is used, the environment locale is used for validation:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Float();

$validator-&gt;isValid(1234.5);   // returns true
$validator-&gt;isValid('10a01'); // returns false
$validator-&gt;isValid('1,234.5'); // returns true
</pre>

        <p>
            In the above example we expected that our environment is set to "en" as locale.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.float.localized"></a>Localized float validation</h4></div></div></div>
        

        <p>
            Often it's useful to be able to validate also localized values. Float values are often
            written different in other countries. For example using english you will write "1.5".
            In german you may write "1,5" and in other languages you may use grouping.
        </p>

        <p>
            <code class="classname">Zend_Validate_Float</code> is able to validate such notations. But it is
            limited to the locale you set. See the following code:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Float(array('locale' =&gt; 'de'));

$validator-&gt;isValid(1234.5); // returns true
$validator-&gt;isValid("1 234,5"); // returns false
$validator-&gt;isValid("1.234"); // returns true
</pre>

        <p>
            As you can see, by using a locale, your input is validated localized. Using a different
            notation you get a <code class="constant">FALSE</code> when the locale forces a different
            notation.
        </p>

        <p>
            The locale can also be set afterwards by using <code class="methodname">setLocale()</code> and
            retrieved by using <code class="methodname">getLocale()</code>.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.greaterthan"></a>GreaterThan</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_GreaterThan</code> allows you to validate if a given value is
        greater than a minimum border value.
    </p>

    <div class="note"><table border="0" summary="Note: Zend_Validate_GreaterThan supports only number validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Zend_Validate_GreaterThan supports only number validation</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            It should be noted that <code class="classname">Zend_Validate_GreaterThan</code> supports only
            the validation of numbers. Strings or dates can not be validated with this validator.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.greaterthan.options"></a>Supported options for Zend_Validate_GreaterThan</h4></div></div></div>
        

        <p>
            The following options are supported for
            <code class="classname">Zend_Validate_GreaterThan</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">min</span></em></span>: Sets the minimum border value.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.greaterthan.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            To validate if a given value is greater than a defined border simply use the following
            example.
        </p>

        <pre class="programlisting">
$valid  = new Zend_Validate_GreaterThan(array('min' =&gt; 10));
$value  = 11;
$return = $valid-&gt;isValid($value);
// returns true
</pre>

        <p>
            The above example returns <code class="constant">TRUE</code> for all values which are greater
            than 10.
        </p>

        <pre class="programlisting">
$valid  = new Zend_Validate_GreaterThan(array('min' =&gt; 10));
$value  = 10;
$return = $valid-&gt;isValid($value);
// returns false
</pre>

        <p>
            The above example returns <code class="constant">FALSE</code> for all values which are lesser
            or equal to the minimum border value.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.hex"></a>Hex</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Hex</code> allows you to validate if a given value contains
        only hexadecimal characters. These are all characters from <span class="emphasis"><em>0 to 9</em></span> and
        <span class="emphasis"><em>A to F</em></span> case insensitive. There is no length limitation for the input
        you want to validate.
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_Hex();
if ($validator-&gt;isValid('123ABC')) {
    // value contains only hex chars
} else {
    // false
}
</pre>

    <div class="note"><table border="0" summary="Note: Invalid characters">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Invalid characters</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            All other characters will return false, including whitespace and decimal point. Also
            unicode zeros and numbers from other scripts than latin will not be treaten as valid.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.hex.options"></a>Supported options for Zend_Validate_Hex</h4></div></div></div>
        

        <p>
            There are no additional options for <code class="classname">Zend_Validate_Hex</code>:
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.hostname"></a>Hostname</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Hostname</code> allows you to validate a hostname against a
        set of known specifications. It is possible to check for three different types of hostnames:
        a <acronym class="acronym">DNS</acronym> Hostname (i.e. <code class="filename">domain.com</code>), IP address (i.e.
        1.2.3.4), and Local hostnames (i.e. localhost). By default only <acronym class="acronym">DNS</acronym>
        hostnames are matched.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.hostname.options"></a>Supported options for Zend_Validate_Hostname</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Hostname</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allow</span></em></span>: Defines the sort of hostname
                    which is allowed to be used. See <a class="link" href="zend.validate.set.html#zend.validate.set.hostname.types" title="Validating different types of hostnames">Hostname types</a> for
                    details.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">idn</span></em></span>: Defines if <acronym class="acronym">IDN</acronym>
                    domains are allowed or not. This option defaults to <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">ip</span></em></span>: Allows to define a own IP
                    validator. This option defaults to a new instance of
                    <code class="classname">Zend_Validate_Ip</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">tld</span></em></span>: Defines if
                    <acronym class="acronym">TLD</acronym>s are validated. This option defaults to
                    <code class="constant">TRUE</code>.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.hostname.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            A basic example of usage is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Hostname();
if ($validator-&gt;isValid($hostname)) {
    // hostname appears to be valid
} else {
    // hostname is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            This will match the hostname <code class="varname">$hostname</code> and on failure populate
            <code class="methodname">getMessages()</code> with useful error messages.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.hostname.types"></a>Validating different types of hostnames</h4></div></div></div>
        

        <p>
            You may find you also want to match IP addresses, Local hostnames, or a combination of
            all allowed types. This can be done by passing a parameter to
            <code class="classname">Zend_Validate_Hostname</code> when you instantiate it. The parameter
            should be an integer which determines what types of hostnames are allowed. You are
            encouraged to use the <code class="classname">Zend_Validate_Hostname</code> constants to do
            this.
        </p>

        <p>
            The <code class="classname">Zend_Validate_Hostname</code> constants are:
            <code class="constant">ALLOW_DNS</code> to allow only
            <acronym class="acronym">DNS</acronym> hostnames, <code class="constant">ALLOW_IP</code> to allow IP addresses,
            <code class="constant">ALLOW_LOCAL</code> to allow local network names,
            <code class="constant">ALLOW_URI</code> to allow
            <a class="ulink" href="http://tools.ietf.org/html/rfc3986" target="_top">RFC3986</a>-compliant addresses,
            and <code class="constant">ALLOW_ALL</code> to allow all four above types.
        </p>

        <div class="note"><table border="0" summary="Note: Additional Information on ALLOW_URI">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Additional Information on ALLOW_URI</th>
</tr>
<tr><td align="left" valign="top">
            
            <p>
                <code class="constant">ALLOW_URI</code> allows to check hostnames
                according to <a class="ulink" href="http://tools.ietf.org/html/rfc3986" target="_top">RFC3986</a>. These
                are registered names which are used by <acronym class="acronym">WINS</acronym>, NetInfo and also local
                hostnames like those defined within your <code class="filename">.hosts</code> file.
            </p>
        </td></tr>
</table></div>

        <p>
            To just check for IP addresses you can use the example below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_IP);
if ($validator-&gt;isValid($hostname)) {
    // hostname appears to be valid
} else {
    // hostname is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            As well as using <code class="constant">ALLOW_ALL</code> to accept all common hostnames types
            you can combine these types to allow for combinations. For example, to accept
            <acronym class="acronym">DNS</acronym> and Local hostnames instantiate your
            <code class="classname">Zend_Validate_Hostname</code> object as so:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_DNS |
                                        Zend_Validate_Hostname::ALLOW_IP);
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.hostname.idn"></a>Validating International Domains Names</h4></div></div></div>
        

        <p>
            Some Country Code Top Level Domains (ccTLDs), such as 'de' (Germany), support
            international characters in domain names. These are known as International Domain Names
            (<acronym class="acronym">IDN</acronym>). These domains can be matched by
            <code class="classname">Zend_Validate_Hostname</code> via extended characters that are used in
            the validation process.
        </p>

        <div class="note"><table border="0" summary="Note: IDN domains">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">IDN domains</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Until now more than 50 ccTLDs support <acronym class="acronym">IDN</acronym> domains.
            </p>
        </td></tr>
</table></div>

        <p>
            To match an <acronym class="acronym">IDN</acronym> domain it's as simple as just using the standard
            Hostname validator since <acronym class="acronym">IDN</acronym> matching is enabled by default. If you
            wish to disable <acronym class="acronym">IDN</acronym> validation this can be done by either passing a
            parameter to the <code class="classname">Zend_Validate_Hostname</code> constructor or via the
            <code class="methodname">setValidateIdn()</code> method.
        </p>

        <p>
            You can disable <acronym class="acronym">IDN</acronym> validation by passing a second parameter to the
            <code class="classname">Zend_Validate_Hostname</code> constructor in the following way.
        </p>

        <pre class="programlisting">
$validator =
    new Zend_Validate_Hostname(
        array(
            'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
            'idn'   =&gt; false
        )
    );
</pre>

        <p>
            Alternatively you can either pass <code class="constant">TRUE</code> or
            <code class="constant">FALSE</code> to <code class="methodname">setValidateIdn()</code> to enable or
            disable <acronym class="acronym">IDN</acronym> validation. If you are trying to match an
            <acronym class="acronym">IDN</acronym> hostname which isn't currently supported it is likely it will
            fail validation if it has any international characters in it. Where a ccTLD file doesn't
            exist in <code class="filename">Zend/Validate/Hostname</code> specifying the additional
            characters a normal hostname validation is performed.
        </p>

        <div class="note"><table border="0" summary="Note: IDN validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">IDN validation</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Please note that <acronym class="acronym">IDN</acronym>s are only validated if you allow
                <acronym class="acronym">DNS</acronym> hostnames to be validated.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.hostname.tld"></a>Validating Top Level Domains</h4></div></div></div>
        

        <p>
            By default a hostname will be checked against a list of known <acronym class="acronym">TLD</acronym>s.
            If this functionality is not required it can be disabled in much the same way as
            disabling <acronym class="acronym">IDN</acronym> support. You can disable <acronym class="acronym">TLD</acronym>
            validation by passing a third parameter to the
            <code class="classname">Zend_Validate_Hostname</code> constructor. In the example below we are
            supporting <acronym class="acronym">IDN</acronym> validation via the second parameter.
        </p>

        <pre class="programlisting">
$validator =
    new Zend_Validate_Hostname(
        array(
            'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
            'idn'   =&gt; true,
            'tld'   =&gt; false
        )
    );
</pre>

        <p>
            Alternatively you can either pass <code class="constant">TRUE</code> or
            <code class="constant">FALSE</code> to <code class="methodname">setValidateTld()</code> to enable or
            disable <acronym class="acronym">TLD</acronym> validation.
        </p>

        <div class="note"><table border="0" summary="Note: TLD validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">TLD validation</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Please note <acronym class="acronym">TLD</acronym>s are only validated if you allow
                <acronym class="acronym">DNS</acronym> hostnames to be validated.
            </p>
        </td></tr>
</table></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.iban"></a>Iban</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Iban</code> validates if a given value could be a
        <acronym class="acronym">IBAN</acronym> number. <acronym class="acronym">IBAN</acronym> is the abbreviation for
        "International Bank Account Number".
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.iban.options"></a>Supported options for Zend_Validate_Iban</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Iban</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: Sets the locale which is used
                    to get the <acronym class="acronym">IBAN</acronym> format for validation.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.iban.basic"></a>IBAN validation</h4></div></div></div>
        

        <p>
            <acronym class="acronym">IBAN</acronym> numbers are always related to a country. This means that
            different countries use different formats for their <acronym class="acronym">IBAN</acronym> numbers.
            This is the reason why <acronym class="acronym">IBAN</acronym> numbers always need a locale. By knowing
            this we already know how to use <code class="classname">Zend_Validate_Iban</code>.
        </p>

        <div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.validate.set.iban.basic.application"></a>Application wide locale</h5></div></div></div>
            

            <p>
                We could use the application wide locale. This means that when no option is given at
                initiation, <code class="classname">Zend_Validate_Iban</code> searches for the application
                wide locale. See the following code snippet:
            </p>

            <pre class="programlisting">
// within bootstrap
Zend_Registry::set('Zend_Locale', new Zend_Locale('de_AT'));

// within the module
$validator = new Zend_Validate_Iban();

if ($validator-&gt;isValid('AT611904300234573201')) {
    // IBAN appears to be valid
} else {
    // IBAN is not valid
}
</pre>

            <div class="note"><table border="0" summary="Note: Application wide locale">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Application wide locale</th>
</tr>
<tr><td align="left" valign="top">
                

                <p>
                    Of course this works only when an application wide locale was set within the
                    registry previously. Otherwise <code class="classname">Zend_Locale</code> will try to
                    use the locale which the client sends or, when non has been send, it uses the
                    environment locale. Be aware that this can lead to unwanted behaviour within
                    the validation.
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.validate.set.iban.basic.false"></a>Ungreedy IBAN validation</h5></div></div></div>
            

            <p>
                Sometime it is usefull, just to validate if the given value <span class="emphasis"><em>is</em></span>
                a <acronym class="acronym">IBAN</acronym> number or not. This means that you don't want to validate
                it against a defined country. This can be done by using a
                <code class="constant">FALSE</code> as locale.
            </p>

            <pre class="programlisting">
$validator = new Zend_Validate_Iban(array('locale' =&gt; false));
// Note: you can also set a FALSE as single parameter

if ($validator-&gt;isValid('AT611904300234573201')) {
    // IBAN appears to be valid
} else {
    // IBAN is not valid
}
</pre>

            <p>
                So <span class="emphasis"><em>any</em></span> <acronym class="acronym">IBAN</acronym> number will be valid. Note that
                this should not be done when you accept only accounts from a single country.
            </p>
        </div>

        <div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.validate.set.iban.basic.aware"></a>Region aware IBAN validation</h5></div></div></div>
            

            <p>
                To validate against a defined country, you just need to give the wished locale.
                You can do this by the option <span class="property">locale</span> and also afterwards by
                using <code class="methodname">setLocale()</code>.
            </p>

            <pre class="programlisting">
$validator = new Zend_Validate_Iban(array('locale' =&gt; 'de_AT'));

if ($validator-&gt;isValid('AT611904300234573201')) {
    // IBAN appears to be valid
} else {
    // IBAN is not valid
}
</pre>

            <div class="note"><table border="0" summary="Note: Use full qualified locales">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Use full qualified locales</th>
</tr>
<tr><td align="left" valign="top">
                

                <p>
                    You must give a full qualified locale, otherwise the country could not be
                    detected correct because languages are spoken in multiple countries.
                </p>
            </td></tr>
</table></div>
        </div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.identical"></a>Identical</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Identical</code> allows you to validate if a given value is
        identical with an set haystack.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.options"></a>Supported options for Zend_Validate_Identical</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Identical</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">strict</span></em></span>: Defines if the validation
                    should be done strict. The default value is <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">token</span></em></span>: Sets the token with which the
                    input will be validated against.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            To validate if two values are identical you need to set the origin value as haystack.
            See the following example which validates two strings.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical('origin');
if ($valid-&gt;isValid($value) {
    return true;
}
</pre>

        <p>
            The validation will only then return <code class="constant">TRUE</code> when both values are
            100% identical. In our example, when <code class="varname">$value</code> is 'origin'.
        </p>

        <p>
            You can set the wished token also afterwards by using the method
            <code class="methodname">setToken()</code> and <code class="methodname">getToken()</code> to get
            the actual set token.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.types"></a>Identical objects</h4></div></div></div>
        

        <p>
            Of course <code class="classname">Zend_Validate_Identical</code> can not only validate strings,
            but also any other variable type like Boolean, Integer, Float, Array or even Objects.
            As already noted Haystack and Value must be identical.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(123);
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <div class="note"><table border="0" summary="Note: Type comparison">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Type comparison</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                You should be aware that also the type of a variable is used for validation.
                This means that the string <span class="emphasis"><em>'3'</em></span> is not identical with the
                integer <span class="emphasis"><em>3</em></span>. When you want such a non strict validation you
                must set the <span class="property">strict</span> option.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.formelements"></a>Form elements</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Identical</code> supports also the comparison of form
            elements. This can be done by using the element's name as <span class="property">token</span>.
            See the following example:
        </p>

        <pre class="programlisting">
$form-&gt;addElement('password', 'elementOne');
$form-&gt;addElement('password', 'elementTwo', array(
    'validators' =&gt; array(
        array('identical', false, array('token' =&gt; 'elementOne'))
    )
));
</pre>

        <p>
            By using the elements name from the first element as <span class="property">token</span> for the
            second element, the validator validates if the second element is equal with the first
            element. In the case your user does not enter two identical values, you will get an
            validation error.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.strict"></a>Strict validation</h4></div></div></div>
        

        <p>
            As mentioned before <code class="classname">Zend_Validate_Identical</code> validates tokens
            strict. You can change this behaviour by using the <span class="property">strict</span> option.
            The default value for this property is <code class="constant">TRUE</code>.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(array('token' =&gt; 123, 'strict' =&gt; FALSE));
$input = '123';
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            The difference to the previous example is that the validation returns in this case
            <code class="constant">TRUE</code>, even if you compare a integer with string value as long
            as the content is identical but not the type.
        </p>

        <p>
            For convinience you can also use <code class="methodname">setStrict()</code> and
            <code class="methodname">getStrict()</code>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.configuration"></a>Configuration</h4></div></div></div>
        

        <p>
            As all other validators also <code class="classname">Zend_Validate_Identical</code> supports
            the usage of configuration settings as input parameter. This means that you can
            configure this validator with an <code class="classname">Zend_Config</code> object.
        </p>

        <p>
            But this adds one case which you have to be aware. When you are using an array as
            haystack then you should wrap it within an '<span class="property">token</span>' key when
            it could contain only one element.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(array('token' =&gt; 123));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            The above example validates the integer 123. The reason for this special case is, that
            you can configure the token which has to be used by giving the
            '<span class="property">token</span>' key.
        </p>

        <p>
            So, when your haystack contains one element and this element is named
            '<span class="property">token</span>' then you have to wrap it like shown in the example below.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(array('token' =&gt; array('token' =&gt; 123)));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.in_array"></a>InArray</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_InArray</code> allows you to validate if a given value is
        contained within an array. It is also able to validate multidimensional arrays.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.in_array.options"></a>Supported options for Zend_Validate_InArray</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_InArray</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">haystack</span></em></span>: Sets the haystack for the
                    validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">recursive</span></em></span>: Defines if the validation
                    should be done recursive. This option defaults to <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">strict</span></em></span>: Defines if the validation
                    should be done strict. This option defaults to <code class="constant">FALSE</code>.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.in_array.basic"></a>Simple array validation</h4></div></div></div>
        

        <p>
            The simplest way, is just to give the array which should be searched against at
            initiation:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray(array('key' =&gt; 'value',
                                             'otherkey' =&gt; 'othervalue'));
if ($validator-&gt;isValid('value')) {
    // value found
} else {
    // no value found
}
</pre>

        <p>
            This will behave exactly like <acronym class="acronym">PHP</acronym>'s
            <code class="methodname">in_array()</code> method.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Per default this validation is not strict nor can it validate multidimensional
                arrays.
            </p>
        </td></tr>
</table></div>

        <p>
            Of course you can give the array to validate against also afterwards by using the
            <code class="methodname">setHaystack()</code> method. <code class="methodname">getHaystack()</code>
            returns the actual set haystack array.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray();
$validator-&gt;setHaystack(array('key' =&gt; 'value', 'otherkey' =&gt; 'othervalue'));

if ($validator-&gt;isValid('value')) {
    // value found
} else {
    // no value found
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.in_array.strict"></a>Strict array validation</h4></div></div></div>
        

        <p>
            As mentioned before you can also do a strict validation within the array. Per default
            there would be no difference between the integer value <span class="emphasis"><em>0</em></span> and the
            string <span class="emphasis"><em>"0"</em></span>. When doing a strict validation this difference will
            also be validated and only same types are accepted.
        </p>

        <p>
            A strict validation can also be done by using two different ways. At initiation and by
            using a method. At initiation you have to give an array with the following structure:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray(
    array(
        'haystack' =&gt; array('key' =&gt; 'value', 'otherkey' =&gt; 'othervalue'),
        'strict'   =&gt; true
    )
);

if ($validator-&gt;isValid('value')) {
    // value found
} else {
    // no value found
}
</pre>

        <p>
            The <span class="emphasis"><em>haystack</em></span> key contains your array to validate against. And by
            setting the <span class="emphasis"><em>strict</em></span> key to <code class="constant">TRUE</code>, the validation
            is done by using a strict type check.
        </p>

        <p>
            Of course you can also use the <code class="methodname">setStrict()</code> method to change
            this setting afterwards and <code class="methodname">getStrict()</code> to get the actual set
            state.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Note that the <span class="emphasis"><em>strict</em></span> setting is per default
                <code class="constant">FALSE</code>.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.in_array.recursive"></a>Recursive array validation</h4></div></div></div>
        

        <p>
            In addition to <acronym class="acronym">PHP</acronym>'s <code class="methodname">in_array()</code> method
            this validator can also be used to validate multidimensional arrays.
        </p>

        <p>
            To validate multidimensional arrays you have to set the <span class="emphasis"><em>recursive</em></span>
            option.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray(
    array(
        'haystack' =&gt; array(
            'firstDimension' =&gt; array('key' =&gt; 'value',
                                      'otherkey' =&gt; 'othervalue'),
            'secondDimension' =&gt; array('some' =&gt; 'real',
                                       'different' =&gt; 'key')),
        'recursive' =&gt; true
    )
);

if ($validator-&gt;isValid('value')) {
    // value found
} else {
    // no value found
}
</pre>

        <p>
            Your array will then be validated recursive to see if the given value is contained.
            Additionally you could use <code class="methodname">setRecursive()</code> to set this option
            afterwards and <code class="methodname">getRecursive()</code> to retrieve it.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray(
    array(
        'firstDimension' =&gt; array('key' =&gt; 'value',
                                  'otherkey' =&gt; 'othervalue'),
        'secondDimension' =&gt; array('some' =&gt; 'real',
                                   'different' =&gt; 'key')
    )
);
$validator-&gt;setRecursive(true);

if ($validator-&gt;isValid('value')) {
    // value found
} else {
    // no value found
}
</pre>

        <div class="note"><table border="0" summary="Note: Default setting for recursion">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Default setting for recursion</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Per default the recursive validation is turned off.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: Option keys within the haystack">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Option keys within the haystack</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                When you are using the keys '<span class="property">haystack</span>',
                '<span class="property">strict</span>' or '<span class="property">recursive</span>' within your
                haystack, then you must wrap the <span class="property">haystack</span> key.
            </p>
        </td></tr>
</table></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.int"></a>Int</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Int</code> validates if a given value is an integer. Also
        localized integer values are recognised and can be validated.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.int.options"></a>Supported options for Zend_Validate_Int</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Int</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: Sets the locale which will be
                    used to validate localized integers.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.int.basic"></a>Simple integer validation</h4></div></div></div>
        

        <p>
            The simplest way to validate an integer is by using the system settings. When no option
            is used, the environment locale is used for validation:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Int();

$validator-&gt;isValid(1234);   // returns true
$validator-&gt;isValid(1234.5); // returns false
$validator-&gt;isValid('1,234'); // returns true
</pre>

        <p>
            In the above example we expected that our environment is set to "en" as locale. As you
            can see in the third example also grouping is recognised.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.int.localized"></a>Localized integer validation</h4></div></div></div>
        

        <p>
            Often it's useful to be able to validate also localized values. Integer values are often
            written different in other countries. For example using english you can write "1234" or
            "1,234". Both are integer values but the grouping is optional. In german for example you
            may write "1.234" and in french "1 234".
        </p>

        <p>
            <code class="classname">Zend_Validate_Int</code> is able to validate such notations. But it is
            limited to the locale you set. This means that it not simply strips off the separator,
            it validates if the correct separator is used. See the following code:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Int(array('locale' =&gt; 'de'));

$validator-&gt;isValid(1234); // returns true
$validator-&gt;isValid("1,234"); // returns false
$validator-&gt;isValid("1.234"); // returns true
</pre>

        <p>
            As you can see, by using a locale, your input is validated localized. Using the english
            notation you get a <code class="constant">FALSE</code> when the locale forces a different
            notation.
        </p>

        <p>
            The locale can also be set afterwards by using <code class="methodname">setLocale()</code> and
            retrieved by using <code class="methodname">getLocale()</code>.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.ip"></a>Ip</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Ip</code> allows you to validate if a given value is an IP
        address. It supports the IPv4 and also the IPv6 standard.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.ip.options"></a>Supported options for Zend_Validate_Ip</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Ip</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowipv4</span></em></span>: Defines if the validator
                    allows IPv4 adresses. This option defaults to <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowipv6</span></em></span>: Defines if the validator
                    allows IPv6 adresses. This option defaults to <code class="constant">TRUE</code>.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.ip.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            A basic example of usage is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Ip();
if ($validator-&gt;isValid($ip)) {
    // ip appears to be valid
} else {
    // ip is invalid; print the reasons
}
</pre>

        <div class="note"><table border="0" summary="Note: Invalid IP addresses">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Invalid IP addresses</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Keep in mind that <code class="classname">Zend_Validate_Ip</code> only validates IP
                addresses. Addresses like '<code class="filename">mydomain.com</code>' or
                '<code class="filename">192.168.50.1/index.html</code>' are no valid
                IP addresses. They are either hostnames or valid <acronym class="acronym">URL</acronym>s but not IP
                addresses.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: IPv6 validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">IPv6 validation</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                <code class="classname">Zend_Validate_Ip</code> validates IPv6 addresses with regex. The
                reason is that the filters and methods from <acronym class="acronym">PHP</acronym> itself don't
                follow the <acronym class="acronym">RFC</acronym>. Many other available classes also don't follow
                it.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.ip.singletype"></a>Validate IPv4 or IPV6 alone</h4></div></div></div>
        

        <p>
            Sometimes it's useful to validate only one of the supported formats. For example when
            your network only supports IPv4. In this case it would be useless to allow IPv6 within
            this validator.
        </p>

        <p>
            To limit <code class="classname">Zend_Validate_Ip</code> to one protocol you can set the options
            <span class="property">allowipv4</span> or <span class="property">allowipv6</span> to
            <code class="constant">FALSE</code>. You can do this either by giving the option to the
            constructor or by using <code class="methodname">setOptions()</code> afterwards.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Ip(array('allowipv6' =&gt; false);
if ($validator-&gt;isValid($ip)) {
    // ip appears to be valid ipv4 address
} else {
    // ip is no ipv4 address
}
</pre>

        <div class="note"><table border="0" summary="Note: Default behaviour">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Default behaviour</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                The default behaviour which <code class="classname">Zend_Validate_Ip</code> follows is to
                allow both standards.
            </p>
        </td></tr>
</table></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.isbn"></a>Isbn</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Isbn</code> allows you to validate an
        <acronym class="acronym">ISBN-10</acronym> or <acronym class="acronym">ISBN-13</acronym> value.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.options"></a>Supported options for Zend_Validate_Isbn</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Isbn</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">separator</span></em></span>: Defines the allowed
                    separator for the <acronym class="acronym">ISBN</acronym> number. It defaults to an empty
                    string.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span>: Defines the allowed type of
                    <acronym class="acronym">ISBN</acronym> numbers. It defaults to
                    <code class="constant">Zend_Validate_Isbn::AUTO</code>. For details take a look at
                    <a class="link" href="zend.validate.set.html#zend.validate.set.isbn.type-explicit" title="Setting an explicit ISBN validation type">this section</a>.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            A basic example of usage is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Isbn();
if ($validator-&gt;isValid($isbn)) {
    // isbn is valid
} else {
    // isbn is not valid
}
</pre>

        <p>
            This will validate any <acronym class="acronym">ISBN-10</acronym> and <acronym class="acronym">ISBN-13</acronym> without
            separator.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.type-explicit"></a>Setting an explicit ISBN validation type</h4></div></div></div>
        

        <p>
            An example of an <acronym class="acronym">ISBN</acronym> type restriction is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Isbn();
$validator-&gt;setType(Zend_Validate_Isbn::ISBN13);
// OR
$validator = new Zend_Validate_Isbn(array(
    'type' =&gt; Zend_Validate_Isbn::ISBN13,
));

if ($validator-&gt;isValid($isbn)) {
    // this is a valid ISBN-13 value
} else {
    // this is an invalid ISBN-13 value
}
</pre>

        <p>
            The above will validate only <acronym class="acronym">ISBN-13</acronym> values.
        </p>

        <p>
            Valid types include:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="constant">Zend_Validate_Isbn::AUTO</code> (default)</p>
            </li>
<li class="listitem">
                <p><code class="constant">Zend_Validate_Isbn::ISBN10</code></p>
            </li>
<li class="listitem">
                <p><code class="constant">Zend_Validate_Isbn::ISBN13</code></p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.separator"></a>Specifying a separator restriction</h4></div></div></div>
        

        <p>
            An example of separator restriction is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Isbn();
$validator-&gt;setSeparator('-');
// OR
$validator = new Zend_Validate_Isbn(array(
    'separator' =&gt; '-',
));

if ($validator-&gt;isValid($isbn)) {
    // this is a valid ISBN with separator
} else {
    // this is an invalid ISBN with separator
}
</pre>

        <div class="note"><table border="0" summary="Note: Values without separator">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Values without separator</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                This will return <code class="constant">FALSE</code> if <code class="varname">$isbn</code> doesn't
                contain a separator <span class="emphasis"><em>or</em></span> if it's an invalid
                <acronym class="acronym">ISBN</acronym> value.
            </p>
        </td></tr>
</table></div>

        <p>
            Valid separators include:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><p>"" (empty) (default)</p></li>
<li class="listitem"><p>"-" (hyphen)</p></li>
<li class="listitem"><p>" " (space)</p></li>
</ul></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.lessthan"></a>LessThan</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_LessThan</code> allows you to validate if a given value is
        less than a maximum border value. It is the cousine of
        <code class="classname">Zend_Validate_GreaterThan</code>.
    </p>

    <div class="note"><table border="0" summary="Note: Zend_Validate_LessThan supports only number validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Zend_Validate_LessThan supports only number validation</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            It should be noted that <code class="classname">Zend_Validate_LessThan</code> supports only the
            validation of numbers. Strings or dates can not be validated with this validator.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.lessthan.options"></a>Supported options for Zend_Validate_LessThan</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_LessThan</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">max</span></em></span>: Sets the maximum allowed value.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.lessthan.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            To validate if a given value is less than a defined border simply use the following
            example.
        </p>

        <pre class="programlisting">
$valid  = new Zend_Validate_LessThan(array('max' =&gt; 10));
$value  = 10;
$return = $valid-&gt;isValid($value);
// returns true
</pre>

        <p>
            The above example returns <code class="constant">TRUE</code> for all values which are equal to 10
            or lower than 10.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.notempty"></a>NotEmpty</h3></div></div></div>
    

    <p>
        This validator allows you to validate if a given value is not empty. This is often useful
        when working with form elements or other user input, where you can use it to ensure required
        elements have values associated with them.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.notempty.options"></a>Supported options for Zend_Validate_NotEmpty</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_NotEmpty</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span>: Sets the type of validation
                    which will be processed. For details take a look into <a class="link" href="zend.validate.set.html#zend.validate.set.notempty.types" title="Changing behaviour for Zend_Validate_NotEmpty">this section</a>.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.notempty.default"></a>Default behaviour for Zend_Validate_NotEmpty</h4></div></div></div>
        

        <p>
            By default, this validator works differently than you would expect when you've worked
            with <acronym class="acronym">PHP</acronym>'s <code class="methodname">empty()</code> function. In
            particular, this validator will evaluate both the integer <span class="emphasis"><em>0</em></span> and
            string '<span class="emphasis"><em>0</em></span>' as empty.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_NotEmpty();
$value  = '';
$result = $valid-&gt;isValid($value);
// returns false
</pre>

        <div class="note"><table border="0" summary="Note: Default behaviour differs from PHP">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Default behaviour differs from PHP</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Without providing configuration, <code class="classname">Zend_Validate_NotEmpty</code>'s
                behaviour differs from <acronym class="acronym">PHP</acronym>.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.notempty.types"></a>Changing behaviour for Zend_Validate_NotEmpty</h4></div></div></div>
        

        <p>
            Some projects have differing opinions of what is considered an "empty" value: a string
            with only whitespace might be considered empty, or <span class="emphasis"><em>0</em></span> may be
            considered non-empty (particularly for boolean sequences). To accomodate differing
            needs, <code class="classname">Zend_Validate_NotEmpty</code> allows you to configure which types
            should be validated as empty and which not.
        </p>

        <p>
            The following types can be handled:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>boolean</em></span>: Returns <code class="constant">FALSE</code> when the
                    boolean value is <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>integer</em></span>: Returns <code class="constant">FALSE</code> when an integer
                    <span class="emphasis"><em>0</em></span> value is given. Per default this validation is not
                    activated and returns <code class="constant">TRUE</code> on any integer values.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>float</em></span>: Returns <code class="constant">FALSE</code> when an float
                    <span class="emphasis"><em>0.0</em></span> value is given. Per default this validation is not
                    activated and returns <code class="constant">TRUE</code> on any float values.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>string</em></span>: Returns <code class="constant">FALSE</code> when an empty
                    string <span class="emphasis"><em>''</em></span> is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>zero</em></span>: Returns <code class="constant">FALSE</code> when the single
                    character zero (<span class="emphasis"><em>'0'</em></span>) is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>empty_array</em></span>: Returns <code class="constant">FALSE</code> when an
                    empty <span class="emphasis"><em>array</em></span> is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>null</em></span>: Returns <code class="constant">FALSE</code> when an
                    <code class="constant">NULL</code> value is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>php</em></span>: Returns <code class="constant">FALSE</code> on the same reasons
                    where <acronym class="acronym">PHP</acronym> method <code class="methodname">empty()</code> would
                    return <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>space</em></span>: Returns <code class="constant">FALSE</code> when an string
                    is given which contains only whitespaces.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>object</em></span>: Returns <code class="constant">TRUE</code>.
                    <code class="constant">FALSE</code> will be returned when <span class="property">object</span> is
                    not allowed but an object is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>object_string</em></span>: Returns <code class="constant">FALSE</code> when an
                    object is given and it's <code class="methodname">__toString()</code> method returns an
                   empty string.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>object_count</em></span>: Returns <code class="constant">FALSE</code> when an
                    object is given, it has an <code class="classname">Countable</code> interface and it's
                    count is 0.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>all</em></span>: Returns <code class="constant">FALSE</code> on all above types.
                </p>
            </li>
</ul></div>

        <p>
            All other given values will return <code class="constant">TRUE</code> per default.
        </p>

        <p>
            There are several ways to select which of the above types are validated. You can give
            one or multiple types and add them, you can give an array, you can use constants, or you
            can give a textual string. See the following examples:
        </p>

        <pre class="programlisting">
// Returns false on 0
$validator = new Zend_Validate_NotEmpty(Zend_Validate_NotEmpty::INTEGER);

// Returns false on 0 or '0'
$validator = new Zend_Validate_NotEmpty(
    Zend_Validate_NotEmpty::INTEGER + Zend_NotEmpty::ZERO
);

// Returns false on 0 or '0'
$validator = new Zend_Validate_NotEmpty(array(
    Zend_Validate_NotEmpty::INTEGER,
    Zend_Validate_NotEmpty::ZERO
));

// Returns false on 0 or '0'
$validator = new Zend_Validate_NotEmpty(array(
    'integer',
    'zero',
));
</pre>

        <p>
            You can also provide an instance of <code class="classname">Zend_Config</code> to set the
            desired types. To set types after instantiation, use the
            <code class="methodname">setType()</code> method.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.post_code"></a>PostCode</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_PostCode</code> allows you to determine if a given value is a
        valid postal code. Postal codes are specific to cities, and in some locales termed
        <acronym class="acronym">ZIP</acronym> codes.
    </p>

    <p>
        <code class="classname">Zend_Validate_PostCode</code> knows more than 160 different postal code
        formates. To select the correct format there are 2 ways. You can either use a fully
        qualified locale or you can set your own format manually.
    </p>

    <p>
        Using a locale is more convenient as Zend Framework already knows the appropriate postal
        code format for each locale; however, you need to use the fully qualified locale (one
        containing a region specifier) to do so. For instance, the locale "de" is a locale but
        could not be used with <code class="classname">Zend_Validate_PostCode</code> as it does not include
        the region; "de_AT", however, would be a valid locale, as it specifies the region code
        ("AT", for Austria).
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_PostCode('de_AT');
</pre>

    <p>
        When you don't set a locale yourself, then <code class="classname">Zend_Validate_PostCode</code>
        will use the application wide set locale, or, when there is none, the locale returned by
        <code class="classname">Zend_Locale</code>.
    </p>

    <pre class="programlisting">
// application wide locale within your bootstrap
$locale = new Zend_Locale('de_AT');
Zend_Registry::set('Zend_Locale', $locale);

$validator = new Zend_Validate_PostCode();
</pre>

    <p>
        You can also change the locale afterwards by calling <code class="methodname">setLocale()</code>.
        And of course you can get the actual used locale by calling
        <code class="methodname">getLocale()</code>.
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_PostCode('de_AT');
$validator-&gt;setLocale('en_GB');
</pre>

    <p>
        Postal code formats themself are simply regular expression strings. When the international
        postal code format, which is used by setting the locale, does not fit your needs, then you
        can also manually set a format by calling <code class="methodname">setFormat()</code>.
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_PostCode('de_AT');
$validator-&gt;setFormat('AT-\d{5}');
</pre>

    <div class="note"><table border="0" summary="Note: Conventions for self defined formats">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Conventions for self defined formats</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            When using self defined formats you should omit the starting (<span class="command"><strong>'/^'</strong></span>)
            and ending tags (<span class="command"><strong>'$/'</strong></span>). They are attached automatically.
        </p>

        <p>
            You should also be aware that postcode values are always be validated in a strict way.
            This means that they have to be written standalone without additional characters when
            they are not covered by the format.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.post_code.constructor"></a>Constructor options</h4></div></div></div>
        

        <p>
            At it's most basic, you may pass either a <code class="classname">Zend_Locale</code> object or a
            string representing a fully qualified locale to the constructor of
            <code class="classname">Zend_Validate_PostCode</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_PostCode('de_AT');
$validator = new Zend_Validate_PostCode($locale);
</pre>

        <p>
            Additionally, you may pass either an array or a <code class="classname">Zend_Config</code>
            object to the constructor. When you do so, you must include either the key "locale" or
            "format"; these will be used to set the appropriate values in the validator object.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_PostCode(array(
    'locale' =&gt; 'de_AT',
    'format' =&gt; 'AT_\d+'
));
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.post_code.options"></a>Supported options for Zend_Validate_PostCode</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_PostCode</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">format</span></em></span>: Sets a postcode format which
                    will be used for validation of the input.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: Sets a locale from which the
                    postcode will be taken from.
                </p>
            </li>
</ul></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.regex"></a>Regex</h3></div></div></div>
    

    <p>
        This validator allows you to validate if a given string conforms a defined regular
        expression.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.regex.options"></a>Supported options for Zend_Validate_Regex</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Regex</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">pattern</span></em></span>: Sets the regular expression
                    pattern for this validator.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.regex.basic"></a>Validation with Zend_Validate_Regex</h4></div></div></div>
        

        <p>
            Validation with regular expressions allows to have complicated validations being done
            without writing a own validator. The usage of regular expression is quite common and
            simple. Let's look at some examples:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Regex(array('pattern' =&gt; '/^Test/');

$validator-&gt;isValid("Test"); // returns true
$validator-&gt;isValid("Testing"); // returns true
$validator-&gt;isValid("Pest"); // returns false
</pre>

        <p>
            As you can see, the pattern has to be given using the same syntax as for
            <code class="methodname">preg_match()</code>. For details about regular expressions take a look
            into <a class="ulink" href="http://php.net/manual/en/reference.pcre.pattern.syntax.php" target="_top">PHP's
                manual about PCRE pattern syntax</a>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.regex.handling"></a>Pattern handling</h4></div></div></div>
        

        <p>
            It is also possible to set a different pattern afterwards by using
            <code class="methodname">setPattern()</code> and to get the actual set pattern with
            <code class="methodname">getPattern()</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Regex(array('pattern' =&gt; '/^Test/');
$validator-&gt;setPattern('ing$/');

$validator-&gt;isValid("Test"); // returns false
$validator-&gt;isValid("Testing"); // returns true
$validator-&gt;isValid("Pest"); // returns false
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.sitemap"></a>Sitemap Validators</h3></div></div></div>
    

    <p>
        The following validators conform to the <a class="ulink" href="http://www.sitemaps.org/protocol.php" target="_top">Sitemap <acronym class="acronym">XML</acronym>
            protocol</a>.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.changefreq"></a>Sitemap_Changefreq</h4></div></div></div>
        

        <p>
            Validates whether a string is valid for using as a 'changefreq'
            element in a Sitemap <acronym class="acronym">XML</acronym> document. Valid values are: 'always',
            'hourly', 'daily', 'weekly', 'monthly', 'yearly', or 'never'.
        </p>

        <p>
            Returns <code class="constant">TRUE</code> if and only if the value is a string
            and is equal to one of the frequencies specified above.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.lastmod"></a>Sitemap_Lastmod</h4></div></div></div>
        

        <p>
            Validates whether a string is valid for using as a 'lastmod'
            element in a Sitemap <acronym class="acronym">XML</acronym> document. The lastmod element should
            contain a <acronym class="acronym">W3C</acronym> date string, optionally discarding information
            about time.
        </p>

        <p>
            Returns <code class="constant">TRUE</code> if and only if the given value is
            a string and is valid according to the protocol.
        </p>

        <div class="example">
<a name="zend.validate.sitemap.lastmod.example"></a><p class="title"><b>Exemplo 941. Sitemap Lastmod Validator</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$validator = new Zend_Validate_Sitemap_Lastmod();

$validator-&gt;isValid('1999-11-11T22:23:52-02:00'); // true
$validator-&gt;isValid('2008-05-12T00:42:52+02:00'); // true
$validator-&gt;isValid('1999-11-11'); // true
$validator-&gt;isValid('2008-05-12'); // true

$validator-&gt;isValid('1999-11-11t22:23:52-02:00'); // false
$validator-&gt;isValid('2008-05-12T00:42:60+02:00'); // false
$validator-&gt;isValid('1999-13-11'); // false
$validator-&gt;isValid('2008-05-32'); // false
$validator-&gt;isValid('yesterday'); // false
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.loc"></a>Sitemap_Loc</h4></div></div></div>
        

        <p>
            Validates whether a string is valid for using as a 'loc'
            element in a Sitemap <acronym class="acronym">XML</acronym> document. This uses
            <code class="methodname">Zend_Form::check()</code> internally. Read more at
            <a class="link" href="zend.uri.chapter.html#zend.uri.validation" title="URI Validation">URI Validation</a>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.priority"></a>Sitemap_Priority</h4></div></div></div>
        

        <p>
            Validates whether a value is valid for using as a 'priority'
            element in a Sitemap <acronym class="acronym">XML</acronym> document. The value should be a
            decimal between 0.0 and 1.0. This validator accepts both numeric
            values and string values.
        </p>

        <div class="example">
<a name="zend.validate.sitemap.priority.example"></a><p class="title"><b>Exemplo 942. Sitemap Priority Validator</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$validator = new Zend_Validate_Sitemap_Priority();

$validator-&gt;isValid('0.1'); // true
$validator-&gt;isValid('0.789'); // true
$validator-&gt;isValid(0.8); // true
$validator-&gt;isValid(1.0); // true

$validator-&gt;isValid('1.1'); // false
$validator-&gt;isValid('-0.4'); // false
$validator-&gt;isValid(1.00001); // false
$validator-&gt;isValid(0xFF); // false
$validator-&gt;isValid('foo'); // false
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.sitemap.options"></a>Supported options for Zend_Validate_Sitemap_*</h4></div></div></div>
        

        <p>
            There are no supported options for any of the Sitemap validators.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.stringlength"></a>StringLength</h3></div></div></div>
    

    <p>
        This validator allows you to validate if a given string is between a defined length.
    </p>

    <div class="note"><table border="0" summary="Note: Zend_Validate_StringLength supports only string validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Zend_Validate_StringLength supports only string validation</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            It should be noted that <code class="classname">Zend_Validate_StringLength</code> supports only
            the validation of strings. Integers, floats, dates or objects can not be validated with
            this validator.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.options"></a>Supported options for Zend_Validate_StringLength</h4></div></div></div>
        

        <p>
            The following options are supported for
            <code class="classname">Zend_Validate_StringLength</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">encoding</span></em></span>: Sets the
                    <code class="constant">ICONV</code> encoding which has to be used for this string.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">min</span></em></span>: Sets the minimum allowed length
                    for a string.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">max</span></em></span>: Sets the maximum allowed length
                    for a string.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.basic"></a>Default behaviour for Zend_Validate_StringLength</h4></div></div></div>
        

        <p>
            Per default this validator checks if a value is between <span class="property">min</span> and
            <span class="property">max</span>. But for <span class="property">min</span> the default value is
            <span class="emphasis"><em>0</em></span> and for <span class="property">max</span> it is
            <span class="emphasis"><em><code class="constant">NULL</code></em></span> which means unlimited.
        </p>

        <p>
            So per default, without giving any options, this validator only checks if the input
            is a string.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.maximum"></a>Limiting the maximum allowed length of a string</h4></div></div></div>
        

        <p>
            To limit the maximum allowed length of a string you need to set the
            <span class="property">max</span> property. It accepts an integer value as input.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength(array('max' =&gt; 6));

$validator-&gt;isValid("Test"); // returns true
$validator-&gt;isValid("Testing"); // returns false
</pre>

        <p>
            You can set the maximum allowed length also afterwards by using the
            <code class="methodname">setMax()</code> method. And <code class="methodname">getMax()</code> to
            retrieve the actual maximum border.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength();
$validator-&gt;setMax(6);

$validator-&gt;isValid("Test"); // returns true
$validator-&gt;isValid("Testing"); // returns false
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.minimum"></a>Limiting the minimal required length of a string</h4></div></div></div>
        

        <p>
            To limit the minimal required length of a string you need to set the
            <span class="property">min</span> property. It accepts also an integer value as input.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength(array('min' =&gt; 5));

$validator-&gt;isValid("Test"); // returns false
$validator-&gt;isValid("Testing"); // returns true
</pre>

        <p>
            You can set the minimal requested length also afterwards by using the
            <code class="methodname">setMin()</code> method. And <code class="methodname">getMin()</code> to
            retrieve the actual minimum border.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength();
$validator-&gt;setMin(5);

$validator-&gt;isValid("Test"); // returns false
$validator-&gt;isValid("Testing"); // returns true
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.both"></a>Limiting a string on both sides</h4></div></div></div>
        

        <p>
            Sometimes it is required to get a string which has a maximal defined length but which
            is also minimal chars long. For example when you have a textbox where a user can enter
            his name, then you may want to limit the name to maximum 30 chars but want to get sure
            that he entered his name. So you limit the mimimum required length to 3 chars. See the
            following example:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength(array('min' =&gt; 3, 'max' =&gt; 30));

$validator-&gt;isValid("."); // returns false
$validator-&gt;isValid("Test"); // returns true
$validator-&gt;isValid("Testing"); // returns true
</pre>

        <div class="note"><table border="0" summary="Note: Setting a lower maximum border than the minimum border">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Setting a lower maximum border than the minimum border</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                When you try to set a lower maximum value as the actual minimum value, or a
                higher minimum value as the actual maximum value, then an exception will be
                raised.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.encoding"></a>Encoding of values</h4></div></div></div>
        

        <p>
            Strings are always using a encoding. Even when you don't set the encoding explicit,
            <acronym class="acronym">PHP</acronym> uses one. When your application is using a different encoding
            than <acronym class="acronym">PHP</acronym> itself then you should set an encoding yourself.
        </p>

        <p>
            You can set your own encoding at initiation with the <span class="property">encoding</span>
            option, or by using the <code class="methodname">setEncoding()</code> method. We assume that
            your installation uses <acronym class="acronym">ISO</acronym> and your application it set to
            <acronym class="acronym">ISO</acronym>. In this case you will see the below behaviour.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength(
    array('min' =&gt; 6)
);
$validator-&gt;isValid("Ärger"); // returns false

$validator-&gt;setEncoding("UTF-8");
$validator-&gt;isValid("Ärger"); // returns true

$validator2 = new Zend_Validate_StringLength(
    array('min' =&gt; 6, 'encoding' =&gt; 'UTF-8')
);
$validator2-&gt;isValid("Ärger"); // returns true
</pre>

        <p>
            So when your installation and your application are using different encodings, then you
            should always set an encoding yourself.
        </p>
    </div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.validate.introduction.html">Anterior</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.validate.html">Acima</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.validate.validator_chains.html">Próxima</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Introduction </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td>
<td width="40%" align="right" valign="top"> Validator Chains</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
