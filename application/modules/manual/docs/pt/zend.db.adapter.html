<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Zend_Db_Adapter</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guia de Referência do Programador">
<link rel="up" href="zend.db.html" title="Zend_Db">
<link rel="prev" href="zend.db.html" title="Zend_Db">
<link rel="next" href="zend.db.statement.html" title="Zend_Db_Statement">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Zend_Db_Adapter</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.db.html">Anterior</a> </td>
<th width="60%" align="center">Zend_Db</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.db.statement.html">Próxima</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.adapter"></a>Zend_Db_Adapter</h2></div></div></div>
    

    <p>
        <code class="classname">Zend_Db</code> e suas classes relacionadas provêem uma interface de banco
        de dados <acronym class="acronym">SQL</acronym> simples para Zend Framework.
        <code class="classname">Zend_Db_Adapter</code> é a classe básica que você usa para conectar sua
        aplicação <acronym class="acronym">PHP</acronym>a um <acronym class="acronym">SGBDR</acronym>. Há uma classe adaptadora
        diferente para cada marca de <acronym class="acronym">SGBDR</acronym>.
    </p>

    <p>
        Os adaptadores <code class="classname">Zend_Db</code> criam uma ponte entre extensões
        <acronym class="acronym">PHP</acronym> específicas de cada fabricante para uma interface comum que ajuda
        você a escrever aplicações <acronym class="acronym">PHP</acronym> uma vez e distribui-las com múltiplas
        marcas de <acronym class="acronym">SGBDR</acronym> com muito pouco esforço.
    </p>

    <p>
        A interface da classe adaptadora é similar à interface da extensão
        <a class="ulink" href="http://www.php.net/pdo" target="_top">PHP Data Objects</a>.
        <code class="classname">Zend_Db</code> provê classes adaptadoras para drivers
        <acronym class="acronym">PDO</acronym> das seguintes marcas de <acronym class="acronym">SGBDR</acronym>:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                <acronym class="acronym">IBM</acronym> <acronym class="acronym">DB2</acronym> e Informix Dynamic Server
                (<acronym class="acronym">IDS</acronym>), usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/pdo-ibm" target="_top">pdo_ibm</a>
            </p>
        </li>
<li class="listitem">
            <p>
                MariaDB, usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/pdo-mysql" target="_top">pdo_mysql</a>
            </p>
        </li>
<li class="listitem">
            <p>
                MySQL, usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/pdo-mysql" target="_top">pdo_mysql</a>
            </p>
        </li>
<li class="listitem">
            <p>
                Microsoft <acronym class="acronym">SQL</acronym> Server, usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/pdo-dblib" target="_top">pdo_dblib</a>
            </p>
        </li>
<li class="listitem">
            <p>
                Oracle, usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/pdo-oci" target="_top">pdo_oci</a>
            </p>
        </li>
<li class="listitem">
            <p>
                PostgreSQL, usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/pdo-pgsql" target="_top">pdo_pgsql</a>
            </p>
        </li>
<li class="listitem">
            <p>
                SQLite, usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/pdo-sqlite" target="_top">pdo_sqlite</a>
            </p>
        </li>
</ul></div>

    <p>
        Além disso, <code class="classname">Zend_Db</code> provê classes adaptadoras que utilizam extensões
        de bancos de dados
        <acronym class="acronym">PHP</acronym> para as seguintes marcas de <acronym class="acronym">SGBDR</acronym>:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                MariaDB, usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/mysqli" target="_top">mysqli</a>
            </p>
        </li>
<li class="listitem">
            <p>
                MySQL, usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/mysqli" target="_top">mysqli</a>
            </p>
        </li>
<li class="listitem">
            <p>
                Oracle, usando a extensão <acronym class="acronym">PHP</acronym>
                <a class="ulink" href="http://www.php.net/oci8" target="_top">oci8</a>
            </p>
        </li>
<li class="listitem">
            <p>
                <acronym class="acronym">IBM</acronym> <acronym class="acronym">DB2</acronym> e <acronym class="acronym">DB2</acronym> I5, usando a
                extensão <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/ibm_db2" target="_top">ibm_db2</a>
            </p>
        </li>
<li class="listitem">
            <p>
                Firebird (Interbase), usando a extensão <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/ibase" target="_top">php_interbase</a>
            </p>
        </li>
</ul></div>

    <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">
        <p>
            Cada classe adaptadora <code class="classname">Zend_Db</code> usa uma extensão
            <acronym class="acronym">PHP</acronym>. Você deve ter a respectiva extensão <acronym class="acronym">PHP</acronym>
            habilitada em seu ambiente <acronym class="acronym">PHP</acronym> para usar uma classe adaptadora
            <code class="classname">Zend_Db</code>. Por exemplo, se você usa qualquer uma das classes
            adaptadoras <acronym class="acronym">PDO</acronym> do <code class="classname">Zend_Db</code>
            , você precisa habilitar tanto a extensão <acronym class="acronym">PDO</acronym> quanto o driver
            <acronym class="acronym">PDO</acronym> para a marca de <acronym class="acronym">SGBDR</acronym> que você usa.
        </p>
    </td></tr>
</table></div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.connecting"></a>Conectando-se a um Banco de Dados Usando uma Adaptadora</h3></div></div></div>
        

        <p>
            Esta seção descreve como criar uma instância de uma classe adaptadora de banco de
            dados. Isso corresponde a fazer uma conexão com seu servidor <acronym class="acronym">SGBDR</acronym> a
            partir de sua aplicação <acronym class="acronym">PHP</acronym>.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.constructor"></a>Usando um Construtor de Adaptadora Zend_Db</h4></div></div></div>
            

            <p>
                Você pode criar uma instância de uma classe adaptadora usando seu construtor.
                Um construtor de classe adaptadora leva um argumento, que é um matriz
                de parâmetros usado para declarar a conexão.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.constructor.example"></a><p class="title"><b>Exemplo 186. Usando um Construtor de Adaptadora</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db = new Zend_Db_Adapter_Pdo_Mysql(array(
    'host'     =&gt; '127.0.0.1',
    'username' =&gt; 'webuser',
    'password' =&gt; 'xxxxxxxx',
    'dbname'   =&gt; 'test'
));
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.factory"></a>Usando a Fábrica Zend_Db</h4></div></div></div>
            

            <p>
                Como uma alternativa ao uso direto do construtor da classe adaptadora, você
                pode criar uma instância de uma adaptadora usando o método estático
                <code class="methodname">Zend_Db::factory()</code>. Este método carrega dinamicamente
                o arquivo da classe adaptadora sob demanda usando o método
                <a class="link" href="zend.loader.load.html#zend.loader.load.class" title="Loading Classes">Zend_Loader::loadClass()</a>.
            </p>

            <p>
                O primeiro argumento é um string que identifica o nome base da
                classe adaptadora. Por exemplo, a string '<code class="classname">Pdo_Mysql</code>'
                corresponde à classe <code class="classname">Zend_Db_Adapter_Pdo_Mysql</code>. O segundo
                argumento é a mesma matriz de parâmetros que você teria passado para
                o construtor da adaptadora.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.factory.example"></a><p class="title"><b>Exemplo 187. Using the Adapter Factory Method</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// Nós não precisamos seguir a declaração a seguir porque o
// arquivo Zend_Db_Adapter_Pdo_Mysql será carregado para nós pelo método Zend_Db
// factory.

// require_once 'Zend/Db/Adapter/Pdo/Mysql.php';

// Carrega automaticamente a classe Zend_Db_Adapter_Pdo_Mysql
// e cria uma instância dela.
$db = Zend_Db::factory('Pdo_Mysql', array(
    'host'     =&gt; '127.0.0.1',
    'username' =&gt; 'webuser',
    'password' =&gt; 'xxxxxxxx',
    'dbname'   =&gt; 'test'
));
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Se você criar sua própria classe que estende
                <code class="classname">Zend_Db_Adapter_Abstract</code>, mas não nomear sua
                classe com o prefixo de pacote "<code class="classname">Zend_Db_Adapter</code>", você pode
                usar o método <code class="methodname">factory()</code> para carregar sua adaptadora se
                você especificar a parte principal da classe adaptadora com a
                chave 'adapterNamespace' na matriz de parâmetros.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.factory.example2"></a><p class="title"><b>Exemplo 188. 
                Usando o Método de Fábrica da Adaptadora para uma Classe Adaptadora Personalizada
                </b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// Nós não precisamos carregar o arquivo da classe adaptadora
// porque ele será carregado para nós pelo método de fábrica do Zend_Db.

// Carrega automaticamente a classe MyProject_Db_Adapter_Pdo_Mysql e cria
// uma instância dela.
$db = Zend_Db::factory('Pdo_Mysql', array(
    'host'             =&gt; '127.0.0.1',
    'username'         =&gt; 'webuser',
    'password'         =&gt; 'xxxxxxxx',
    'dbname'           =&gt; 'test',
    'adapterNamespace' =&gt; 'MyProject_Db_Adapter'
));
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.factory-config"></a>Usando Zend_Config com Zend_Db Factory</h4></div></div></div>
            

            <p>
                Opcionalmente, você pode especificar cada argumento do
                método <code class="methodname">factory()</code> como um objeto do tipo
                <a class="link" href="zend.config.html" title="Zend_Config">Zend_Config</a>.
            </p>

            <p>
                Se o primeiro argumento é um objeto de configuração, espera-se que
                ele contenha uma propriedade chamada <span class="property">adapter</span>, contendo uma
                string que designa a base do nome da classe adaptadora. Opcionalmente, o objeto
                pode conter uma propriedade chamada <span class="property">params</span>, com
                subpropriedades correspondentes aos nomes de parâmetro da adaptadora.
                Isso é usado somente se o segundo argumento do
                método <code class="methodname">factory()</code> for omitido.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.factory.example1"></a><p class="title"><b>Exemplo 189. Usando o Método de Fábrica da Adaptadora com um Objeto Zend_Config</b></p>
<div class="example-contents">
                

                <p>
                    No exemplo abaixo, um objeto <code class="classname">Zend_Config</code> é criado
                    a partir de um matriz. Você pode também carregar dados a partir de um arquivo
                    externo usando classes tais como
                    <a class="link" href="zend.config.adapters.ini.html" title="Zend_Config_Ini">Zend_Config_Ini</a>
                    e <a class="link" href="zend.config.adapters.xml.html" title="Zend_Config_Xml">Zend_Config_Xml</a>.
                </p>

                <pre class="programlisting">
$config = new Zend_Config(
    array(
        'database' =&gt; array(
            'adapter' =&gt; 'Mysqli',
            'params'  =&gt; array(
                'host'     =&gt; '127.0.0.1',
                'dbname'   =&gt; 'test',
                'username' =&gt; 'webuser',
                'password' =&gt; 'secret',
            )
        )
    )
);

$db = Zend_Db::factory($config-&gt;database);
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                O segundo argumento do método <code class="methodname">factory()</code> pode ser
                um matriz associativo contendo entradas correspondentes aos
                parâmetros da adaptadora. Esse argumento é opcional. Se o primeiro
                argumento é do tipo <code class="classname">Zend_Config</code>, é assumido que ele contém
                todos os parâmetros, e o segundo argumento é ignorado
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.parameters"></a>Parâmetros da Adaptadora</h4></div></div></div>
            

            <p>
                A seguinte lista explica parâmetros comuns reconhecidos pelas
                classes adaptadoras <code class="classname">Zend_Db</code>.
            </p>

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>host</em></span>:
                        uma string contendo um hostname ou endereço IP do
                        servidor de banco de dados. Se o banco de dados está rodando no
                        mesmo servidor anfitrião da aplicação <acronym class="acronym">PHP</acronym>, você pode
                        usar 'localhost' ou '127.0.0.1'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>username</em></span>:
                        identificador da conta para autenticar uma conexão com o
                        servidor <acronym class="acronym">SGBDR</acronym>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>password</em></span>:
                        credencial de senha para autenticar uma
                        conexão com o servidor <acronym class="acronym">SGBDR</acronym>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>dbname</em></span>:
                        nome da instância do banco de dados no servidor <acronym class="acronym">SGBDR</acronym>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>port</em></span>:
                        alguns servidores <acronym class="acronym">SGBDR</acronym> podem aceitar conexões de rede
                        em um número de porta especificado pelo administrador. O parâmetro port
                        permite que você especifique a porta a qual sua
                        aplicação <acronym class="acronym">PHP</acronym> se conecta, para casar com a porta
                        configurada no servidor <acronym class="acronym">SGBDR</acronym>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>charset</em></span>:
                        especifica o conjunto de caracteres usado para a conexão.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>options</em></span>:
                        este parâmetro é um matriz associativo de opções
                        que são genéricas para todas as classes
                        <code class="classname">Zend_Db_Adapter</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>driver_options</em></span>:
                        este parâmetro é um matriz associativo de opções
                        adicionais que são específicas para uma dada extensão
                        de banco de dados. Um uso típico deste parâmetro é para
                        configurar atributos de um driver <acronym class="acronym">PDO</acronym>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>adapterNamespace</em></span>:
                        nomeia a parte inicial do nome da classe para a
                        adaptadora, em vez de '<code class="classname">Zend_Db_Adapter</code>'. Use isto se
                        você precisar do método <code class="methodname">factory()</code> para
                        carregar uma classe adaptadora de banco de dados não-Zend.
                    </p>
                </li>
</ul></div>

            <div class="example">
<a name="zend.db.adapter.connecting.parameters.example1"></a><p class="title"><b>Exemplo 190. Passando a Opção Case-Folding para a Fábrica</b></p>
<div class="example-contents">
                

                <p>
                    Você pode especificar essa opção pela constante
                    <code class="constant">Zend_Db::CASE_FOLDING</code>. Ela corresponde ao atributo
                    <code class="constant">ATTR_CASE</code> nos drivers de banco de dados
                    <acronym class="acronym">PDO</acronym> e <acronym class="acronym">IBM</acronym> <acronym class="acronym">DB2</acronym>,
                    ajustando a caixa das chaves de string nos conjuntos de resultado de consulta.
                    A opção leva os valores <code class="constant">Zend_Db::CASE_NATURAL</code> (padrão),
                    <code class="constant">Zend_Db::CASE_UPPER</code>, e
                    <code class="constant">Zend_Db::CASE_LOWER</code>.
                </p>

                <pre class="programlisting">
$options = array(
    Zend_Db::CASE_FOLDING =&gt; Zend_Db::CASE_UPPER
);

$params = array(
    'host'           =&gt; '127.0.0.1',
    'username'       =&gt; 'webuser',
    'password'       =&gt; 'xxxxxxxx',
    'dbname'         =&gt; 'test',
    'options'        =&gt; $options
);

$db = Zend_Db::factory('Db2', $params);
</pre>
            </div>
</div>
<br class="example-break">

            <div class="example">
<a name="zend.db.adapter.connecting.parameters.example2"></a><p class="title"><b>Exemplo 191. Passando a Opção Auto-Quoting para a Fábrica</b></p>
<div class="example-contents">
                

                <p>
                    Você pode especificar essa opção pela constante
                    <code class="constant">Zend_Db::AUTO_QUOTE_IDENTIFIERS</code>. Se o valor
                    é <code class="constant">TRUE</code> (padrão), identificadores como nomes de
                    tabela, nomes de coluna, e mesmo apelidos são delimitados em toda
                    sintaxe <acronym class="acronym">SQL</acronym> gerada pelo objeto adaptador. Isso torna simples
                    usar identificadores que contêm palavras-chave <acronym class="acronym">SQL</acronym>, ou
                    caracteres especiais. Se o valor é <code class="constant">FALSE</code>,
                    identificadores não são delimitados automaticamente. Se você precisa
                    delimitar identificadores, você deve fazer por conta própria usando
                    o método <code class="methodname">quoteIdentifier()</code>.
                </p>

                <pre class="programlisting">
$options = array(
    Zend_Db::AUTO_QUOTE_IDENTIFIERS =&gt; false
);

$params = array(
    'host'           =&gt; '127.0.0.1',
    'username'       =&gt; 'webuser',
    'password'       =&gt; 'xxxxxxxx',
    'dbname'         =&gt; 'test',
    'options'        =&gt; $options
);

$db = Zend_Db::factory('Pdo_Mysql', $params);
</pre>
            </div>
</div>
<br class="example-break">

            <div class="example">
<a name="zend.db.adapter.connecting.parameters.example3"></a><p class="title"><b>Exemplo 192. Passando Opções de Driver PDO para a Fábrica</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$pdoParams = array(
    PDO::MYSQL_ATTR_USE_BUFFERED_QUERY =&gt; true
);

$params = array(
    'host'           =&gt; '127.0.0.1',
    'username'       =&gt; 'webuser',
    'password'       =&gt; 'xxxxxxxx',
    'dbname'         =&gt; 'test',
    'driver_options' =&gt; $pdoParams
);

$db = Zend_Db::factory('Pdo_Mysql', $params);

echo $db-&gt;getConnection()
        -&gt;getAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY);
</pre>
            </div>
</div>
<br class="example-break">

            <div class="example">
<a name="zend.db.adapter.connecting.parameters.example4"></a><p class="title"><b>Exemplo 193. Passando Opções de Serialização para a Fábrica</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$options = array(
    Zend_Db::ALLOW_SERIALIZATION =&gt; false
);

$params = array(
    'host'           =&gt; '127.0.0.1',
    'username'       =&gt; 'webuser',
    'password'       =&gt; 'xxxxxxxx',
    'dbname'         =&gt; 'test',
    'options'        =&gt; $options
);

$db = Zend_Db::factory('Pdo_Mysql', $params);
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.getconnection"></a>Gerenciando Conexões Preguiçosas</h4></div></div></div>
            

            <p>
                Criar uma instância de uma classe adaptadora não abre uma conexão
                com o servidor <acronym class="acronym">SGBDR</acronym> imediatamente. A adaptadora guarda os
                parâmetros de conexão, e a estabelece por demanda, na primeira
                vez que você precisar executar uma consulta. Isso garante que
                criar um objeto adaptador é rápido é barato. Você pode
                criar uma instância de uma adaptadora mesmo se não estiver certo
                que precisa rodar quaisquer consultas de banco de dados durante a requisição
                atual que sua aplicação está servindo.
            </p>

            <p>
                Se você precisa forçar a adaptador a se conectar ao <acronym class="acronym">SGBDR</acronym>, use
                o método <code class="methodname">getConnection()</code>. Esse método retorna
                um objeto para a conexão como representado pela respectiva
                extensão de banco de dados <acronym class="acronym">PHP</acronym>. Por exemplo, se você usar
                qualquer uma das classes adaptadoras para drivers <acronym class="acronym">PDO</acronym>, então
                <code class="methodname">getConnection()</code> retorna o objeto <acronym class="acronym">PDO</acronym>,
                depois de iniciá-lo como uma conexão ativa para o banco de dados especificado.
            </p>

            <p>
                Pode ser útil forçar a conexão se você quer capturar
                quaisquer exceções que ela lançar como resultado de credenciais de conta
                inválidas, ou outra falha ao conectar-se ao servidor <acronym class="acronym">SGBDR</acronym>.
                Essas exceções não são lançadas até que a conexão seja feita,
                assim isso pode ajudar a simplificar o código de sua aplicação se você manipular as
                exceções em um lugar, em vez de fazê-lo
                na primeira consulta ao banco de dados.
            </p>

            <p>
                Adicionalmente, uma adaptadora pode ser serializada para armazená-la, por exemplo,
                em uma variável de sessão. Isso pode ser muito útil não somente para a
                própria adaptadora, mas para outros objetos que a agreguem, como um
                objeto <code class="classname">Zend_Db_Select</code>. Por padrão, adaptadoras têm permissão
                de serem serializadas, se você não quiser isso, deve considerar passar a
                opção <code class="constant">Zend_Db::ALLOW_SERIALIZATION</code> com
                <code class="constant">FALSE</code>, veja o exemplo abaixo. Em respeito ao princípio de
                conexões preguiçosas, a adaptadora não reconectará a si própria depois de ser
                revertida sua serialização. Você deve então chamar
                <code class="methodname">getConnection()</code> por conta própria. Você pode fazer a
                adaptadora se autorreconectar pela passagem de
                <code class="constant">Zend_Db::AUTO_RECONNECT_ON_UNSERIALIZE</code> com
                <code class="constant">TRUE</code> como uma opção da adaptadora.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.getconnection.example"></a><p class="title"><b>Exemplo 194. Manipulando Exceções de Conexão</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
try {
    $db = Zend_Db::factory('Pdo_Mysql', $parameters);
    $db-&gt;getConnection();
} catch (Zend_Db_Adapter_Exception $e) {
    // talvez uma credencial de login falhou, ou talvez o SGBDR não está rodando
} catch (Zend_Exception $e) {
    // talvez factory() falhou em carregar a classe adaptadora especificada
}
</pre>
            </div>
</div>
<br class="example-break">
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.example-database"></a>Banco de Dados de Exemplo</h3></div></div></div>
        

        <p>
            Na documentação para classes <code class="classname">Zend_Db</code>, nós usamos um conjunto de
            tabelas simples para ilustrar o uso de classes e métodos. Estas
            tabelas de exemplo podem armazenar informações sobre rastreamento de bugs em um
            projeto de desenvolvimento de software. O banco de dados contém quatro tabelas:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>accounts</em></span> armazena
                    informação sobre cada usuário do banco de dados de rastreamento de bugs.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>products</em></span> armazena
                    informação sobre cada produto para o qual um bug pode ser
                    registrado.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>bugs</em></span> armazena informação
                    sobre bugs, incluindo o estado atual do bug, a
                    pessoa que o reportou, a pessoa que se encarregou de
                    corrigí-lo e a pessoa que se encarregou de verificar a
                    correção.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>bugs_products</em></span> armazena um
                    relacionamento entre bugs e produtos. Ela implementa um
                    relacionamento muitos-para-muitos, porque para um dado bug pode ter
                    relevância para múltiplos produtos, e, obviamente, um dado
                    produto pode ter múltiplos bugs.
                </p>
            </li>
</ul></div>

        <p>
            O seguinte pseudocódigo de linguagem de definição de dados <acronym class="acronym">SQL</acronym>
            descreve as tabelas neste banco de dados de exemplo. Estas tabelas de exemplo são
            extensivamente usadas pelos testes unitários automatizados de
            <code class="classname">Zend_Db</code>.
        </p>

        <pre class="programlisting">
CREATE TABLE accounts (
  account_name      VARCHAR(100) NOT NULL PRIMARY KEY
);

CREATE TABLE products (
  product_id        INTEGER NOT NULL PRIMARY KEY,
  product_name      VARCHAR(100)
);

CREATE TABLE bugs (
  bug_id            INTEGER NOT NULL PRIMARY KEY,
  bug_description   VARCHAR(100),
  bug_status        VARCHAR(20),
  reported_by       VARCHAR(100) REFERENCES accounts(account_name),
  assigned_to       VARCHAR(100) REFERENCES accounts(account_name),
  verified_by       VARCHAR(100) REFERENCES accounts(account_name)
);

CREATE TABLE bugs_products (
  bug_id            INTEGER NOT NULL REFERENCES bugs,
  product_id        INTEGER NOT NULL REFERENCES products,
  PRIMARY KEY       (bug_id, product_id)
);
</pre>

        <p>
            Note também que a tabela 'bugs' contém múltiplas referências de chave estrangeira para a
            tabela 'accounts'. Cada uma das chaves estrangeiras pode referenciar uma linha diferente
            na tabela 'accounts' para um dado bug.
        </p>

        <p>
            O diagrama abaixo ilustra o modelo físico de dados do banco de dados de exemplo.
        </p>

        <p>
            <img src="figures/zend.db.adapter.example-database.png" align="middle">
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.select"></a>Lendo Resultados de Consulta</h3></div></div></div>
        

        <p>
            Esta seção descreve métodos da classe adaptadora com os quais você
            pode rodar consultas <acronym class="acronym">SELECT</acronym> e recuperar seus resultados.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchall"></a>Buscando um Conjunto Completo de Resultados</h4></div></div></div>
            

            <p>
                Você pode rodar uma consulta <acronym class="acronym">SQL</acronym> <acronym class="acronym">SELECT</acronym> e
                recuperar seus resultados em um passo usando o método
                <code class="methodname">fetchAll()</code>.
            </p>

            <p>
                O primeiro argumento para este método é uma string contendo uma
                declaração <acronym class="acronym">SELECT</acronym>. Como alternativa, o primeiro argumento pode
                ser um objeto da classe <a class="link" href="zend.db.select.html" title="Zend_Db_Select">Zend_Db_Select</a>.
                A classe adaptadora converte automaticamente esse objeto em uma representação de
                string da declaração <acronym class="acronym">SELECT</acronym>.
            </p>

            <p>
                O segundo argumento para <code class="methodname">fetchAll()</code> é um matriz de
                valores para substituir por curingas de parâmetro na declaração
                <acronym class="acronym">SQL</acronym>.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchall.example"></a><p class="title"><b>Exemplo 195. Usando fetchAll()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$sql = 'SELECT * FROM bugs WHERE bug_id = ?';

$result = $db-&gt;fetchAll($sql, 2);
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetch-mode"></a>Alterando o Modo de Busca</h4></div></div></div>
            

            <p>
                Por padrão, <code class="methodname">fetchAll()</code> retorna um matriz de
                linhas, cada uma das quais é um matriz associativo. As chaves do
                matriz associativo são as colunas ou apelidos de coluna dados
                na consulta de seleção.
            </p>

            <p>
                Você pode especificar um estilo diferente de resultados de busca usando o
                método <code class="methodname">setFetchMode()</code>. Os modos suportados são
                identificados por constantes:
            </p>

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        <span class="emphasis"><em><code class="constant">Zend_Db::FETCH_ASSOC</code></em></span>:
                        retorna dados em um matriz de matrizs associativos.
                        As chaves de matriz são nomes de coluna, como strings. Este é o modo padrão
                        de busca para classes <code class="classname">Zend_Db_Adapter</code>.
                    </p>

                    <p>
                        Note que se sua lista de seleção contém mais de uma
                        coluna com o mesmo nome, por exemplo se elas são de
                        duas tabelas diferentes em um <acronym class="acronym">JOIN</acronym>, pode haver somente
                        uma entrada na matriz associativa para o nome dado.
                        Se você usa o modo <code class="constant">FETCH_ASSOC</code>, deve especificar
                        apelidos de coluna em sua consulta <acronym class="acronym">SELECT</acronym> para garantir
                        que os nomes resultem em chaves de matriz únicas.
                    </p>

                    <p>
                        Por padrão, essas strings são devolvidas como foram
                        devolvidas pelo driver de banco de dados. Isso é tipicamente
                        a leitura da coluna no servidor <acronym class="acronym">SGBDR</acronym>. Você pode
                        especificar a caixa para essas strings, usando a
                        opção <code class="constant">Zend_Db::CASE_FOLDING</code>.
                        Especifique isso quando instanciar a adaptadora.
                        Veja <a class="link" href="zend.db.adapter.html#zend.db.adapter.connecting.parameters.example1" title="Exemplo 190. Passando a Opção Case-Folding para a Fábrica">este
                            exemplo</a>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em><code class="constant">Zend_Db::FETCH_NUM</code></em></span>:
                        retorna dados em um matriz de matrizs. Os matrizs são
                        indexados por inteiros, correspondendo à posição do
                        respectivo campo na lista de seleção da consulta.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em><code class="constant">Zend_Db::FETCH_BOTH</code></em></span>:
                        retorna dados em um matriz de matrizs. As chaves de matriz são
                        tanto strings como as usadas no modo <code class="constant">FETCH_ASSOC</code>, como
                        inteiros como os usados no modo <code class="constant">FETCH_NUM</code>. Note que o
                        número de elementos na matriz é o dobro do que seria se você usasse
                        <code class="constant">FETCH_ASSOC</code> ou <code class="constant">FETCH_NUM</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em><code class="constant">Zend_Db::FETCH_COLUMN</code></em></span>:
                        retorna dados em um matriz de valores. O valor em cada matriz
                        é o valor retornado pela coluna do conjunto de resultados.
                        Por padrão, essa é a primeira coluna, indexada por 0.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em><code class="constant">Zend_Db::FETCH_OBJ</code></em></span>:
                        retorna dados em um matriz de objetos. A classe padrão
                        é a classe interna <acronym class="acronym">PHP</acronym> stdClass. Colunas do conjunto de
                        resultados estão disponíveis como propriedades públicas do
                        objeto.
                    </p>
                </li>
</ul></div>

            <div class="example">
<a name="zend.db.adapter.select.fetch-mode.example"></a><p class="title"><b>Exemplo 196. Usando setFetchMode()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchAll('SELECT * FROM bugs WHERE bug_id = ?', 2);

// $result é um matriz de objetos
echo $result[0]-&gt;bug_description;
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchassoc"></a>Buscando um Conjunto de Resultados como um matriz Associativo</h4></div></div></div>
            

            <p>
                O método <code class="methodname">fetchAssoc()</code> retorna dados em uma matriz
                de matrizes associativas, independente de qual valor você tenha configurado
                para o modo de busca, utilizando a primeira coluna como índice da matriz.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchassoc.example"></a><p class="title"><b>Exemplo 197. Usando fetchAssoc()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchAssoc(
    'SELECT bug_id, bug_description, bug_status FROM bugs'
);

// $result é uma matriz de matrizes associativas, conforme o modo de busca
echo $result[2]['bug_description']; // Descrição do Bug #2
echo $result[1]['bug_description']; // Descrição do Bug #1
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchcol"></a>Buscando uma Única Coluna a partir de um Conjunto de Resultados</h4></div></div></div>
            

            <p>
                O método <code class="methodname">fetchCol()</code> retorna dados em um matriz
                de valores, independente do valor que você tenha configurado para o modo de busca
                Ele devolve somente a primeira coluna devolvida pela consulta.
                Quaisquer outras colunas devolvidas pela consulta são descartadas.
                Se você precisar devolver uma outra coluna que não seja a primeira, veja
                <a class="link" href="zend.db.statement.html#zend.db.statement.fetching.fetchcolumn" title="Fetching a Single Column from a Result Set">esta seção</a>.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchcol.example"></a><p class="title"><b>Exemplo 198. Usando fetchCol()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchCol(
    'SELECT bug_description, bug_id FROM bugs WHERE bug_id = ?', 2);

// contém bug_description; bug_id não é devolvida
echo $result[0];
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchpairs"></a>Buscando Pares Chave-Valor a partir de um Conjunto de Resultados</h4></div></div></div>
            

            <p>
                O método <code class="methodname">fetchPairs()</code> retorna dados em um matriz
                de pares chave-valor, como um matriz associativo com uma entrada única
                por linha. A chave desse matriz associativo é tomada da
                primeira coluna devolvida pela consulta <acronym class="acronym">SELECT</acronym>. O valor é tomado
                da segunda coluna devolvida pela consulta <acronym class="acronym">SELECT</acronym>. Quaisquer
                outras colunas devolvidas pela consulta são descartadas.
            </p>

            <p>
                Você deve projetar a conuslta <acronym class="acronym">SELECT</acronym> de modo que a primeira
                coluna devolvida tenha valores únicos. Se há valores duplicados na
                primeira coluna, entradas na matriz associativo serão
                sobrescritas.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchpairs.example"></a><p class="title"><b>Exemplo 199. Usando fetchPairs()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchPairs('SELECT bug_id, bug_status FROM bugs');

echo $result[2];
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchrow"></a>Buscando uma Linha Única a partir de um Conjunto de Resultados</h4></div></div></div>
            

            <p>
                O método <code class="methodname">fetchRow()</code> retorna dados usando o
                modo de busca atual, mas retorna somente a primeira linha
                buscada a partir do conjunto de resultados.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchrow.example"></a><p class="title"><b>Exemplo 200. Using fetchRow()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchRow('SELECT * FROM bugs WHERE bug_id = 2');

// note que $result é um único objeto, não um matriz de objetos
echo $result-&gt;bug_description;
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchone"></a>Buscando um Escalar Único a partir de um Conjunto de Resultados</h4></div></div></div>
            

            <p>
                O método <code class="methodname">fetchOne()</code> é como uma combinação
                do método <code class="methodname">fetchRow()</code> com o método
                <code class="methodname">fetchCol()</code>, no que ele retorna dados somente
                para a primeira linha buscada a partir do conjunto de resultados, e retorna
                somente o valor da primeira coluna naquela linha. Portanto ele retorna somente
                um único valor escalar, nem um matriz nem um objeto.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchone.example"></a><p class="title"><b>Exemplo 201. Usando fetchOne()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$result = $db-&gt;fetchOne('SELECT bug_status FROM bugs WHERE bug_id = 2');

// este é um valor string único
echo $result;
</pre>
            </div>
</div>
<br class="example-break">
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.write"></a>Gravando Mudanças no Banco de Dados</h3></div></div></div>
        

        <p>
            Você pode usar a classe adaptadora para gravar novos dados ou alterar
            dados existentes em seu banco de dados. Esta seção descreve métodos para fazer essas
            operações.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.write.insert"></a>Incluindo Dados</h4></div></div></div>
            

            <p>
                Você pode adicionar novas linhas em uma tabela de seu banco de dados usando
                o método <code class="methodname">insert()</code>. O primeiro argumento é uma string
                que denomina a tabela, e o segundo argumento é um matriz
                associativo, mapeando nomes de coluna para valores de dados.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.insert.example"></a><p class="title"><b>Exemplo 202. Incluindo em uma Tabela</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$data = array(
    'created_on'      =&gt; '2007-03-22',
    'bug_description' =&gt; 'Something wrong',
    'bug_status'      =&gt; 'NEW'
);

$db-&gt;insert('bugs', $data);
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Colunas que você excluir da matriz de dados não serão especificadas para
                o banco de dados. Portanto, elas seguem as mesmas regras que uma
                declaração <acronym class="acronym">SQL</acronym> <acronym class="acronym">INSERT</acronym> segue: se a coluna
                tem uma cláusula <acronym class="acronym">DEFAULT</acronym>, a coluna leva o valor na linha
                criada, caso contrário é deixado em um estado <code class="constant">NULL</code>.
            </p>

            <p>
                Por padrão, os valores em seu matriz de dados são incluídos usando
                parâmetros. ISso reduz o risco de alguns tipos de problemas de
                segurança. Você não precisa aplicar escaping ou quoting para valores
                na matriz de dados.
            </p>

            <p>
                Você pode precisar que valores na matriz de dados sejam tratados como expressões
                <acronym class="acronym">SQL</acronym>, caso no qual elas não devam sofrer quoting. Por
                padrão, todos os valores de dados passados como strings são tratados como
                literais string. Para especificar que o valor é uma expressão
                <acronym class="acronym">SQL</acronym> e portanto não deve sofrer quoting, passe o valor
                na matriz de dados como um objeto do tipo <code class="classname">Zend_Db_Expr</code>
                em vez de texto claro.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.insert.example2"></a><p class="title"><b>Exemplo 203. Incluindo Expressões em uma Tabela</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$data = array(
    'created_on'      =&gt; new Zend_Db_Expr('CURDATE()'),
    'bug_description' =&gt; 'Something wrong',
    'bug_status'      =&gt; 'NEW'
);

$db-&gt;insert('bugs', $data);
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.write.lastinsertid"></a>Recuperando um Valor Gerado</h4></div></div></div>
            

            <p>
                Algumas marcas de <acronym class="acronym">SGBDR</acronym> suportam autoincremento de chaves
                primárias. Uma tabela definida desse modo gera um valor de chave primária
                automaticamente durante um <acronym class="acronym">INSERT</acronym> de uma nova linha. O valor de
                retorno do método <code class="methodname">insert()</code> <span class="emphasis"><em>não</em></span> é
                o último ID incluído, porque a tabela pode não ter uma
                coluna de autoincremento. Em vez disso, o valor de retorno é o
                número de linhas afetadas (geralmente 1).
            </p>

            <p>
                Se sua tabela é definida com uma chave primária de autoincremento
                você pode chamar o método <code class="methodname">lastInsertId()</code> depois da
                inclusão. Esse método retonra o último valor gerado no
                escopo da conexão atual com o banco de dados.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.lastinsertid.example-1"></a><p class="title"><b>Exemplo 204. Usando lastInsertId() para uma Chave de Autoincremento</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;insert('bugs', $data);

// retorna o último valor gerado por uma coluna de autoincremento
$id = $db-&gt;lastInsertId();
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Algumas marcas de <acronym class="acronym">SGBDR</acronym> suportam um objeto de sequencia, que
                gera valores únicos para servir como valores da chave primária. Para suportar
                sequencias, o método <code class="methodname">lastInsertId()</code> aceita dois
                argumentos string opcionais. Esses argumentos denominam a tabela e
                a coluna, assumindo que você tenha seguido a convenção de que uma
                sequencias é denominada usando os nomes de tabela e coluna para os quais
                a sequencia gera valores, e um sufixo "_seq". Isso é
                baseado na convenção usada pelo PostgreSQL quando nomeia
                sequencias para colunas <code class="constant">SERIAL</code>. Por exemplo, uma tabela "bugs"
                com a coluna de chave primária "bug_id" usaria uma sequencia denominada
                "bugs_bug_id_seq".
            </p>

            <div class="example">
<a name="zend.db.adapter.write.lastinsertid.example-2"></a><p class="title"><b>Exemplo 205. Usando lastInsertId() para uma Sequencia</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;insert('bugs', $data);

// retorna o último valor gerado pela sequencia 'bugs_bug_id_seq'.
$id = $db-&gt;lastInsertId('bugs', 'bug_id');

// alternativamente, retorna o último valor gerado pela sequencia 'bugs_seq'.
$id = $db-&gt;lastInsertId('bugs');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Se o nome de seu objeto de sequencia não seguir essa convenção
                de nomes, use o método <code class="methodname">lastSequenceId()</code>
                em seu lugar. Esse método leva um único argumento string, nomeando
                literalmente a sequencia.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.lastinsertid.example-3"></a><p class="title"><b>Exemplo 206. Usando lastSequenceId()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;insert('bugs', $data);

// retorna o último valor gerado pela sequencia 'bugs_id_gen'.
$id = $db-&gt;lastSequenceId('bugs_id_gen');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Para as marcas de <acronym class="acronym">SGBDR</acronym> que não suportam sequencias, incluindo
                MariaDB, MySQL, Microsoft <acronym class="acronym">SQL</acronym> Server, e SQLite, os argumentos
                para o método <code class="methodname">lastInsertId()</code> são ignorados, e o valor
                devolvido é o valor mais recente gerado para qualquer tabela por operações
                <acronym class="acronym">INSERT</acronym> durante a conexão atual. Para essas marcas de
                <acronym class="acronym">SGBDR</acronym>, o método <code class="methodname">lastSequenceId()</code> sempre
                devolve <code class="constant">NULL</code>.
            </p>

            <div class="note"><table border="0" summary='Note: Porque Não Usar "SELECT MAX(id) FROM table"?'>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Porque Não Usar "SELECT MAX(id) FROM table"?</th>
</tr>
<tr><td align="left" valign="top">
                

                <p>
                    Algumas essa consulta retorna valor de chave primária mais recente
                    incluído em uma tabela. Entretanto, essa técnica
                    não é segura para ser usada em um ambiente onde múltiplos clientes estão
                    incluindo registros no banco de dados. É possível, e
                    portanto pode acontecer eventualmente, que outro
                    cliente inclua outra linha no instante entre a
                    inclusão executada por sua aplicação cliente e sua consulta
                    para o valor de <code class="methodname">MAX(id)</code>. Assim o valor devolvido
                    não identifica a linha que você incluiu, mas sim a linha
                    incluída por algum outro cliente. Não há um modo de saber
                    quando isso aconteceu.
                </p>

                <p>
                    Usar um modo de isolamento de transação forte tal como
                    "repeatable read" pode mitigar esse risco, mas algumas marcas de
                    <acronym class="acronym">SGBDR</acronym> não suportam o isolamento de transação necessário para
                    isso, ou sua aplicação pode usar um modo de isolamento
                    de transação baixo por projeto.
                </p>

                <p>
                    Além disso, usar uma expressão como "<span class="command"><strong>MAX(id)+1</strong></span>" para gerar
                    um novo valor para uma chave primária não é seguro, porque dois clientes
                    poderiam fazer esta consulta simultanamente, e em seguida, ambos usariam
                    o mesmo valor calculado para sua próxima operação <acronym class="acronym">INSERT</acronym>.
                </p>

                <p>
                     Todas as marcas de <acronym class="acronym">SGBDR</acronym> fornecem mecanismos para gerar
                    valores únicos e retornar o último valor gerado. Esses
                    mecanismos necessariamente trabalham fora do escopo de
                    isolamento da transação, portanto, não há chance de dois clientes
                    gerarem o mesmo valor, e não há chance de que o
                    valor gerado por um outro cliente possa ser informado à sua
                    conexão de cliente como o último valor gerado.
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.write.update"></a>Updating Data</h4></div></div></div>
            

            <p>
                Você pode atualizar linhas em uma tabela de banco de dados usando o
                método <code class="methodname">update()</code> de uma adaptadora. Esse método leva
                três argumentos: o primeiro é o nome da tabela, o
                segundo é um matriz associativo mapeando as colunas a serem alteradas para os novos
                valores a serem atribuídos a essas colunas.
            </p>

            <p>
                Os valores na matriz de dados são tratados como sequências de caracteres.
                Veja <a class="link" href="zend.db.adapter.html#zend.db.adapter.write.insert" title="Incluindo Dados">esta seção</a>
                para obter informações sobre como utilizar expressões <acronym class="acronym">SQL</acronym> na
                matriz de dados.
            </p>

            <p>
                O terceiro argumento é uma string contendo uma expressão <acronym class="acronym">SQL</acronym>
                que é usada como critério para as linhas a serem alteradas. Os valores
                e identificadores nesse argumento não são citados ou escapados.
                Você é responsável por garantir que o conteúdo dinâmico seja
                interpolados para essa sequência de forma segura.
                Veja <a class="link" href="zend.db.adapter.html#zend.db.adapter.quoting" title="Citando Valores e Identificadores">esta seção</a>
                para métodos que o ajudam a fazer isso.
            </p>

            <p>
                O valor de retorno é o número de linhas afetadas pela operação
                de atualização.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.update.example"></a><p class="title"><b>Exemplo 207. Atualizando Linhas</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$data = array(
    'updated_on'      =&gt; '2007-03-23',
    'bug_status'      =&gt; 'FIXED'
);

$n = $db-&gt;update('bugs', $data, 'bug_id = 2');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Se você omitir o terceiro argumento, então todas as linhas na tabela
                do banco de dados são atualizadas com os valores especificados no matriz de dados.
            </p>

            <p>
                Se você fornecer um matriz de strings como terceiro argumento, essas
                strings são unidas como termos em uma expressão separada
                por operadores <code class="constant">AND</code>.
            </p>

            <p>
                Se você fornecer um matriz de matrizs como terceiro argumento, os
                valores serão automaticamente citados dentro das chaves. Esses
                serão então unidos como termos, separados por
                operadores <code class="constant">AND</code>.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.update.example-array"></a><p class="title"><b>Exemplo 208. Atualizando Linhas Usando um matriz de Expressões</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$data = array(
    'updated_on'      =&gt; '2007-03-23',
    'bug_status'      =&gt; 'FIXED'
);

$where[] = "reported_by = 'goofy'";
$where[] = "bug_status = 'OPEN'";

$n = $db-&gt;update('bugs', $data, $where);

// A SQL resultante é:
//  UPDATE "bugs" SET "update_on" = '2007-03-23', "bug_status" = 'FIXED'
//  WHERE ("reported_by" = 'goofy') AND ("bug_status" = 'OPEN')
</pre>
            </div>
</div>
<br class="example-break">

            <div class="example">
<a name="zend.db.adapter.write.update.example-arrayofarrays"></a><p class="title"><b>Exemplo 209. Atualizando Linhas Usando um matriz de matrizs</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$data = array(
    'updated_on'      =&gt; '2007-03-23',
    'bug_status'      =&gt; 'FIXED'
);

$where['reported_by = ?'] = 'goofy';
$where['bug_status = ?']  = 'OPEN';

$n = $db-&gt;update('bugs', $data, $where);

// A SQL resultante é:
//  UPDATE "bugs" SET "update_on" = '2007-03-23', "bug_status" = 'FIXED'
//  WHERE ("reported_by" = 'goofy') AND ("bug_status" = 'OPEN')
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.write.delete"></a>Excluindo Dados</h4></div></div></div>
            

            <p>
                Você pode excluir linhas de uma tabela de banco de dados usando o
                método <code class="methodname">delete()</code>methodName&gt;. Esse método leva dois
                argumentos: O primeiro é uma string com o nome da tabela.

            </p>

            <p>
                O segundo argumento é uma string contendo uma expressão <acronym class="acronym">SQL</acronym>
                que é usada como critério para as linhas a eliminar. Os valores
                e identificadores nesse argumento não são citados ou escapado.
                Você é responsável por garantir que o conteúdo dinâmico seja
                interpolado para esta seqüência de forma segura.
                Veja <a class="link" href="zend.db.adapter.html#zend.db.adapter.quoting" title="Citando Valores e Identificadores">esta seção</a>
                para métodos que o ajudam a fazer isso.
            </p>

            <p>
                O valor de retorno é o número de linhas afetadas pela operação
                de exclusão.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.delete.example"></a><p class="title"><b>Exemplo 210. Excluindo Linhas</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$n = $db-&gt;delete('bugs', 'bug_id = 3');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Se você omitir o segundo argumento, o resultado é que todas as linhas na
                tabela do banco de dados são eliminadas.
            </p>

            <p>
                Se você fornecer um matriz de strings como o segundo argumento, essas
                strings são unidas como termos em uma expressão separada
                por operadores <code class="constant">AND</code>.
            </p>

            <p>
                Se você fornecer um matriz de matrizs como segundo argumento, os
                valores serão automaticamente citados dentro das chaves. Esses
                serão então unidos como termos, separados por
                operadores <code class="constant">AND</code>.
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.quoting"></a>Citando Valores e Identificadores</h3></div></div></div>
        

        <p>
            Quando você monta consultas <acronym class="acronym">SQL</acronym>, muitas vezes é o caso de você
            precisar incluir os valores de variáveis<acronym class="acronym">PHP</acronym> em expressões
            <acronym class="acronym">SQL</acronym>. Isso é arriscado, porque se o valor em uma string
            <acronym class="acronym">PHP</acronym> contém certos símbolos, como o símbolo de citação, isso pode
            resultar em <acronym class="acronym">SQL</acronym> inválido. Por exemplo, observe os apóstrofos não
            balanceados na seguinte consulta:
        </p>

        <pre class="programlisting">
$name = "O'Reilly";
$sql = "SELECT * FROM bugs WHERE reported_by = '$name'";

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O'Reilly'
</pre>

        <p>
            Ainda pior é o risco de tais erros de código possam ser explorados
            deliberadamente por uma pessoa que está tentando manipular a função
            de sua aplicação web. Se eles podem especificar o valor de uma variável
            <acronym class="acronym">PHP</acronym> através do uso de um parâmetro <acronym class="acronym">HTTP</acronym> ou
            outro mecanismo, eles podem ser capazes de fazer suas consultas <acronym class="acronym">SQL</acronym>
            fazerem coisas que você não pretendia que elas fizessem, tais retornar dados para a
            pessoa que não deveria ter o privilégio de lê-los. Essa é uma técnica grave e
            generalizada para violar a segurança do aplicativo, conhecido como "SQL Injection"
            (veja <a class="ulink" href="http://en.wikipedia.org/wiki/SQL_Injection" target="_top">
            http://en.wikipedia.org/wiki/SQL_Injection
            </a>).
        </p>

        <p>
            A classe adaptadora <code class="classname">Zend_Db</code> fornece funções convenientes para
            ajudar a reduzir as vulnerabilidades para ataques de Injeção de <acronym class="acronym">SQL</acronym>
            em seu código <acronym class="acronym">PHP</acronym>. A solução é escapar caracteres especiais tais
            como apóstrofos em valores <acronym class="acronym">PHP</acronym> antes deles serem interpolados em
            suas strings <acronym class="acronym">SQL</acronym>. Isso protege tanto contra manipulação acidental
            quanto deliberada de strings <acronym class="acronym">SQL</acronym> por variáveis
            <acronym class="acronym">PHP</acronym> que contém caracteres especiais.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.quoting.quote"></a>Usando quote()</h4></div></div></div>
            

            <p>
                O método <code class="methodname">quote()</code> aceita um único argumento, um
                valor string escalar. Ele retorna o valor com
                caracteres especiais de uma forma adequada para o <acronym class="acronym">SGBDR</acronym> que você
                está usando, e rodeado por delimitadores de valor de string. O
                delimitador de valor de string padrão <acronym class="acronym">SQL</acronym> é o apóstrofo
                ( ').
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote.example"></a><p class="title"><b>Exemplo 211. Usando quote()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$name = $db-&gt;quote("O'Reilly");
echo $name;
// 'O\'Reilly'

$sql = "SELECT * FROM bugs WHERE reported_by = $name";

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O\'Reilly'
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Note que o valor de retorno de <code class="methodname">quote()</code> inclui os
                delimitadores de citação em torno da cadeia. Isso é diferente de
                algumas funções que escapam caracteres especiais, mas não adicionam
                os delimitadores de citação, por exemplo
                <a class="ulink" href="http://www.php.net/mysqli_real_escape_string" target="_top">
                mysql_real_escape_string()
                </a>.
            </p>

            <p>
                Os valores podem precisar ser citados ou não citados de acordo com o
                contexto de tipo de dados <acronym class="acronym">SQL</acronym> em que eles são usados. Por
                exemplo, em algumas marcas de <acronym class="acronym">SGBDR</acronym>, um valor inteiro não deve
                ser citado como uma string se for comparado a uma coluna ou expressão do tipo
                inteiro. Em outras palavras, o código seguinte é um erro em algumas implementações
                <acronym class="acronym">SQL</acronym>, assumindo que <span class="property">intColumn</span> tem um tipo de
                dados <acronym class="acronym">SQL</acronym> <code class="constant">INTEGER</code>
            </p>

            <pre class="programlisting">
SELECT * FROM atable WHERE intColumn = '123'
</pre>

            <p>
                Você pode usar o segundo argumento opcional para o
                método <code class="methodname">quote()</code> para aplicar citação seletivamente para
                o tipo de dados <acronym class="acronym">SQL</acronym> que você especificar.
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote.example-2"></a><p class="title"><b>Exemplo 212. Usando quote() com um Tipo SQL</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$value = '1234';
$sql = 'SELECT * FROM atable WHERE intColumn = '
     . $db-&gt;quote($value, 'INTEGER');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Cada classe <code class="classname">Zend_Db_Adapter</code> tem codificada os nomes de
                tipos de dados <acronym class="acronym">SQL</acronym> numéricos para a respectiva marca de
                <acronym class="acronym">SGBDR</acronym>. Você também pode usar as constantes
                <code class="constant">Zend_Db::INT_TYPE</code>, <code class="constant">Zend_Db::BIGINT_TYPE</code>,
                e <code class="constant">Zend_Db::FLOAT_TYPE</code> para escrever código de uma forma mais
                independente de <acronym class="acronym">SGBDR</acronym>.
            </p>

            <p>
                <code class="classname">Zend_Db_Table</code> especifica <acronym class="acronym">SQL</acronym> para
                <code class="methodname">quote()</code> automaticamente ao gerar
                consultas <acronym class="acronym">SQL</acronym> que referenciam colunas-chave de uma tabela.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.quoting.quote-into"></a>Usando quoteInto()</h4></div></div></div>
            

            <p>
                O uso mais típico de citação é para interpolar uma variável <acronym class="acronym">PHP</acronym>
                em uma expressão ou declaração <acronym class="acronym">SQL</acronym>. Você pode usar o
                método <code class="methodname">quoteInto()</code> para fazer isso em uma única etapa.
                Esse método leva dois argumentos: o primeiro argumento é uma string
                contendo um símbolo marcador (?), e o
                segundo argumento é um valor ou variável <acronym class="acronym">PHP</acronym> que deve ser
                substituída pelo marcador.
            </p>

            <p>
                O símbolo marcador é o mesmo símbolo usado por muitas marcas de
                <acronym class="acronym">SGBDR</acronym> para parâmetros posicionais, mas o
                método <code class="methodname">quoteInto()</code> apenas emula parâmetros de consulta.
                O método simplesmente interpola o valor para a string,
                escapa caracteres especiais, e aplica apóstrofos em torno dele.
                Parâmetros de consulta verdadeiros mantêm a separação entre a string
                <acronym class="acronym">SQL</acronym> e os parâmetros assim que a declaração é analisada no
                servidor <acronym class="acronym">SGBDR</acronym>.
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote-into.example"></a><p class="title"><b>Exemplo 213. Usando quoteInto()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$sql = $db-&gt;quoteInto("SELECT * FROM bugs WHERE reported_by = ?", "O'Reilly");

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O\'Reilly'
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Você pode usar o terceiro parâmetro opcional de
                <code class="methodname">quoteInto()</code> para especificar o tipo de dados
                <acronym class="acronym">SQL</acronym>.
                Tipos de dados numéricos não são citados, e outros tipos são citados.
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote-into.example-2"></a><p class="title"><b>Exemplo 214. Using quoteInto() with a SQL Type</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$sql = $db
    -&gt;quoteInto("SELECT * FROM bugs WHERE bug_id = ?", '1234', 'INTEGER');

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 1234
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.quoting.quote-identifier"></a>Usando quoteIdentifier()</h4></div></div></div>
            

            <p>
                Os valores não são a única parte da sintaxe <acronym class="acronym">SQL</acronym> que pode
                precisar ser variável. Se você usar variáveis <acronym class="acronym">PHP</acronym> para nomear
                tabelas, colunas, ou outros identificadores em suas declarações
                <acronym class="acronym">SQL</acronym>, pode ser necessário citar essas strings também. Por padrão,
                identificadores <acronym class="acronym">SQL</acronym> têm regras de sintaxe como
                <acronym class="acronym">PHP</acronym> e a maioria das outras linguagens de programação.
                Por exemplo, os identificadores não devem conter espaços, certas
                pontuações ou caracteres especiais, ou ainda caracteres internacionais.
                Certas palavras também são reservadas para a sintaxe <acronym class="acronym">SQL</acronym>,
                e não devem ser usadas como identificadores.
            </p>

            <p>
                No entanto, <acronym class="acronym">SQL</acronym> tem um recurso chamado
                <span class="emphasis"><em>identificadores delimitados</em></span>, que permite escolhas mais amplas
                para a grafia de identificadores. Se você colocar um identificador
                <acronym class="acronym">SQL</acronym> no tipo adequado de aspas, pode usar identificadores
                com dados que seriam inválidos sem as aspas. Identificadores delimitados podem
                conter espaços, pontuação, ou caracteres internacionais. Você também pode usar
                palavras reservadas da <acronym class="acronym">SQL</acronym> se colocá-las em identificadores
                delimitados.
            </p>

            <p>
                O método <code class="methodname">quoteIdentifier()</code> trabalha como
                <code class="methodname">quote()</code>, mas ele aplica caracteres delimitadores
                de identificador para a string de acordo com o tipo de adaptador que você
                usar. Por exemplo, a <acronym class="acronym">SQL</acronym> padrão usa aspas duplas (")
                para delimitadores de identificador, e a maioria das marcas de
                <acronym class="acronym">SGBDR</acronym> marcas usam esse símbolo. O MySQL usa crase (`) por
                padrão. O método <code class="methodname">quoteIdentifier()</code> também escapa
                caracteres especiais dentro do argumento string.
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote-identifier.example"></a><p class="title"><b>Exemplo 215. Usando quoteIdentifier()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// podemos deter um nome de tabela que é uma palavra reservada SQL
$tableName = $db-&gt;quoteIdentifier("order");

$sql = "SELECT * FROM $tableName";

echo $sql
// SELECT * FROM "order"
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Identificadores delimitados <acronym class="acronym">SQL</acronym> são sensíveis à caixa, ao
                contrário de identificadores não citados. Portanto, se você usar identificadores
                delimitados, você deve usar a ortografia do identificador exatamente como ela é
                armazenada no seu esquema, incluindo a caixa das letras.
            </p>

            <p>
                Na maioria dos casos onde <acronym class="acronym">SQL</acronym> é gerada dentro
                de classes <code class="classname">Zend_Db</code>, o padrão é que todos os identificadores
                sejam delimitados automaticamente. Você pode alterar esse comportamento com a opção
                <code class="constant">Zend_Db::AUTO_QUOTE_IDENTIFIERS </code>. Especifique essa opção
                ao instanciar o adaptador.
                Veja <a class="link" href="zend.db.adapter.html#zend.db.adapter.connecting.parameters.example2" title="Exemplo 191. Passando a Opção Auto-Quoting para a Fábrica">este
                    exemplo</a>.
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.transactions"></a>Controlando Transações de Banco de Dados</h3></div></div></div>
        

        <p>
            Bases de dados definem as operações como unidades lógicas de trabalho que podem ser
            confirmadas ou revertidas como uma única mudança, mesmo que operem em várias tabelas.
            Todas as consultas ao banco de dados são executadas no contexto de uma transação, mesmo
            se o driver de banco de dados as gerencia implicitamente. Isso é chamado modo
            <span class="emphasis"><em>auto-commit</em></span>, no qual o driver de banco cria uma transação para cada
            declaração que você executa, e confirma essa transação após sua declaração
            <acronym class="acronym">SQL</acronym> ser executada. Por padrão, todas as classes adaptadoras
            <code class="classname">Zend_Db</code> operam em modo auto-commit.
        </p>

        <p>
            De forma alternativa, você pode especificar o início e resolução de uma
            transação, e assim controlar quantas consultas <acronym class="acronym">SQL</acronym> estão incluídas
            em um único grupo que é confirmado (ou revertido) como uma única
            transação. Use o método <code class="methodname">beginTransaction()</code> para
            iniciar uma transação. Posteriormente declarações <acronym class="acronym">SQL</acronym> são executadas
            no contexto da mesma transação, até que você o resolva explicitamente.
        </p>

        <p>
            Para resolver a transação, use o método <code class="methodname">commit()</code> ou
            <code class="methodname">rollBack()</code>. O método <code class="methodname">commit()</code>
            altera marcas feitas durante a sua transação como confirmadas, o que
            significa que os efeitos dessas mudanças são mostrados em consultas executadas em
            outras transações.
        </p>

        <p>
            O método <code class="methodname">rollBack()</code> faz o oposto: ele descarta
            as alterações feitas durante a transação. As mudanças são
            efetivamente desfeitas, e o estado dos dados retorna a como estava
            antes de você começar sua transação. No entanto, a reversão de sua
            transação não tem efeito sobre as mudanças feitas por outras transações
            executadas simultaneamente.
        </p>

        <p>
            Depois de resolver essa operação, <code class="classname">Zend_Db_Adapter</code>
            retorna ao modo auto-commit, até que você chame
            <code class="methodname">beginTransaction()</code> novamente.
        </p>

        <div class="example">
<a name="zend.db.adapter.transactions.example"></a><p class="title"><b>Exemplo 216. Gerenciando uma Transação para Garantir Consistência</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
// Inicie uma transação explicitamente.
$db-&gt;beginTransaction();

try {
    // Tenta executar uma ou mais consultas:
    $db-&gt;query(...);
    $db-&gt;query(...);
    $db-&gt;query(...);

    // Se todas tem sucesso, confirma a transação e todas as mudanças
    // são confirmadas de uma vez.
    $db-&gt;commit();

} catch (Exception $e) {
    // Se qualquer uma das consultas falhar e lançar uma exceção
    // nós queremos desfazer a transação inteira, revertendo
    // mudanças feitas na transação, mesmo aquelas que tiveram sucesso
    // Assim todas as mudanças são confirmadas juntas, ou nenhuma é.
    $db-&gt;rollBack();
    echo $e-&gt;getMessage();
}
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.list-describe"></a>Listando e Descrevendo Tabelas</h3></div></div></div>
        

        <p>
            O método <code class="methodname">listTables()</code> retorna uma matriz de strings,
            com os nomes de todas as tabelas do banco de dados atual.
        </p>

        <p>
            O método <code class="methodname">describeTable()</code> retorna uma matriz associativa
            de metadados sobre uma tabela. Especifique o nome da tabela
            como uma string no primeiro argumento para este método. O segundo
            argumento é opcional, e identifica o esquema no qual a tabela
            existe.
        </p>

        <p>
            As chaves da matriz associativa retornada são os nomes das colunas
            da tabela. O valor correspondente a cada coluna é também uma
            matriz associativa, com as seguintes chaves e valores:
        </p>

        <div class="table">
<a name="zend.db.adapter.list-describe.metadata"></a><p class="title"><b>Tabela 63. Campos de Metadados Devolvidos por describeTable()</b></p>
<div class="table-contents">
            

            <table class="table" summary="Campos de Metadados Devolvidos por describeTable()" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Key</th>
<th align="left">Type</th>
<th align="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td align="left"><code class="constant">SCHEMA_NAME</code></td>
<td align="left">(string)</td>
<td align="left">
                        Nome do esquema do banco de dados no qual essa tabela existe.
                        </td>
</tr>
<tr>
<td align="left"><code class="constant">TABLE_NAME</code></td>
<td align="left">(string)</td>
<td align="left">Nome da tabela a qual esta coluna pertence.</td>
</tr>
<tr>
<td align="left"><code class="constant">COLUMN_NAME</code></td>
<td align="left">(string)</td>
<td align="left">Nome da coluna.</td>
</tr>
<tr>
<td align="left"><code class="constant">COLUMN_POSITION</code></td>
<td align="left">(integer)</td>
<td align="left">Posição ordinal da coluna na tabela.</td>
</tr>
<tr>
<td align="left"><code class="constant">DATA_TYPE</code></td>
<td align="left">(string)</td>
<td align="left">Nome do tipo de dados do <acronym class="acronym">SGBDR</acronym> da coluna.</td>
</tr>
<tr>
<td align="left"><code class="constant">DEFAULT</code></td>
<td align="left">(string)</td>
<td align="left">Valor padrão para a coluna, se houver.</td>
</tr>
<tr>
<td align="left"><code class="constant">NULLABLE</code></td>
<td align="left">(boolean)</td>
<td align="left">
                            <code class="constant">TRUE</code> se a coluna aceita <acronym class="acronym">SQL</acronym>
                            <code class="constant">NULL</code>'s, <code class="constant">FALSE</code> se a
                            coluna tem uma restrição <code class="constant">NOT</code>
                            <code class="constant">NULL</code>.
                        </td>
</tr>
<tr>
<td align="left"><code class="constant">LENGTH</code></td>
<td align="left">(integer)</td>
<td align="left">
                            Comprimento ou tamanho da coluna como informado pelo
                            <acronym class="acronym">SGBDR</acronym>.
                        </td>
</tr>
<tr>
<td align="left"><code class="constant">SCALE</code></td>
<td align="left">(integer)</td>
<td align="left">
                            Escala de tipo <acronym class="acronym">SQL</acronym> <code class="constant">NUMERIC</code> ou
                            <code class="constant">DECIMAL</code>.
                        </td>
</tr>
<tr>
<td align="left"><code class="constant">PRECISION</code></td>
<td align="left">(integer)</td>
<td align="left">
                            Precisão de tipo <acronym class="acronym">SQL</acronym> <code class="constant">NUMERIC</code> ou
                            <code class="constant">DECIMAL</code>.
                        </td>
</tr>
<tr>
<td align="left"><code class="constant">UNSIGNED</code></td>
<td align="left">(boolean)</td>
<td align="left">
                            <code class="constant">TRUE</code> se um tipo baseado em inteiro for informado
                            como <code class="constant">UNSIGNED</code>.
                        </td>
</tr>
<tr>
<td align="left"><code class="constant">PRIMARY</code></td>
<td align="left">(boolean)</td>
<td align="left">
                            <code class="constant">TRUE</code> se a coluna é parte da chave primária dessa
                            tabela.
                        </td>
</tr>
<tr>
<td align="left"><code class="constant">PRIMARY_POSITION</code></td>
<td align="left">(integer)</td>
<td align="left">Posição ordinal (baseada em 1) da coluna na chave primária.</td>
</tr>
<tr>
<td align="left"><code class="constant">IDENTITY</code></td>
<td align="left">(boolean)</td>
<td align="left">
                            <code class="constant">TRUE</code> se a coluna usa um valor autogerado.
                        </td>
</tr>
</tbody>
</table>
        </div>
</div>
<br class="table-break">

        <div class="note"><table border="0" summary="Note: Como o Campo de Metadados IDENTITY Relaciona-se com SGBDRs Específicos">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Como o Campo de Metadados IDENTITY Relaciona-se com SGBDRs Específicos</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                O campo de metadados <code class="constant">IDENTITY</code> foi escolhido como um termo
                'idiomático' para representar uma relação de chaves substitutas. Este campo pode ser
                vulgarmente conhecido pelos seguintes valores: --
            </p>

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        <code class="constant">IDENTITY</code> - <acronym class="acronym">DB2</acronym>,
                        <acronym class="acronym">MSSQL</acronym>
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <code class="constant">AUTO_INCREMENT</code> - MySQL/MariaDB
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <code class="constant">SERIAL</code> - PostgreSQL
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <code class="constant">SEQUENCE</code> - Oracle
                    </p>
                </li>
</ul></div>
        </td></tr>
</table></div>

        <p>
            Se não houver nenhum tabela que se encaixe com o nome da tabela e nome de esquema
            opcional especificado, então <code class="methodname">describeTable()</code> retorna uma
            matriz vazia.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.closing"></a>Fechando uma Conexão</h3></div></div></div>
        

        <p>
            Normalmente não é necessário fechar uma conexão de dados. <acronym class="acronym">PHP</acronym>
            limpa automaticamente todos os recursos ao final de uma requisição.
            Extensões de Banco de Dados são projetadas para fechar a conexão assim que a
            referência para o objeto do recurso é eliminada.
        </p>

        <p>
            No entanto, se você tem um script de longa duração <acronym class="acronym">PHP</acronym> que inicia
            muitas conexões de banco de dados, talvez seja necessário encerrar a conexão, para
            evitar um esgotamento da capacidade de seu servidor <acronym class="acronym">SGBDR</acronym>. Você pode
            usar o método <code class="methodname">closeConnection()</code> da classe adaptadora fechar
            explicitamente a conexão de dados subjacente.
        </p>

        <p>
            Desde a versão 1.7.2, você pode verificar se está conectado ao
            servidor <acronym class="acronym">SGBDR</acronym> com o método <code class="methodname">isConnected()</code>.
            Isso significa que um recurso de conexão foi iniciado e não foi fechado. Essa
            função não é atualmente capaz de testar, por exemplo, um fechamento do lado servidor
            da conexão. Ela é usada internamente para fechar a conexão. Isso permite que você feche
            a conexão várias vezes sem erros. Já era o caso antes de 1.7.2 para adaptadores
            <acronym class="acronym">PDO</acronym>, mas não para os outros.
        </p>

        <div class="example">
<a name="zend.db.adapter.closing.example"></a><p class="title"><b>Exemplo 217. Fechando uma Conexão com o Banco de Dados</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$db-&gt;closeConnection();
</pre>
        </div>
</div>
<br class="example-break">

        <div class="note"><table border="0" summary="Note: Zend_Db Suporta Conexões Persistentes?">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Zend_Db Suporta Conexões Persistentes?</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Sim, a persistência é suportada através da adição da
                propriedade <span class="property">persistent</span> definida como <code class="constant">TRUE</code>
                na configuração (não em driver_configuration) de um adaptador
                em <code class="classname">Zend_Db</code>.
           </p>

            <div class="example">
<a name="zend.db.adapter.connecting.persistence.example"></a><p class="title"><b>Exemplo 218. Usando a Propriedade Persistence com o Adaptador Oracle</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db = Zend_Db::factory('Oracle', array(
    'host'       =&gt; '127.0.0.1',
    'username'   =&gt; 'webuser',
    'password'   =&gt; 'xxxxxxxx',
    'dbname'     =&gt; 'test',
    'persistent' =&gt; true
));
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Por favor, note que o uso de conexões persistentes pode causar um
                excesso de conexões inativas no servidor <acronym class="acronym">SGBDR</acronym>, o que leva a
                mais problemas do que qualquer ganho de desempenho que você possa obter por
                reduzir a sobrecarga de fazer conexões.
            </p>

            <p>
                Conexões de banco de dados tem estado. Isto é, alguns objetos no
                servidor <acronym class="acronym">SGBDR</acronym> existem no escopo de sessão.
                Exemplos são bloqueios, variáveis de usuário,
                tabelas temporárias, e informações sobre as consultas mais
                recentemente executadas, tais como linhas afetadas e o último
                valor gerado de id. Se você usa conexões persistentes, a sua
                aplicação pode acessar dados inválidos ou privilegiadas que foram
                criado em uma solicitação <acronym class="acronym">PHP</acronym> anterior.
            </p>

            <p>
                Atualmente, apenas Oracle, <acronym class="acronym">DB2</acronym>, e os adaptadores
                <acronym class="acronym">PDO</acronym> (onde especificado pelo <acronym class="acronym">PHP</acronym>) suportam
                persistência em <code class="classname">Zend_Db</code>.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.other-statements"></a>Rodando Outras Declarações de Banco de Dados</h3></div></div></div>
        

        <p>
            Pode haver casos em que você precisa acessar o objeto de conexão
            diretamente, como provido pela extensão de banco de dados <acronym class="acronym">PHP</acronym>.
            Algumas dessas extensões podem oferecer recursos que não são cobertos por
            métodos de <code class="classname">Zend_Db_Adapter_Abstract</code>.
        </p>

        <p>
            Por exemplo, todas as declarações <acronym class="acronym">SQL</acronym> rodadas por
            <code class="classname">Zend_Db</code> são preparadas, então executadas. No entanto, algumas
            funções de banco de dados são incompatíveis com declarações preparadas. Instruções
            <code class="constant">DDL</code> como <code class="constant">CREATE</code> e <code class="constant">ALTER</code>
            não podem ser preparadas no MySQL. Além disso, declarações <acronym class="acronym">SQL</acronym> não se
            beneficiam do <a class="ulink" href="http://dev.mysql.com/doc/refman/5.1/en/query-cache-how.html" target="_top">MySQL Query
                Cache</a>, antes do MySQL 5.1.17.
        </p>

        <p>
            A maioria das extensões de banco de dados <acronym class="acronym">PHP</acronym> fornecem um método
            para executar declarações <acronym class="acronym">SQL</acronym> sem prepará-los. Por exemplo, em
            <acronym class="acronym">PDO</acronym>, esse método é <code class="methodname">exec()</code>. Você pode
            acessar o objeto de conexão na extensão <acronym class="acronym">PHP</acronym> diretamente usando
            <code class="methodname">getConnection()</code>.
        </p>

        <div class="example">
<a name="zend.db.adapter.other-statements.example"></a><p class="title"><b>Exemplo 219. Rodando uma Declaração Não Preparada em um Adaptador PDO</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$result = $db-&gt;getConnection()-&gt;exec('DROP TABLE bugs');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            A maioria das extensões de banco de dados <acronym class="acronym">PHP</acronym> fornecem um método
            para executar declarações <acronym class="acronym">SQL</acronym> sem prepará-los. Por exemplo, em
            <acronym class="acronym">PDO</acronym>, esse método é <code class="methodname">exec()</code>. Você pode
            acessar o objeto de conexão na extensão <acronym class="acronym">PHP</acronym> diretamente usando
            <code class="methodname">getConnection()</code>.
        </p>

        <p>
            Em versões futuras de <code class="classname">Zend_Db</code>, haverá oportunidades de
            adicionar pontos de entrada de método para funcionalidades que são comuns às
            extensões de banco de dados <acronym class="acronym">PHP</acronym> suportadas . Isso não afetará
            compatibilidade com versões anteriores.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.server-version"></a>Recuperanco a Versão do Servidor</h3></div></div></div>
        

        <p>
            Desde a versão 1.7.2, você pode recuperar a versão do servidor no estilo de sintaxe
            <acronym class="acronym">PHP</acronym> para ser capaz de usar
            <code class="methodname">version_compare()</code>. Se a informação não estiver disponível,
            você receberá <code class="constant">NULL</code>.
        </p>

        <div class="example">
<a name="zend.db.adapter.server-version.example"></a><p class="title"><b>Exemplo 220. Verificando a versão do servidor antes de rodar uma consulta</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$version = $db-&gt;getServerVersion();
if (!is_null($version)) {
    if (version_compare($version, '5.0.0', '&gt;=')) {
        // faz alguma coisa
    } else {
        // faz alguma outra coisa
    }
} else {
    // impossível ler a versão do servidor
}
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.adapter-notes"></a>Notas sobre Adaptadores Específicos</h3></div></div></div>
        

        <p>
            Esta seção lista diferenças entre as classes adaptadoras sobre as quais
            você deve ficar atento.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.ibm-db2"></a>IBM DB2</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique esse adaptador para o método <code class="methodname">factory()</code>
                        com o nome 'Db2'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Este adaptador usa a extensão <acronym class="acronym">PHP</acronym>
                        <code class="constant">IBM_DB2</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <acronym class="acronym">IBM</acronym> <acronym class="acronym">DB2</acronym> suporta tanto seqüências
                        quanto chaves de autoincremento. Portanto os argumentos para
                        <code class="methodname">lastInsertId()</code> são opcionais. Se você não fornecer
                        argumentos, o adaptador retorna o último valor gerado para uma chave de
                        autoincremento. Se você fornecer argumentos, o adaptador retorna o último
                        valor gerado pela seqüência nomeada de acordo com a convenção
                        '<span class="emphasis"><em>table</em></span>_<span class="emphasis"><em>column</em></span>_seq'.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.mysqli"></a>MySQLi</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique esse adaptador para o método <code class="methodname">factory()</code>
                        com o nome 'Mysqli'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Este adaptador utiliza a extensão <acronym class="acronym">PHP</acronym>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        O MySQL e o MariaDB não suportam sequências, assim
                        <code class="methodname">lastInsertId()</code> ignora seus argumentos e
                        sempre retorna o último valor gerado para uma
                        chave de autoincremento. O método <code class="methodname">lastSequenceId()</code>
                        retorna <code class="constant">NULL</code>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.oracle"></a>Oracle</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique esse adaptador para o método <code class="methodname">factory()</code>
                        com o nome de 'Oracle'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Esse adaptador usa a extensão <acronym class="acronym">PHP</acronym> oci8.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Oracle não suporta chaves de autoincremento, assim você
                        deve especificar o nome de uma sequência de
                        <code class="methodname">lastInsertId()</code> ou
                        <code class="methodname">lastSequenceId()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        A extensão da Oracle não suporta parâmetros
                        posicionais. Você deve usar parâmetros nomeados.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Atualmente, a opção <code class="constant">Zend_Db::CASE_FOLDING</code>
                        não é suportada pelo adaptador Oracle. Para utilizar essa
                        opção com a Oracle, você deve usar o adaptador <acronym class="acronym">PDO</acronym>
                        <acronym class="acronym">OCI</acronym>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Por padrão, os campos <acronym class="acronym">LOB</acronym> são devolvidos como objetos
                        <acronym class="acronym">OCI</acronym>-Lob. Você pode recuperá-los como string para todas as
                        solicitações, utilizando as opções do driver
                        '<span class="property">lob_as_string</span>' ou para uma solicitação particular,
                        usando <code class="methodname">setLobAsString(boolean)</code> no adaptador ou na
                        declaração.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.sqlsrv"></a>Microsoft SQL Server</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique esse adaptador para o método <code class="methodname">factory()</code>
                        com o nome 'Sqlsrv'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Esse adaptador usa a extensão <acronym class="acronym">PHP</acronym> sqlsrv.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Somente o Microsoft <acronym class="acronym">SQL</acronym> Server 2005 ou superior é
                        suportado.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Microsoft <acronym class="acronym">SQL</acronym> Server não suporta sequências, assim
                        <code class="methodname">lastInsertId()</code> ignora o argumento de chave
                        primária e retorna o último valor gerado para uma chave de autoincremento
                        se um nome de tabela for especificado ou o último id retornado por uma
                        consulta de inserção. O método <code class="methodname">lastSequenceId()</code>
                        retorna <code class="constant">NULL</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <code class="classname">Zend_Db_Adapter_Sqlsrv</code> configura
                        <code class="constant">QUOTED_IDENTIFIER</code> ON imediatamente após conectar-se a
                        um servidor <acronym class="acronym">SQL</acronym>. Isso faz com que o driver utilize o
                        símbolo delimitador de identificador da <acronym class="acronym">SQL</acronym> padrão
                        (<span class="emphasis"><em> "</em></span>) em vez dos colchetes que a sintaxe do
                        <acronym class="acronym">SQL</acronym> Server usa para delimitar identificadores.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Você pode especificar <span class="property">driver_options</span> como uma chave na
                        matriz de opções. O valor pode ser uma coisa qualquer coisa daqui <a class="ulink" href="http://msdn.microsoft.com/en-us/library/cc296161(SQL.90).aspx" target="_top">
                            http://msdn.microsoft.com/en-us/library/cc296161(SQL.90).aspx</a>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Você pode usar <code class="methodname">setTransactionIsolationLevel()</code> para
                        definir nível de isolamento para a conexão atual. O valor pode ser
                        <code class="constant">SQLSRV_TXN_READ_UNCOMMITTED</code>,
                        <code class="constant">SQLSRV_TXN_READ_COMMITTED</code>,
                        <code class="constant">SQLSRV_TXN_REPEATABLE_READ</code>,
                        <code class="constant">SQLSRV_TXN_SNAPSHOT</code> ou
                        <code class="constant">SQLSRV_TXN_SERIALIZABLE</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        A partir de Zend Framework 1.9, a distribuição mínima suportada da
                        extesnão <acronym class="acronym">PHP</acronym> para <acronym class="acronym">SQL</acronym> Server
                        da Microsoft é a 1.0.1924.0. e o <acronym class="acronym">MSSQL</acronym> Server Native
                        Client versão 9.00.3042.00.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-ibm"></a>PDO para IBM DB2 e Informix Dynamic Server (IDS)</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique esse adaptador o método <code class="methodname">factory()</code>
                        com o nome '<code class="classname">Pdo_Ibm</code>'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Esse adaptador usa as extensões <acronym class="acronym">PHP</acronym>
                        <acronym class="acronym">PDO</acronym> e <code class="constant">PDO_IBM</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Você deve usar pelo menos a versão da extensão <code class="constant">PDO_IBM</code>
                        1.2.2. Se você tiver uma versão anterior desta extensão, você deve atualizar
                        a extensão <code class="constant">PDO_IBM</code> a partir da <acronym class="acronym">PECL</acronym>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-mssql"></a>PDO Microsoft SQL Server</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique este adaptador para o método <code class="methodname">factory()</code>
                        com o nome '<code class="classname">Pdo_Mssql</code>'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Esse adaptador usa as extensões <acronym class="acronym">PHP</acronym> pdo e pdo_dblib.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Microsoft <acronym class="acronym">SQL</acronym> Server não suporta sequências, assim
                        <code class="methodname">lastInsertId()</code> ignora seus argumentos e
                        sempre retorna o último valor gerado para uma
                        chave de autoincremento. O método <code class="methodname">lastSequenceId()</code>
                        retorna <code class="constant">NULL</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Se você está trabalhando com strings Unicode em uma codificação diferente
                        de <acronym class="acronym">UCS</acronym>-2 (tal como <acronym class="acronym">UTF</acronym>-8), você pode
                        ter que realizar uma conversão no código de sua aplicação ou armazenar os
                        dados em uma coluna binária. Por favor, consulte a <a class="ulink" href="http://support.microsoft.com/kb/232580" target="_top">Base de Conhecimento da
                            Microsoft</a> para mais informações.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <code class="classname">Zend_Db_Adapter_Pdo_Mssql</code> configura
                        <code class="constant">QUOTED_IDENTIFIER</code> ON imediatamente depois de
                        conectar-se a um banco de dados <acronym class="acronym">SQL</acronym> Server. Isso
                        faz com que o driver utilize o símbolo delimitador de identificador
                        da <acronym class="acronym">SQL</acronym> padrão ( ") em vez dos colchetes que a sintaxe
                        <acronym class="acronym">SQL</acronym> Server utiliza para delimitar identificadores.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Você pode especificar <span class="property">pdoType</span> como uma chave na
                        matriz de opções. O valor pode ser "mssql" (o padrão),
                        "dblib", "FreeTDS", ou "Sybase". Essa opção afeta
                        o prefixo <acronym class="acronym">DSN</acronym> que o adaptador usa quando constrói a
                        string <acronym class="acronym">DSN</acronym>. Tanto "FreeTDS" quanto "sybase" implicam
                        um prefixo de "sybase:", que é usado para o conjunto de bibliotecas
                        <a class="ulink" href="http://www.freetds.org/" target="_top">FreeTDS</a>.
                        Veja também
                        <a class="ulink" href="http://www.php.net/manual/en/ref.pdo-dblib.connection.php" target="_top">
                        http://www.php.net/manual/en/ref.pdo-dblib.connection.php </a>
                        Para obter mais informações sobre os prefixos <acronym class="acronym">DSN</acronym>
                        utilizados neste driver.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-mysql"></a>PDO MySQL</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique este adaptador para o método <code class="methodname">factory()</code>
                        com o nome '<code class="classname">Pdo_Mysql</code>'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Este adaptador usa as extensões <acronym class="acronym">PHP</acronym> pdo e pdo_mysql.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        O MySQL e o MariaDB não suportam sequencias, assim
                        <code class="methodname">lastInsertId()</code> ignora seus argumentos e
                        sempre retorna o último valor gerado para uma
                        chave de autoincremento. O método <code class="methodname">lastSequenceId()</code>
                        retorna <code class="constant">NULL</code>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-oci"></a>PDO Oracle</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique este adaptador para o método <code class="methodname">factory()</code>
                        com o nome '<code class="classname">Pdo_Oci</code>'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Este adaptador usa as extensões <acronym class="acronym">PHP</acronym> pdo e pdo_oci.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Oracle não suporta chaves de autoincremento, assim você
                        deve especificar o nome de uma sequencia para
                        <code class="methodname">lastInsertId()</code> ou
                        <code class="methodname">lastSequenceId()</code>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-pgsql"></a>PDO PostgreSQL</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique este adaptador para o método <code class="methodname">factory()</code>
                        com o nome '<code class="classname">Pdo_Pgsql</code>'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Este adaptador usa as extensões <acronym class="acronym">PHP</acronym> pdo e pdo_pgsql.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        PostgreSQL supporta tanto sequencias quanto chaves de
                        autoincremento. Portanto os argumentos para
                        <code class="methodname">lastInsertId()</code> são opcionais. Se você não
                        fornecer argumentos, o adaptador retorna o último valor
                        gerado para uma chave de autoincremento. Se você fornecer
                        argumentos, o adaptador retorna o último valor gerado
                        pela sequencia nomeado de acordo com a convenção
                        '<span class="emphasis"><em>table</em></span>_<span class="emphasis"><em>column</em></span>_seq'.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-sqlite"></a>PDO SQLite</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Especifique este adaptador para o método <code class="methodname">factory()</code>
                        com o nome '<code class="classname">Pdo_Sqlite</code>'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Este adaptador usa as extensões <acronym class="acronym">PHP</acronym> pdo e pdo_sqlite.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        SQLite não suporta sequencias, assim
                        <code class="methodname">lastInsertId()</code> ignora seus argumentos e
                        sempre retorna o último valor gerado para uma
                        chave de autoincremento. O método <code class="methodname">lastSequenceId()</code>
                        retorna <code class="constant">NULL</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Para conectar-se com um banco de dados SQLite2, especifique
                        <span class="command"><strong>'sqlite2' =&gt; true</strong></span> na matriz de
                        parâmetros quando criar uma instância do adaptador
                        <code class="classname">Pdo_Sqlite</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Para conectar-se com um banco de dados SQLite em memória,
                        especifique <span class="command"><strong>'dbname' =&gt; ':memory:'</strong></span> na
                        matriz de parâmetros quando criar uma instância do
                        adaptador <code class="classname">Pdo_Sqlite</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Versões antigas do driver SQLite para <acronym class="acronym">PHP</acronym> parecem não
                        suportar os comandos <acronym class="acronym">PRAGMA</acronym> necessários para garantir que
                        nomes de coluna curtos sejam usados em conjuntos de resultados. Se você
                        tem problemas que seus conjuntos de resultados são retornados com
                        chaves da forma "tablename.columnname" quando você faz uma
                        consulta com junção, então você deve atualizar para a versão
                        atual do <acronym class="acronym">PHP</acronym>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.firebird"></a>Firebird (Interbase)</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Este adaptador usa a extensão <acronym class="acronym">PHP</acronym> php_interbase.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Firebird (Interbase) não suporta chaves de autoincremento,
                        portanto, você deve especificar o nome de uma sequência para
                        <code class="methodname">lastInsertId()</code> ou
                        <code class="methodname">lastSequenceId()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Atualmente, a opção <code class="constant">Zend_Db::CASE_FOLDING</code>
                        não é suportada pelo adaptador Firebird (Interbase).
                        Identificadores não citadas são automaticamente devolvidos em
                        maiúsculas.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        O nome do adaptador é <code class="classname">ZendX_Db_Adapter_Firebird</code>.
                    </p>

                    <p>
                        Lembre-se de usar o parâmetro adapterNamespace com o valor
                        <code class="classname">ZendX_Db_Adapter</code>.
                    </p>

                    <p>
                        Recomendamos a atualização de <code class="filename">gds32.dll</code> (ou equivalente
                        Linux) empacotado junto com <acronym class="acronym">PHP</acronym>, para a mesma versão do
                        servidor. Para Firebird o equivalente de <code class="filename">gds32.dll</code> é
                        <code class="filename">fbclient.dll</code>.
                    </p>

                    <p>
                        Por padrão todos os identificadores (nomes de tabela, campos) são
                        devolvidos em caixa
                        alta.
                    </p>
                </li>
</ul></div>
        </div>
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.db.html">Anterior</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.db.html">Acima</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.db.statement.html">Próxima</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Zend_Db </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td>
<td width="40%" align="right" valign="top"> Zend_Db_Statement</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
