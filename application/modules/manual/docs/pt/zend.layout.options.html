<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Opções de Configuração Zend_Layout</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guia de Referência do Programador">
<link rel="up" href="zend.layout.html" title="Zend_Layout">
<link rel="prev" href="zend.layout.quickstart.html" title="Guia Rápido Zend_Layout">
<link rel="next" href="zend.layout.advanced.html" title="Uso Avançado de Zend_Layout">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Opções de Configuração Zend_Layout</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.layout.quickstart.html">Anterior</a> </td>
<th width="60%" align="center">Zend_Layout</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.layout.advanced.html">Próxima</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.layout.options"></a>Opções de Configuração Zend_Layout</h2></div></div></div>
    

    <p>
        <code class="classname">Zend_Layout</code> tem uma variedade de opções de configuração. Essas
        podem ser configuradas chamando os acessores apropriados, passando uma matriz ou objeto
        <code class="classname">Zend_Config</code> para o construtor ou
        <code class="methodname">startMvc()</code>, passando uma matriz de opções para
        <code class="methodname">setOptions()</code>, ou passando um objeto
        <code class="classname">Zend_Config</code> para <code class="methodname">setConfig()</code>.
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                <span class="emphasis"><em>layout</em></span>: o layout a ser usado. Utiliza o inflector atual para
                resolver o nome fornecido para o view script de layout apropriado. Por padrão,
                esse valor é 'layout' e resolve para 'layout.phtml'. Os acessores são
                <code class="methodname">setLayout()</code> e <code class="methodname">getLayout()</code>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>layoutPath</em></span>: o caminho base para os view scripts
                de layout. Os acessores são <code class="methodname">setLayoutPath()</code> e
                <code class="methodname">getLayoutPath()</code>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>contentKey</em></span>: a variável de layout usada para o conteúdo
                padrão (quando usado com o <acronym class="acronym">MVC</acronym>). O valor padrão é 'content'.
                Os acessores são <code class="methodname">setContentKey()</code> e
                <code class="methodname">getContentKey()</code>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>mvcSuccessfulActionOnly</em></span>: quando usar o
                <acronym class="acronym">MVC</acronym>, se uma ação lança uma exceção e esse marco
                é <code class="constant">TRUE</code>, o layout não será renderizado (isso é para
                prevenir dupla renderização do layout quando o <a class="link" href="zend.controller.plugins.html#zend.controller.plugins.standard.errorhandler" title="Zend_Controller_Plugin_ErrorHandler">ErrorHandler plugin</a>
                estiver em uso). Por padrão, o marco é <code class="constant">TRUE</code>. Os acessores são
                <code class="methodname">setMvcSuccessfulActionOnly()</code> e
                <code class="methodname">getMvcSuccessfulActionOnly()</code>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>view</em></span>: O objeto view para ser usado na renderização.
                Quando usado com o <acronym class="acronym">MVC</acronym>, <code class="classname">Zend_Layout</code>
                tentará usar o objeto view registrado com o
                <a class="link" href="zend.controller.actionhelpers.html#zend.controller.actionhelpers.viewrenderer" title="ViewRenderer">ViewRenderer</a>
                se nenhum objeto view tiver sido passado explicitamente. Os acessores são
                <code class="methodname">setView()</code> e <code class="methodname">getView()</code>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>helperClass</em></span>: a classe action helper para usar quando
                <code class="classname">Zend_Layout</code> estiver utilizando os componentes
                <acronym class="acronym">MVC</acronym>. Por padrão, ela é
                <code class="classname">Zend_Layout_Controller_Action_Helper_Layout</code>.
                Os acessores são <code class="methodname">setHelperClass()</code> e
                <code class="methodname">getHelperClass()</code>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>pluginClass</em></span>: a classe front controller plugin para usar
                quando <code class="classname">Zend_Layout</code> estiver utilizando os componentes
                <acronym class="acronym">MVC</acronym>. Por padrão, ela é
                <code class="classname">Zend_Layout_Controller_Plugin_Layout</code>. Os acessores são
                <code class="methodname">setPluginClass()</code> e
                <code class="methodname">getPluginClass()</code>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>inflector</em></span>: o inflector a ser usado quando resolver
                nomes para caminhos de view scripts de layout; veja
                <a class="link" href="zend.layout.advanced.html#zend.layout.advanced.inflector" title="Resolução de Caminho de Script de Layout Customizada: Usando o Inflector">a documentação
                <code class="classname">Zend_Layout</code> inflector para mais detalhes</a>. Os
                acessores são <code class="methodname">setInflector()</code> e
                <code class="methodname">getInflector()</code>.
            </p>
        </li>
</ul></div>

    <div class="note"><table border="0" summary="Note: helperClass e pluginClass devem ser passados para startMvc()">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">helperClass e pluginClass devem ser passados para startMvc()</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            Para que as configurações <span class="property">helperClass</span> e
            <span class="property">pluginClass</span> tenham efeito, elas devem ser passadas como opções para
            <code class="methodname">startMvc()</code>; se forem configuradas mais tarde,
            elas não tem efeito.
        </p>
    </td></tr>
</table></div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.layout.options.examples"></a>Exemplos</h3></div></div></div>
        

        <p>
            Os seguintes exemplos assumem a seguinte matriz <code class="varname">$options</code>
            e objeto <code class="varname">$config</code>:
        </p>

        <pre class="programlisting">
$options = array(
    'layout'     =&gt; 'foo',
    'layoutPath' =&gt; '/path/to/layouts',
    'contentKey' =&gt; 'CONTENT',           // ignorado quando o MVC não é usado
);
</pre>

        <pre class="programlisting">
/**
[layout]
layout = "foo"
layoutPath = "/path/to/layouts"
contentKey = "CONTENT"
*/
$config = new Zend_Config_Ini('/path/to/layout.ini', 'layout');
</pre>

        <div class="example">
<a name="zend.layout.options.examples.constructor"></a><p class="title"><b>Exemplo 490. Passando opções para o construtor ou startMvc()</b></p>
<div class="example-contents">
            

            <p>
                Tanto o construtor quanto o método estático <code class="methodname">startMvc()</code>
                podem aceitar tanto uma matriz de opções quanto um objeto
                <code class="classname">Zend_Config</code> com opções de modo a configurar
                a instância de <code class="classname">Zend_Layout</code>.
            </p>

            <p>Primeiro, dê uma olhada na passagem de uma matriz:</p>

            <pre class="programlisting">
// Usando um construtor:
$layout = new Zend_Layout($options);

// Usando startMvc():
$layout = Zend_Layout::startMvc($options);
</pre>

            <p>E agora usando um objeto config:</p>

            <pre class="programlisting">
$config = new Zend_Config_Ini('/path/to/layout.ini', 'layout');

// Usando construtor:
$layout = new Zend_Layout($config);

// Usando startMvc():
$layout = Zend_Layout::startMvc($config);
</pre>

            <p>
                Basicamente, esse é o modo mais fácil de customizar sua instância
                <code class="classname">Zend_Layout</code>.
            </p>
        </div>
</div>
<br class="example-break">

        <div class="example">
<a name="zend.layout.options.examples.setoptionsconfig"></a><p class="title"><b>Exemplo 491. Usando setOption() e setConfig()</b></p>
<div class="example-contents">
            

            <p>
                Algumas vezes você precisa configurar o objeto <code class="classname">Zend_Layout</code>
                depois que ele já foi instanciado; <code class="methodname">setOptions()</code> e
                <code class="methodname">setConfig()</code> dão a você um modo fácil
                e rápido de fazer isso:
            </p>

            <pre class="programlisting">
// Usando uma matriz de opções:
$layout-&gt;setOptions($options);

// Usando um objeto Zend_Config:
$layout-&gt;setConfig($options);
</pre>

            <p>
                Note, entretanto, que certas opções, tais como <span class="property">pluginClass</span> e
                <span class="property">helperClass</span>, não serão afetadas quando a passagem for feita
                por esse método; elas precisam ser passadas ao construtor ou método
                <code class="methodname">startMvc()</code>.
            </p>
        </div>
</div>
<br class="example-break">

        <div class="example">
<a name="zend.layout.options.examples.accessors"></a><p class="title"><b>Exemplo 492. Usando Acessores</b></p>
<div class="example-contents">
            

            <p>
                Finalmente, você pode também configurar sua instância
                <code class="classname">Zend_Layout</code> via acessores. Todos os acessores
                implementam uma interface fluente, significando que suas chamadas
                podem ser encadeadas:
            </p>

            <pre class="programlisting">
$layout-&gt;setLayout('foo')
       -&gt;setLayoutPath('/path/to/layouts')
       -&gt;setContentKey('CONTENT');
</pre>
        </div>
</div>
<br class="example-break">
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.layout.quickstart.html">Anterior</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.layout.html">Acima</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.layout.advanced.html">Próxima</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Guia Rápido Zend_Layout </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td>
<td width="40%" align="right" valign="top"> Uso Avançado de Zend_Layout</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
