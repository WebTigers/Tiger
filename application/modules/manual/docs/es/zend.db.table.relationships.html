<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Zend_Db_Table Relationships</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Programmer's Guía de Referencia">
<link rel="up" href="zend.db.html" title="Zend_Db">
<link rel="prev" href="zend.db.table.rowset.html" title="Zend_Db_Table_Rowset">
<link rel="next" href="zend.db.table.definition.html" title="Zend_Db_Table_Definition">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Zend_Db_Table Relationships</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.db.table.rowset.html">Anterior</a> </td>
<th width="60%" align="center">Zend_Db</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.db.table.definition.html">Siguiente</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.table.relationships"></a>Zend_Db_Table Relationships</h2></div></div></div>

    

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.introduction"></a>Introduction</h3></div></div></div>

        

        <p>
            Tables have relationships to each other in a relational database. An entity in one
            table can be linked to one or more entities in another table by using referential
            integrity constraints defined in the database schema.
       </p>

        <p>
            The
            <code class="classname">Zend_Db_Table_Row</code>
            class has methods for querying related rows
            in other tables.
        </p>

    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.defining"></a>Defining Relationships</h3></div></div></div>

        

        <p>
            Define classes for each of your tables, extending the abstract class
            <code class="classname">Zend_Db_Table_Abstract</code>
            , as described in
            <a class="xref" href="zend.db.table.html#zend.db.table.defining" title="Defining a Table Class">“Defining a Table Class”</a>
            . Also
            see
            <a class="xref" href="zend.db.adapter.html#zend.db.adapter.example-database" title="La base de datos de ejemplo">“La base de datos de ejemplo”</a>
            for a description of the
            example database for which the following example code is
            designed.
        </p>

        <p>
            Below are the
            <acronym class="acronym">PHP</acronym>
            class definitions for these tables:
        </p>

        <pre class="programlisting">
class Accounts extends Zend_Db_Table_Abstract
{
    protected $_name            = 'accounts';
    protected $_dependentTables = array('Bugs');
}

class Products extends Zend_Db_Table_Abstract
{
    protected $_name            = 'products';
    protected $_dependentTables = array('BugsProducts');
}

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name            = 'bugs';

    protected $_dependentTables = array('BugsProducts');

    protected $_referenceMap    = array(
        'Reporter' =&gt; array(
            'columns'           =&gt; 'reported_by',
            'refTableClass'     =&gt; 'Accounts',
            'refColumns'        =&gt; 'account_name'
        ),
        'Engineer' =&gt; array(
            'columns'           =&gt; 'assigned_to',
            'refTableClass'     =&gt; 'Accounts',
            'refColumns'        =&gt; 'account_name'
        ),
        'Verifier' =&gt; array(
            'columns'           =&gt; array('verified_by'),
            'refTableClass'     =&gt; 'Accounts',
            'refColumns'        =&gt; array('account_name')
        )
    );
}

class BugsProducts extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs_products';

    protected $_referenceMap    = array(
        'Bug' =&gt; array(
            'columns'           =&gt; array('bug_id'),
            'refTableClass'     =&gt; 'Bugs',
            'refColumns'        =&gt; array('bug_id')
        ),
        'Product' =&gt; array(
            'columns'           =&gt; array('product_id'),
            'refTableClass'     =&gt; 'Products',
            'refColumns'        =&gt; array('product_id')
        )
    );

}
</pre>

        <p>
            If you use
            <code class="classname">Zend_Db_Table</code>
            to emulate cascading UPDATE and DELETE
            operations, declare the
            <code class="varname">$_dependentTables</code>
            array in the class for the
            parent table. List the class name for each dependent table.
            Use the class name, not the
            physical name of the
            <acronym class="acronym">SQL</acronym>
            table.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">

            <p>
                Skip declaration of
                <code class="varname">$_dependentTables</code>
                if you use referential
                integrity constraints in the
                <acronym class="acronym">RDBMS</acronym>
                server to implement cascading
                operations. See
                <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.cascading" title="Cascading Write Operations">“Cascading Write Operations”</a>
                for more
                information.
            </p>

        </td></tr>
</table></div>

        <p>
            Declare the
            <code class="varname">$_referenceMap</code>
            array in the class for each dependent
            table. This is an associative array of reference
            "rules". A reference rule identifies
            which table is the parent table in the relationship,
            and also lists which columns in the
            dependent table reference which columns in the parent
            table.
        </p>

        <p>
            The rule key is a string used as an index to the
            <code class="varname">$_referenceMap</code>
            array. This rule key is used to identify each reference relationship. Choose a
            descriptive name for this rule key. It's best to use a string that can be part of a
            <acronym class="acronym">PHP</acronym>
            method name, as you will see later.
        </p>

        <p>
            In the example
            <acronym class="acronym">PHP</acronym>
            code above, the rule keys in the Bugs table class
            are:
            <code class="code">'Reporter'</code>
            ,
            <code class="code">'Engineer'</code>
            ,
            <code class="code">'Verifier'</code>
            , and
            <code class="code">'Product'</code>
            .
        </p>

        <p>
            The value of each rule entry in the
            <code class="varname">$_referenceMap</code>
            array is also an
            associative array. The elements of this rule entry are described below:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>columns</em></span>
                    =&gt; A string or an array of strings
                    naming the foreign key column name(s) in the
                    dependent table.
                </p>

                <p>
                    It's common for this to be a single column, but some tables have multi-column
                    keys.
               </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>refTableClass</em></span>
                    =&gt; The class name of the parent table. Use
                    the class name, not the physical name
                    of the
                    <acronym class="acronym">SQL</acronym>
                    table.
                </p>

                <p>
                    It's common for a dependent table to have only one reference to its parent
                    table, but some tables have multiple references to the same parent table. In
                    the
                    example database, there is one reference from the
                    <code class="code">bugs</code>
                    table
                    to the
                    <code class="code">products</code>
                    table, but three references from the
                    <code class="code">bugs</code>
                    table to the
                    <code class="code">accounts</code>
                    table. Put each reference
                    in a separate entry in the
                    <code class="varname">$_referenceMap</code>
                    array.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>refColumns</em></span>
                    =&gt; A string or an array of
                    strings naming the primary key column name(s) in the
                    parent table.
                </p>

                <p>
                    It's common for this to be a single column, but some tables have multi-column
                    keys. If the reference uses a multi-column key, the order of columns in the
                    <code class="code">'columns'</code>
                    entry must match the order of columns in the
                    <code class="code">'refColumns'</code>
                    entry.
                </p>

                <p>
                    It is optional to specify this element. If you don't specify the
                    <code class="code">refColumns</code>
                    , the column(s) reported as the primary key columns of
                    the parent table are used
                    by default.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>onDelete</em></span>
                    =&gt; The rule for an action to
                    execute if a row is deleted in the parent table. See
                    <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.cascading" title="Cascading Write Operations">“Cascading Write Operations”</a>
                    for more information.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>onUpdate</em></span>
                    =&gt; The rule for an action to
                    execute if values in primary key columns are updated
                    in the parent table. See
                    <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.cascading" title="Cascading Write Operations">“Cascading Write Operations”</a>
                    for more information.
                </p>
            </li>
</ul></div>

    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.fetching.dependent"></a>Fetching a Dependent Rowset</h3></div></div></div>

        

        <p>
            If you have a Row object as the result of a query on a parent table, you can fetch
            rows
            from dependent tables that reference the current row. Use the method:
       </p>

        <pre class="programlisting">
$row-&gt;findDependentRowset($table, [$rule]);
</pre>

        <p>
            This method returns a
            <code class="classname">Zend_Db_Table_Rowset_Abstract</code>
            object,
            containing a set of rows from the dependent table
            <code class="varname">$table</code>
            that refer
            to the row identified by the
            <code class="varname">$row</code>
            object.
        </p>

        <p>
            The first argument
            <code class="varname">$table</code>
            can be a string that specifies the
            dependent table by its class name. You can also
            specify the dependent table by using an
            object of that table class.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example"></a><p class="title"><b>Ejemplo 326. Fetching a Dependent Rowset</b></p>
<div class="example-contents">

            

            <p>
                This example shows getting a Row object from the table
                <code class="code">Accounts</code>
                , and
                finding the
                <code class="code">Bugs</code>
                reported by that account.
            </p>

            <pre class="programlisting">
$accountsTable = new Accounts();
$accountsRowset = $accountsTable-&gt;find(1234);
$user1234 = $accountsRowset-&gt;current();

$bugsReportedByUser = $user1234-&gt;findDependentRowset('Bugs');
</pre>

        </div>
</div>
<br class="example-break">

        <p>
            The second argument
            <code class="varname">$rule</code>
            is optional. It is a string that names the
            rule key in the
            <code class="varname">$_referenceMap</code>
            array of the dependent table class. If
            you don't specify a rule, the first rule in the
            array that references the parent table
            is used. If you need to use a rule other than the
            first, you need to specify the key.
        </p>

        <p>
            In the example code above, the rule key is not specified, so the rule used by default
            is
            the first one that matches the parent table. This is the rule
            <code class="code">'Reporter'</code>
            .
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example-by"></a><p class="title"><b>Ejemplo 327. Fetching a Dependent Rowset By a Specific Rule</b></p>
<div class="example-contents">

            

            <p>
                This example shows getting a Row object from the table
                <code class="code">Accounts</code>
                , and
                finding the
                <code class="code">Bugs</code>
                assigned to be fixed by the user of that account. The
                rule key string that
                corresponds to this reference relationship in this example is
                <code class="code">'Engineer'</code>
                .
            </p>

            <pre class="programlisting">
$accountsTable = new Accounts();
$accountsRowset = $accountsTable-&gt;find(1234);
$user1234 = $accountsRowset-&gt;current();

$bugsAssignedToUser = $user1234-&gt;findDependentRowset('Bugs', 'Engineer');
</pre>

        </div>
</div>
<br class="example-break">

        <p>
            You can also add criteria, ordering and limits to your relationships using the parent
            row's select object.
       </p>

        <p>

            </p>
<div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example-by-select"></a><p class="title"><b>Ejemplo 328. Fetching a Dependent Rowset using a Zend_Db_Table_Select</b></p>
<div class="example-contents">

                

                <p>
                    This example shows getting a Row object from the table
                    <code class="code">Accounts</code>
                    ,
                    and finding the
                    <code class="code">Bugs</code>
                    assigned to be fixed by the user of that
                    account, limited only to 3 rows and
                    ordered by name.
                </p>

                <pre class="programlisting">
$accountsTable = new Accounts();
$accountsRowset = $accountsTable-&gt;find(1234);
$user1234 = $accountsRowset-&gt;current();
$select = $accountsTable-&gt;select()-&gt;order('name ASC')
                                  -&gt;limit(3);

$bugsAssignedToUser = $user1234-&gt;findDependentRowset('Bugs',
                                                     'Engineer',
                                                     $select);
</pre>

            </div>
</div>
<p><br class="example-break">

            Alternatively, you can query rows from a dependent table using a special mechanism
            called a "magic method".
            <code class="classname">Zend_Db_Table_Row_Abstract</code>
            invokes the
            method:
            <code class="methodname">findDependentRowset('&lt;TableClass&gt;',
                '&lt;Rule&gt;')</code>
            if you invoke a method on the Row object matching
            either of the following patterns:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;find&lt;TableClass&gt;()</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;find&lt;TableClass&gt;By&lt;Rule&gt;()</code>
                </p>
            </li>
</ul></div>

        <p>
            In the patterns above,
            <code class="code">&lt;TableClass&gt;</code>
            and
            <code class="code">&lt;Rule&gt;</code>
            are
            strings that correspond to the class name of the dependent table, and the dependent
            table's rule key that references the parent table.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">

            <p>
                Some application frameworks, such as Ruby on Rails, use a mechanism called
                "inflection" to allow the spelling of identifiers to change depending on usage. For
                simplicity,
                <code class="classname">Zend_Db_Table_Row</code>
                does not provide any inflection
                mechanism. The table identity and the rule key named
                in the method call must match
                the spelling of the class and rule key exactly.
            </p>

        </td></tr>
</table></div>

        <div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example-magic"></a><p class="title"><b>Ejemplo 329. Fetching Dependent Rowsets using the Magic Method</b></p>
<div class="example-contents">

            

            <p>
                This example shows finding dependent Rowsets equivalent to those in the previous
                examples. In this case, the application uses the magic method invocation instead of
                specifying the table and rule as strings.
           </p>

            <pre class="programlisting">
$accountsTable = new Accounts();
$accountsRowset = $accountsTable-&gt;find(1234);
$user1234 = $accountsRowset-&gt;current();

// Use the default reference rule
$bugsReportedBy = $user1234-&gt;findBugs();

// Specify the reference rule
$bugsAssignedTo = $user1234-&gt;findBugsByEngineer();
</pre>

        </div>
</div>
<br class="example-break">

    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.fetching.parent"></a>Fetching a Parent Row</h3></div></div></div>

        

        <p>
            If you have a Row object as the result of a query on a dependent table, you can fetch
            the row in the parent to which the dependent row refers. Use the method:
       </p>

        <pre class="programlisting">
$row-&gt;findParentRow($table, [$rule]);
</pre>

        <p>
            There always should be exactly one row in the parent table referenced by a dependent
            row, therefore this method returns a Row object, not a Rowset object.
       </p>

        <p>
            The first argument
            <code class="varname">$table</code>
            can be a string that specifies the parent
            table by its class name. You can also specify
            the parent table by using an object of
            that table class.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.parent.example"></a><p class="title"><b>Ejemplo 330. Fetching the Parent Row</b></p>
<div class="example-contents">

            

            <p>
                This example shows getting a Row object from the table
                <code class="code">Bugs</code>
                (for
                example one of those bugs with status 'NEW'), and finding the row in the
                <code class="code">Accounts</code>
                table for the user who reported the bug.
            </p>

            <pre class="programlisting">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;fetchAll(array('bug_status = ?' =&gt; 'NEW'));
$bug1 = $bugsRowset-&gt;current();

$reporter = $bug1-&gt;findParentRow('Accounts');
</pre>

        </div>
</div>
<br class="example-break">

        <p>
            The second argument
            <code class="varname">$rule</code>
            is optional. It is a string that names the
            rule key in the
            <code class="varname">$_referenceMap</code>
            array of the dependent table class. If
            you don't specify a rule, the first rule in the
            array that references the parent table
            is used. If you need to use a rule other than the
            first, you need to specify the key.
        </p>

        <p>
            In the example above, the rule key is not specified, so the rule used by default is the
            first one that matches the parent table. This is the rule
            <code class="code">'Reporter'</code>
            .
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.parent.example-by"></a><p class="title"><b>Ejemplo 331. Fetching a Parent Row By a Specific Rule</b></p>
<div class="example-contents">

            

            <p>
                This example shows getting a Row object from the table
                <code class="code">Bugs</code>
                , and
                finding the account for the engineer assigned to fix that bug. The rule key
                string
                that corresponds to this reference relationship in this example is
                <code class="code">'Engineer'</code>
                .
            </p>

            <pre class="programlisting">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;fetchAll(array('bug_status = ?', 'NEW'));
$bug1 = $bugsRowset-&gt;current();

$engineer = $bug1-&gt;findParentRow('Accounts', 'Engineer');
</pre>

        </div>
</div>
<br class="example-break">

        <p>
            Alternatively, you can query rows from a parent table using a "magic method".
            <code class="classname">Zend_Db_Table_Row_Abstract</code>
            invokes the method:
            <code class="methodname">findParentRow('&lt;TableClass&gt;', '&lt;Rule&gt;')</code>
            if you
            invoke a method on the Row object matching either of the following patterns:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;findParent&lt;TableClass&gt;([Zend_Db_Table_Select $select])</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;findParent&lt;TableClass&gt;By&lt;Rule&gt;([Zend_Db_Table_Select
                        $select])</code>
                </p>
            </li>
</ul></div>

        <p>
            In the patterns above,
            <code class="code">&lt;TableClass&gt;</code>
            and
            <code class="code">&lt;Rule&gt;</code>
            are strings that correspond to the class name of the parent table, and the dependent
            table's rule key that references the parent table.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">

            <p>
                The table identity and the rule key named in the method call must match the
                spelling of the class and rule key exactly.
           </p>

        </td></tr>
</table></div>

        <div class="example">
<a name="zend.db.table.relationships.fetching.parent.example-magic"></a><p class="title"><b>Ejemplo 332. Fetching the Parent Row using the Magic Method</b></p>
<div class="example-contents">

            

            <p>
                This example shows finding parent Rows equivalent to those in the previous
                examples. In this case, the application uses the magic method invocation instead of
                specifying the table and rule as strings.
           </p>

            <pre class="programlisting">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;fetchAll(array('bug_status = ?', 'NEW'));
$bug1 = $bugsRowset-&gt;current();

// Use the default reference rule
$reporter = $bug1-&gt;findParentAccounts();

// Specify the reference rule
$engineer = $bug1-&gt;findParentAccountsByEngineer();
</pre>

        </div>
</div>
<br class="example-break">

    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.fetching.many-to-many"></a>Fetching a Rowset via a Many-to-many Relationship</h3></div></div></div>

        

        <p>
            If you have a Row object as the result of a query on one table in a many-to-many
            relationship (for purposes of the example, call this the "origin" table), you can
            fetch
            corresponding rows in the other table (call this the "destination" table) via an
            intersection table. Use the method:
       </p>

        <pre class="programlisting">
$row-&gt;findManyToManyRowset($table,
                           $intersectionTable,
                           [$rule1,
                               [$rule2,
                                   [Zend_Db_Table_Select $select]
                               ]
                           ]);
</pre>

        <p>
            This method returns a
            <code class="classname">Zend_Db_Table_Rowset_Abstract</code>
            containing
            rows from the table
            <code class="varname">$table</code>
            , satisfying the many-to-many relationship.
            The current Row object
            <code class="varname">$row</code>
            from the origin table is used to find
            rows in the intersection table, and that is joined
            to the destination table.
        </p>

        <p>
            The first argument
            <code class="varname">$table</code>
            can be a string that specifies the
            destination table in the many-to-many relationship by
            its class name. You can also
            specify the destination table by using an object of that
            table class.
        </p>

        <p>
            The second argument
            <code class="varname">$intersectionTable</code>
            can be a string that specifies
            the intersection table between the two tables in the
            many-to-many relationship by
            its class name. You can also specify the intersection table
            by using an object of that
            table class.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.many-to-many.example"></a><p class="title"><b>Ejemplo 333. Fetching a Rowset with the Many-to-many Method</b></p>
<div class="example-contents">

            

            <p>
                This example shows getting a Row object from the origin table
                <code class="code">Bugs</code>
                , and finding rows from the destination table
                <code class="code">Products</code>
                , representing products related to that bug.
            </p>

            <pre class="programlisting">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;find(1234);
$bug1234 = $bugsRowset-&gt;current();

$productsRowset = $bug1234-&gt;findManyToManyRowset('Products',
                                                 'BugsProducts');
</pre>

        </div>
</div>
<br class="example-break">

        <p>
            The third and fourth arguments
            <code class="varname">$rule1</code>
            and
            <code class="varname">$rule2</code>
            are optional. These are strings that name the rule keys in the
            <code class="varname">$_referenceMap</code>
            array of the intersection table.
        </p>

        <p>
            The
            <code class="varname">$rule1</code>
            key names the rule for the relationship from the
            intersection table to the origin table.
            In this example, this is the relationship from
            <code class="code">BugsProducts</code>
            to
            <code class="code">Bugs</code>
            .
        </p>

        <p>
            The
            <code class="varname">$rule2</code>
            key names the rule for the relationship from the
            intersection table to the destination
            table. In this example, this is the relationship
            from
            <code class="code">Bugs</code>
            to
            <code class="code">Products</code>
            .
        </p>

        <p>
            Similarly to the methods for finding parent and dependent rows, if you don't specify a
            rule, the method uses the first rule in the
            <code class="varname">$_referenceMap</code>
            array that
            matches the tables in the relationship. If you need to use a rule other than
            the first,
            you need to specify the key.
        </p>

        <p>
            In the example code above, the rule key is not specified, so the rules used by default
            are the first ones that match. In this case,
            <code class="varname">$rule1</code>
            is
            <code class="code">'Reporter'</code>
            and
            <code class="varname">$rule2</code>
            is
            <code class="code">'Product'</code>
            .
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.many-to-many.example-by"></a><p class="title"><b>Ejemplo 334. Fetching a Rowset with the Many-to-many Method By a Specific Rule</b></p>
<div class="example-contents">

            

            <p>
                This example shows geting a Row object from the origin table
                <code class="code">Bugs</code>
                , and finding rows from the destination table
                <code class="code">Products</code>
                , representing products related to that bug.
            </p>

            <pre class="programlisting">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;find(1234);
$bug1234 = $bugsRowset-&gt;current();

$productsRowset = $bug1234-&gt;findManyToManyRowset('Products',
                                                 'BugsProducts',
                                                 'Bug');
</pre>

        </div>
</div>
<br class="example-break">

        <p>
            Alternatively, you can query rows from the destination table in a many-to-many
            relationship using a "magic method."
            <code class="classname">Zend_Db_Table_Row_Abstract</code>
            invokes the method:
            <code class="code">findManyToManyRowset('&lt;TableClass&gt;',
                '&lt;IntersectionTableClass&gt;', '&lt;Rule1&gt;', '&lt;Rule2&gt;')</code>
            if you invoke
            a method matching any of the following patterns:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;
                        ([Zend_Db_Table_Select $select])</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;By&lt;Rule1&gt;
                        ([Zend_Db_Table_Select $select])</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;By&lt;Rule1&gt;And&lt;Rule2&gt;
                        ([Zend_Db_Table_Select $select])</code>
                </p>
            </li>
</ul></div>

        <p>
            In the patterns above,
            <code class="code">&lt;TableClass&gt;</code>
            and
            <code class="code">&lt;IntersectionTableClass&gt;</code>
            are strings that correspond to the class
            names of the destination table and the
            intersection table, respectively.
            <code class="code">&lt;Rule1&gt;</code>
            and
            <code class="code">&lt;Rule2&gt;</code>
            are strings that correspond
            to the rule keys in the intersection table that reference the
            origin table and the
            destination table, respectively.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">

            <p>
                The table identities and the rule keys named in the method call must match the
                spelling of the class and rule key exactly.
           </p>

        </td></tr>
</table></div>

        <div class="example">
<a name="zend.db.table.relationships.fetching.many-to-many.example-magic"></a><p class="title"><b>Ejemplo 335. Fetching Rowsets using the Magic Many-to-many Method</b></p>
<div class="example-contents">

            

            <p>
                This example shows finding rows in the destination table of a many-to-many
                relationship representing products related to a given bug.
           </p>

            <pre class="programlisting">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;find(1234);
$bug1234 = $bugsRowset-&gt;current();

// Use the default reference rule
$products = $bug1234-&gt;findProductsViaBugsProducts();

// Specify the reference rule
$products = $bug1234-&gt;findProductsViaBugsProductsByBug();
</pre>

        </div>
</div>
<br class="example-break">

    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.cascading"></a>Cascading Write Operations</h3></div></div></div>

        

        <div class="note"><table border="0" summary="Note: Declare DRI in the database:">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Declare DRI in the database:</th>
</tr>
<tr><td align="left" valign="top">

            

            <p>
                Declaring cascading operations in
                <code class="classname">Zend_Db_Table</code>
                is intended
                <span class="emphasis"><em>only</em></span>
                for
                <acronym class="acronym">RDBMS</acronym>
                brands that do not support
                declarative referential integrity (DRI).
            </p>

            <p>
                For example, if you use MySQL's MyISAM storage engine, or SQLite, these solutions
                do
                not support DRI. You may find it helpful to declare the cascading operations
                with
                <code class="classname">Zend_Db_Table</code>
                .
            </p>

            <p>
                If your
                <acronym class="acronym">RDBMS</acronym>
                implements DRI and the
                <code class="code">ON DELETE</code>
                and
                <code class="code">ON UPDATE</code>
                clauses, you should declare these clauses in your database
                schema, instead of using
                the cascading feature in
                <code class="classname">Zend_Db_Table</code>
                . Declaring cascading DRI rules in the
                <acronym class="acronym">RDBMS</acronym>
                is better for database performance, consistency, and
                integrity.
            </p>

            <p>
                Most importantly, do not declare cascading operations both in the
                <acronym class="acronym">RDBMS</acronym>
                and in your
                <code class="classname">Zend_Db_Table</code>
                class.
            </p>

        </td></tr>
</table></div>

        <p>
            You can declare cascading operations to execute against a dependent table when you
            apply
            an
            <code class="constant">UPDATE</code>
            or a
            <code class="constant">DELETE</code>
            to a row in a
            parent table.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.cascading.example-delete"></a><p class="title"><b>Ejemplo 336. Example of a Cascading Delete</b></p>
<div class="example-contents">

            

            <p>
                This example shows deleting a row in the
                <code class="code">Products</code>
                table, which is
                configured to automatically delete dependent rows in the
                <code class="code">Bugs</code>
                table.
            </p>

            <pre class="programlisting">
$productsTable = new Products();
$productsRowset = $productsTable-&gt;find(1234);
$product1234 = $productsRowset-&gt;current();

$product1234-&gt;delete();
// Automatically cascades to Bugs table
// and deletes dependent rows.
</pre>

        </div>
</div>
<br class="example-break">

        <p>
            Similarly, if you use
            <code class="constant">UPDATE</code>
            to change the value of a primary key
            in a parent table, you may want the value in foreign
            keys of dependent tables to be
            updated automatically to match the new value, so that such
            references are kept up to
            date.
        </p>

        <p>
            It's usually not necessary to update the value of a primary key that was generated by a
            sequence or other mechanism. But if you use a
            <span class="emphasis"><em>natural key</em></span>
            that may
            change value occasionally, it is more likely that you need to apply cascading
            updates
            to dependent tables.
        </p>

        <p>
            To declare a cascading relationship in the
            <code class="classname">Zend_Db_Table</code>
            , edit
            the rules in the
            <code class="varname">$_referenceMap</code>
            . Set the associative array keys
            <code class="code">'onDelete'</code>
            and
            <code class="code">'onUpdate'</code>
            to the string 'cascade' (or the
            constant
            <code class="constant">self::CASCADE</code>
            ). Before a row is deleted from the parent
            table, or its primary key values updated, any
            rows in the dependent table that refer to
            the parent's row are deleted or updated first.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.cascading.example-declaration"></a><p class="title"><b>Ejemplo 337. Example Declaration of Cascading Operations</b></p>
<div class="example-contents">

            

            <p>
                In the example below, rows in the
                <code class="code">Bugs</code>
                table are automatically deleted
                if the row in the
                <code class="code">Products</code>
                table to which they refer is deleted. The
                <code class="code">'onDelete'</code>
                element of the reference map entry is set to
                <code class="constant">self::CASCADE</code>
                .
            </p>

            <p>
                No cascading update is done in the example below if the primary key value in the
                parent class is changed. The
                <code class="code">'onUpdate'</code>
                element of the reference map
                entry is
                <code class="constant">self::RESTRICT</code>
                . You can get the same result by
                omitting the
                <code class="code">'onUpdate'</code>
                entry.
            </p>

            <pre class="programlisting">
class BugsProducts extends Zend_Db_Table_Abstract
{
    ...
    protected $_referenceMap = array(
        'Product' =&gt; array(
            'columns'           =&gt; array('product_id'),
            'refTableClass'     =&gt; 'Products',
            'refColumns'        =&gt; array('product_id'),
            'onDelete'          =&gt; self::CASCADE,
            'onUpdate'          =&gt; self::RESTRICT
        ),
        ...
    );
}
</pre>

        </div>
</div>
<br class="example-break">

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.relationships.cascading.notes"></a>Notes Regarding Cascading Operations</h4></div></div></div>

            

            <p>
                <span class="emphasis"><em>
                    Cascading operations invoked by
                    <code class="classname">Zend_Db_Table</code>
                    are
                    not atomic.
                </em></span>
            </p>

            <p>
                This means that if your database implements and enforces referential integrity
                constraints, a cascading
                <code class="constant">UPDATE</code>
                executed by a
                <code class="classname">Zend_Db_Table</code>
                class conflicts with the constraint, and
                results in a referential integrity
                violation. You can use cascading
                <code class="constant">UPDATE</code>
                in
                <code class="classname">Zend_Db_Table</code>
                <span class="emphasis"><em>only</em></span>
                if your database does not enforce that referential
                integrity constraint.
            </p>

            <p>
                Cascading
                <code class="constant">DELETE</code>
                suffers less from the problem of referential
                integrity violations. You can delete
                dependent rows as a non-atomic action before
                deleting the parent row that they
                reference.
            </p>

            <p>
                However, for both
                <code class="constant">UPDATE</code>
                and
                <code class="constant">DELETE</code>
                ,
                changing the database in a non-atomic way also creates the risk that another
                database user can see the data in an inconsistent state. For example, if you delete
                a row and all its dependent rows, there is a small chance that another database
                client program can query the database after you have deleted the dependent rows, but
                before you delete the parent row. That client program may see the parent row with no
                dependent rows, and assume this is the intended state of the data. There is no way
                for that client to know that its query read the database in the middle of a change.
            </p>

            <p>
                The issue of non-atomic change can be mitigated by using transactions to isolate
                your change. But some
                <acronym class="acronym">RDBMS</acronym>
                brands don't support transactions, or
                allow clients to read "dirty" changes that have
                not been committed yet.
            </p>

            <p>
                <span class="emphasis"><em>
                    Cascading operations in
                    <code class="classname">Zend_Db_Table</code>
                    are invoked
                    only by
                    <code class="classname">Zend_Db_Table</code>
                    .
                </em></span>
            </p>

            <p>
                Cascading deletes and updates defined in your
                <code class="classname">Zend_Db_Table</code>
                classes are applied if you execute the
                <code class="methodname">save()</code>
                or
                <code class="methodname">delete()</code>
                methods on the Row class. However, if you update
                or delete data using another
                interface, such as a query tool or another application,
                the cascading operations are
                not applied. Even when using
                <code class="methodname">update()</code>
                and
                <code class="methodname">delete()</code>
                methods
                in the
                <code class="classname">Zend_Db_Adapter</code>
                class, cascading operations defined in
                your
                <code class="classname">Zend_Db_Table</code>
                classes are not executed.
            </p>

            <p>
                <span class="emphasis"><em>
                    No Cascading
                    <code class="constant">INSERT</code>
                    .
                </em></span>
            </p>

            <p>
                There is no support for a cascading
                <code class="constant">INSERT</code>
                . You must insert a
                row to a parent table in one operation, and insert row(s) to a
                dependent table in a
                separate operation.
            </p>

        </div>

    </div>

</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.db.table.rowset.html">Anterior</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.db.html">Subir</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.db.table.definition.html">Siguiente</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Zend_Db_Table_Rowset </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td>
<td width="40%" align="right" valign="top"> Zend_Db_Table_Definition</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
