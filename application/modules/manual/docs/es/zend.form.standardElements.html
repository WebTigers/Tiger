<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Elementos Enviados en el Formulario Estandard de Zend Framework</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Programmer's Guía de Referencia">
<link rel="up" href="zend.form.html" title="Zend_Form">
<link rel="prev" href="zend.form.decorators.html" title="Creando un personalizado marcado de formulario usando Zend_Form_Decorator">
<link rel="next" href="zend.form.standardDecorators.html" title="Decoradores de Formulario (Form Decorartors) estándar contenidos en Zend Framework">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Elementos Enviados en el Formulario Estandard de Zend
        Framework</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.form.decorators.html">Anterior</a> </td>
<th width="60%" align="center">Zend_Form</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.form.standardDecorators.html">Siguiente</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.form.standardElements"></a>Elementos Enviados en el Formulario Estandard de Zend
        Framework</h2></div></div></div>
    

    <p> Zend Framework viene con clases de elementos concretos cubriendo la
        mayoría de los elementos de los formularios <acronym class="acronym">HTML</acronym> . La
        mayoría simplemente especifica una vista de ayuda para usar cuando se
        decora el elemento, pero varios ofrecen funcionalidad adicional. La
        siguiente es una lista de todas las clases, así como también una
        descripción de la funcionalidad que ofrecen. </p>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.button"></a>Zend_Form_Element_Button</h3></div></div></div>
        

        <p> Usada para crear elementos <acronym class="acronym">HTML</acronym> de tipo
            button, <code class="classname">Zend_Form_Element_Button</code> extiende
                <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.submit" title="Zend_Form_Element_Submit">Zend_Form_Element_Submit</a> , derivandi sy funcionalidad
            personalizada. It specifies the 'formButton' view helper for
            decoration. </p>

        <p>Like the submit element, it uses the element's label as the
            element value for display purposes; in other words, to set the text
            of the button, set the value of the element. The label will be
            translated if a translation adapter is present.</p>

        <p> Because the label is used as part of the element, the button
            element uses only the <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.viewHelper" title="Zend_Form_Decorator_ViewHelper">ViewHelper</a> and <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.dtDdWrapper" title="Zend_Form_Decorator_DtDdWrapper">DtDdWrapper</a> decorators. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.captcha"></a>Zend_Form_Element_Captcha</h3></div></div></div>
        

        <p>Los CAPTCHAs son usados para prevenir el envio automático de
            formularios por los robots y otros procesos automatizados.</p>

        <p> The Captcha form element allows you to specify which <a class="link" href="zend.captcha.adapters.html" title="CAPTCHA Adapters">Zend_Captcha adapter</a> you
            wish to utilize as a form captcha. It then sets this adapter as a
            validator to the object, and uses a Captcha decorator for rendering
            (which proxies to the CAPTCHA adapter). </p>

        <p> Adapters may be any adapters in
                <code class="classname">Zend_Captcha</code> , as well as any custom
            adapters you may have defined elsewhere. To allow this, you may pass
            an additional plugin loader type key, 'CAPTCHA' or 'captcha', when
            specifying a plugin loader prefix path: </p>

        <pre class="programlisting">
$element-&gt;addPrefixPath('My_Captcha', 'My/Captcha/', 'captcha');
</pre>

        <p> Los Captcha entonces pueden ser cargados usando el método
                <code class="methodname">setCaptcha()</code> , el cual puede tomar una
            instancia cualquiera de CAPTCHA instance, o el nombre corto del
            adaptador captcha: </p>

        <pre class="programlisting">
// instancia concreta:
$element-&gt;setCaptcha(new Zend_Captcha_Figlet());

// Usando nombre corto:
$element-&gt;setCaptcha('Dumb');
</pre>

        <p>Si desea cargar sus elementos configuración, especifique la clave
            'captcha' con un array conteniendo la clave 'captcha', o ambas
            claves 'captcha' y 'captchaOptions':</p>

        <pre class="programlisting">
// Usindo la clave captcha simple:
$element = new Zend_Form_Element_Captcha('foo', array(
    'label' =&gt; "Please verify you're a human",
    'captcha' =&gt; array(
        'captcha' =&gt; 'Figlet',
        'wordLen' =&gt; 6,
        'timeout' =&gt; 300,
    ),
));

// Usindo captcha y captchaOptions:
$element = new Zend_Form_Element_Captcha('foo', array(
    'label' =&gt; "Please verify you're a human"
    'captcha' =&gt; 'Figlet',
    'captchaOptions' =&gt; array(
        'captcha' =&gt; 'Figlet',
        'wordLen' =&gt; 6,
        'timeout' =&gt; 300,
    ),
));
</pre>

        <p> El decorador usado es determinado consultando el adaptador
            captcha. Por defecto, es usado el <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.captcha" title="Zend_Form_Decorator_Captcha">Captcha
                decorator</a> , pero un adaptador puede especificar uno
            diferente vía su método <code class="methodname">getDecorator()</code> . </p>

        <p>Como ha notado, el adaptador CAPTCHA actúa él mismo como un
            validador para el elemento. Adicionalmente, el validador NotEmpty no
            es usado y el elemento es marcado como requerido. En la mayoría de
            los casos, usted no necesitará hacer nada más para tener un captcha
            presente en su formulario.</p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.checkbox"></a>Zend_Form_Element_Checkbox</h3></div></div></div>
        

        <p> Las casillas de verificación (checkboxes) <acronym class="acronym">HTML</acronym>
            le permiten devolver un valor específico, pero básicamente funcionan
            como los booleanos: cuando está marcada, el valor es enviado; cuando
            no está marcada, no se envía nada. Internamente,
            Zend_Form_Element_Checkbox fuerza este estado. </p>

        <p> Por defecto, si la casilla (checkbox) está marcada su valor es
            '1', y si no está marcada su valor es '0'. You can specify the
            values to use using the <code class="methodname">setCheckedValue()</code>
            and <code class="methodname">setUncheckedValue()</code> accessors,
            respectively. Internally, any time you set the value, if the
            provided value matches the checked value, then it is set, but any
            other value causes the unchecked value to be set. </p>

        <p> Additionally, setting the value sets the
                <code class="methodname">checked</code> property of the checkbox. You
            can query this using <code class="methodname">isChecked()</code> or simply
            accessing the property. Using the
                <code class="methodname">setChecked($flag)</code> method will both set
            the state of the flag as well as set the appropriate checked or
            unchecked value in the element. Please use this method when setting
            the checked state of a checkbox element to ensure the value is set
            properly. </p>

        <p>
            <code class="classname">Zend_Form_Element_Checkbox</code> uses the
            'formCheckbox' view helper. The checked value is always used to
            populate it. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.file"></a>Zend_Form_Element_File</h3></div></div></div>
        

        <p> The File form element provides a mechanism for supplying file
            upload fields to your form. It utilizes <a class="link" href="zend.file.transfer.introduction.html" title="Zend_File_Transfer">Zend_File_Transfer</a> internally to provide this
            functionality, and the <code class="methodname">FormFile</code> view helper
            as also the <code class="methodname">File</code> decorator to display the
            form element. </p>

        <p> By default, it uses the <code class="methodname">Http</code> transfer
            adapter, which introspects the <code class="varname">$_FILES</code> array and
            allows you to attach validators and filters. Validators and filters
            attached to the form element will be attached to the transfer
            adapter. </p>

        <div class="example">
<a name="zend.form.standardElements.file.usage"></a><p class="title"><b>Ejemplo 444. File form element usage</b></p>
<div class="example-contents">
            

            <p>The above explanation of using the File form element may seem
                arcane, but actual usage is relatively trivial:</p>

            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload');
// ensure only 1 file
$element-&gt;addValidator('Count', false, 1);
// limit to 100K
$element-&gt;addValidator('Size', false, 102400);
// only JPEG, PNG, and GIFs
$element-&gt;addValidator('Extension', false, 'jpg,png,gif');
$form-&gt;addElement($element, 'foo');
</pre>

            <p>También debe asegurarse de que se ha provisto un tipo de
                codificación corecto al formulario; se debe utilizar
                'multipart/form-data'. Se puede hacer esto estableciendo el
                atributo 'enctype' en el formulario:</p>

            <pre class="programlisting">
$form-&gt;setAttrib('enctype', 'multipart/form-data');
</pre>

            <p> After the form is validated successfully, you must receive
                the file to store it in the final destination using
                    <code class="methodname">receive()</code> . Additionally you can
                determinate the final location using
                    <code class="methodname">getFileName()</code> : </p>

            <pre class="programlisting">
if (!$form-&gt;isValid) {
    print "Ohoh... validation error";
}

if (!$form-&gt;foo-&gt;receive()) {
    print "Error receiving the file";
}

$location = $form-&gt;foo-&gt;getFileName();
</pre>

        </div>
</div>
<br class="example-break">

        <div class="note"><table border="0" summary="Note: Ubicaciones Predeterminadas para la Carga de Archivos">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Ubicaciones Predeterminadas para la Carga de Archivos</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>Por defecto, los archivos son cargados al directorio temp del
                sistema.</p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: Valores de archivo">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Valores de archivo</th>
</tr>
<tr><td align="left" valign="top">
            

            <p> Dentro de <acronym class="acronym">HTTP</acronym> , un elemento file no tiene
                valor. Por tanto y a causa de razones de seguridad usted solo
                obtendrá el nombre del archivo cargado llamando a getValue() y
                no el destino completo. si usted necesita la información
                completa llame a getFileName() y le devolverá el destino y
                nombre de archivo completo. </p>
        </td></tr>
</table></div>

        <p> Per default the file will automatically be received when you call
                <code class="methodname">getValues()</code> on the form. The reason
            behind this behaviour is, that the file itself is the value of the
            file element. </p>

        <pre class="programlisting">
$form-&gt;getValues();
</pre>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">
            <p> Therefor another call of <code class="methodname">receive()</code>
                after calling <code class="methodname">getValues()</code> will not have
                an effect. Also creating a instance of
                    <code class="classname">Zend_File_Transfer</code> will not have an
                effect as there no file anymore to receive. </p>
        </td></tr>
</table></div>

        <p> Still, sometimes you may want to call
                <code class="methodname">getValues()</code> without receiving the file.
            You can archive this by calling
                <code class="methodname">setValueDisabled(true)</code> . To get the
            actual value of this flag you can call
                <code class="methodname">isValueDisabled()</code> . </p>

        <div class="example">
<a name="zend.form.standardElements.file.retrievement"></a><p class="title"><b>Ejemplo 445. Explicit file retrievement</b></p>
<div class="example-contents">
            

            <p> First call <code class="methodname">setValueDisabled(true)</code> . </p>

            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload')
        -&gt;setValueDisabled(true);
</pre>

            <p> Now the file will not be received when you call
                    <code class="methodname">getValues()</code> . So you must call
                    <code class="methodname">receive()</code> on the file element, or
                an instance of <code class="classname">Zend_File_Transfer</code>
                yourself. </p>

            <pre class="programlisting">
$values = $form-&gt;getValues();

if ($form-&gt;isValid($form-&gt;getPost())) {
    if (!$form-&gt;foo-&gt;receive()) {
        print "Upload error";
    }
}
</pre>
        </div>
</div>
<br class="example-break">

        <p>There are several states of the uploaded file which can be checked
            with the following methods:</p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="methodname">isUploaded()</code> : Checks if the file
                    element has been uploaded or not. </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">isReceived()</code> : Checks if the file
                    element has already been received. </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">isFiltered()</code> : Checks if the
                    filters have already been applied to the file element or
                    not. </p>
            </li>
</ul></div>

        <div class="example">
<a name="zend.form.standardElements.file.isuploaded"></a><p class="title"><b>Ejemplo 446. Checking if an optional file has been uploaded</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload')
        -&gt;setRequired(false);
$element-&gt;addValidator('Size', false, 102400);
$form-&gt;addElement($element, 'foo');

// The foo file element is optional but when it's given go into here
if ($form-&gt;foo-&gt;isUploaded()) {
    // foo file given... do something
}
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            <code class="classname">Zend_Form_Element_File</code> soporta también
            archivos múltiples. Para llamar el método
                <code class="methodname">setMultiFile($count)</code> usted puede
            establecer la cantidad de elementos file que usted desea crear. Esto
            le previene de establecer la misma configuración varias veces. </p>

        <div class="example">
<a name="zend.form.standardElements.file.multiusage"></a><p class="title"><b>Ejemplo 447. Configuración de múltiples archivos</b></p>
<div class="example-contents">
            

            <p> Crear un elemento multi archivo es lo mismo que querer
                configurar un elemento único. Sólo tiene que llamar a
                    <code class="methodname">setMultiFile()</code> adicionalmente
                después de la creación: </p>

            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload');
// asegura mínimo 1, maximo 3 archivos
$element-&gt;addValidator('Count', false, array('min' =&gt; 1, 'max' =&gt; 3));
// limita a 100K
$element-&gt;addValidator('Size', false, 102400);
// solo JPEG, PNG, y GIFs
$element-&gt;addValidator('Extension', false, 'jpg,png,gif');
// define 3 elementos file idénticos
$element-&gt;setMultiFile(3);
$form-&gt;addElement($element, 'foo');
</pre>

            <p> En su vista usted ahora obtendrá 3 elementos para carga de
                archivos idénticos los cuales comparten la misma configuración.
                Para obtener el conjunto del número de archivos múltiples
                simplemente llame a <code class="methodname">getMultiFile()</code> . </p>

        </div>
</div>
<br class="example-break">

        <div class="note"><table border="0" summary="Note: Elementos File en Subformularios">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Elementos File en Subformularios</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>Cuando usted use elementos file en subformularios debería
                establecer nombres únicos. Así, cuando usted nombre su elemento
                file en el subformulario1, debe darle un nombre diferente en el
                subformularios.</p>

            <p>Tan pronto como haya dos elementos file nombrados de forma
                idéntica, el segundo elemento no se mostrará o enviará.</p>

            <p> Additionally, file elements are not rendered within the
                sub-form. So when you add a file element into a subform, then
                the element will be rendered within the main form. </p>
        </td></tr>
</table></div>

        <p> Para limitar el tamaño del archivo, el cual es cargado por el
            cliente, debe establecer el tamaño máximo de archivo que el
            formulario acepta . Esto limitará el tamaño del archivo en el lado
            del cliente configurando la opción
                <code class="constant">MAX_FILE_SIZE</code> en el formulario. Tan pronto
            como establezca este valor usando el método
                <code class="methodname">setMaxFileSize($size)</code> , será generado
            con el elemento file. </p>

        <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload')
        -&gt;addValidator('Size', false, 102400) // límite en 100K
        -&gt;setMaxFileSize(102400); // limita el tamaño del archivo en el lado del cliente
$form-&gt;addElement($element, 'foo');
</pre>

        <div class="note"><table border="0" summary="Note: MaxFileSize con elementos file múltiples">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">MaxFileSize con elementos file múltiples</th>
</tr>
<tr><td align="left" valign="top">
            

            <p> Cuando usted usa elementos file múltiples en los formularios
                tiene que establecer el <code class="constant">MAX_FILE_SIZE</code> una
                sola vez. Establecerlo otra vez sobreescribirá el valor
                previamente establecido. </p>

            <p> Note que usted puede establecer
                    <code class="constant">MAX_FILE_SIZE</code> una sola vez, incluso si
                usa múltiples formularios. </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.hidden"></a>Zend_Form_Element_Hidden</h3></div></div></div>
        

        <p> Los elementos Hidden simplemente inyectan datos que deben ser
            enviados, pero que el usuario no debe manipular.
                <code class="classname">Zend_Form_Element_Hidden</code> logra esto a
            través del uso del helper de vista 'formHidden'. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.hash"></a>Zend_Form_Element_Hash</h3></div></div></div>
        

        <p>Este elemento provee protección de ataques desde CSRF sobre
            formularios, asegurando que el dato es enviado por la sesión del
            usuario que generó el formulario y no por un script malicioso. La
            protección se logra mediante la adición de un elemento hash a un
            formulario y verificandolo cuando el formulario es enviado.</p>

        <p> El nombre del elemento hash debe ser único. Se recomienda usar la
            opción <code class="literal">salt</code> para el elemento, dos hashes con el
            mismo nombre y diferentes salts no chocan: </p>

        <pre class="programlisting">
$form-&gt;addElement('hash', 'no_csrf_foo', array('salt' =&gt; 'unique'));
</pre>

        <p> Puede establecer el salt más tarde usando el método
                <code class="methodname">setSalt($salt)</code> . </p>

        <p> Internamente, el elemento almacena un identificador único usando
                <code class="classname">Zend_Session_Namespace</code> , y lo comprueba
            en el momento que se envía (comprueba que el TTL no ha espirado). El
            validador 'Identical' entonces es usado para asegurarse que el hash
            enviado marcha con el hash alamacenado. </p>

        <p>El helper de vista 'formHidden' es usado para generar el elemento
            en el formulario. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.Image"></a>Zend_Form_Element_Image</h3></div></div></div>
        

        <p>Las imágenes pueden ser usadas como elementos de formulario, y le
            permiten especificar elementos gráficos como botones de
            formulario.</p>

        <p> Los elementos Image necesitan una imagen fuente.
                <code class="classname">Zend_Form_Element_Image</code> le permite
            especificar esto usando el método de acceso
                <code class="methodname">setImage()</code> (o clave de configuración
            'image'). Opcionalmente, también puede especificar un valor para
            utilizar al momento de enviar la imagen utilizando el método de
            acceso <code class="methodname">setImageValue()</code> (o clave de
            configuración 'imageValue'). Cuando el valor establecido para el
            elemento sea igual a <code class="methodname">imageValue</code> , entonces
            el método de acceso <code class="methodname">isChecked()</code> devolverá
                <code class="constant">TRUE</code> . </p>

        <p> Los elementos Image usan el <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.image" title="Zend_Form_Decorator_Image">Decorador de Imagen
            </a> para generar (así como el estandard Errors, HtmlTag, y
            decorador Label). Opcionalmente, puede especificar una etiqueta para
            el decorador <code class="methodname">Image</code> que luego envuelva al
            elemento imagen. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.multiCheckbox"></a>Zend_Form_Element_MultiCheckbox</h3></div></div></div>
        

        <p> En ocasiones, se tiene un conjunto de checkboxes, y se desea
            agrupar los resultados. Esto es como un <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.multiselect" title="Zend_Form_Element_Multiselect">Multiselect</a> , pero en lugar de estar en una lista
            desplegable, necesita mostrarlos en pares checkbox/value (casilla de
            verificación/valor). </p>

        <p>
            <code class="classname">Zend_Form_Element_MultiCheckbox</code> hace esto
            sencillo. Like all other elements extending the base Multi element,
            you can specify a list of options, and easily validate against that
            same list. The 'formMultiCheckbox' view helper ensures that these
            are returned as an array in the form submission. </p>

        <p> Por defecto, este elemnto requiere un validador
                <code class="methodname">InArray</code> el cual valida contra el array
            de llaves de las opciones registradas. Se puede desactivar esta
            caracteristica llamando a
                <code class="methodname">setRegisterInArrayValidator(false)</code> , o
            pasando un valor <code class="constant">FALSE</code> a la configuración de llaves
                <code class="methodname">registerInArrayValidator</code> . </p>

        <p>Se puede manipular las opciones de checkbox usando los siguinetes
            métodos:</p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="methodname">addMultiOption($option, $value)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">addMultiOptions(array $options)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code>
                    (overwrites existing options) </p>
            </li>
<li class="listitem">
                <p>getMultiOption($option)</p>
            </li>
<li class="listitem">
                <p>getMultiOptions()</p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">removeMultiOption($option)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">clearMultiOptions()</code>
                </p>
            </li>
</ul></div>

        <p> Para marcar los valores confirmados, se necesita pasar un array
            de valores a <code class="methodname">setValue()</code> . El siguiente
            código verificará los valores "bar" y "bat": </p>

        <pre class="programlisting">
$element = new Zend_Form_Element_MultiCheckbox('foo', array(
    'multiOptions' =&gt; array(
        'foo' =&gt; 'Foo Option',
        'bar' =&gt; 'Bar Option',
        'baz' =&gt; 'Baz Option',
        'bat' =&gt; 'Bat Option',
    )
));

$element-&gt;setValue(array('bar', 'bat'));
</pre>

        <p>Note que cuando se determina un asimple variable, se debe pasar un
            array.</p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.multiselect"></a>Zend_Form_Element_Multiselect</h3></div></div></div>
        

        <p>
            <acronym class="acronym">XHTML</acronym>
            <code class="methodname">selector</code> de elementos permite 'multiple'
            atributos, indicando multiples opciones pueden ser seleccionados por
            submision, en vez de lo usual.
                <code class="classname">Zend_Form_Element_Multiselect</code> extiende
                <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.select" title="Zend_Form_Element_Select">Zend_Form_Element_Select</a> , y define los atributos
                <code class="methodname">multiple</code> a 'multiple'. Como las otras
            clases que heredan de la clase base
                <code class="classname">Zend_Form_Element_Multi</code> , se puede
            manipular las opciones del selector usando: </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="methodname">addMultiOption($option, $value)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">addMultiOptions(array $options)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code>
                    (overwrites existing options) </p>
            </li>
<li class="listitem">
                <p>getMultiOption($option)</p>
            </li>
<li class="listitem">
                <p>getMultiOptions()</p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">removeMultiOption($option)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">clearMultiOptions()</code>
                </p>
            </li>
</ul></div>

        <p>Si un adaptador de tranducción es registrado con el formulario y/o
            elemnto, la opción valores será traducido para propósito de
            despliegue.</p>

        <p> Por defecto, este elemento registra un validador
                <code class="methodname">InArray</code> el cual valida contra el array
            de llaves de opciones registradas. se puede deshabilitar esta
            caracteristica llamando a
                <code class="methodname">setRegisterInArrayValidator(false)</code> , o
            pasando un valor <code class="constant">FALSE</code> a la configuracion de llaves
                <code class="methodname">registerInArrayValidator</code> . </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.password"></a>Zend_Form_Element_Password</h3></div></div></div>
        

        <p>Elementos contraseña son basicamente elementos de texto -- excepto
            que tipicamente no se quiera desplegar la contraseña en los mensajes
            de error o del elemnto en si cuando el formulario es re
            desplegado.</p>

        <p>
            <code class="classname">Zend_Form_Element_Password</code> archiva esto
            llamando <code class="methodname">setObscureValue(true)</code> en cada
            validador (asegurando que la contraseña este oculta en mensajes de
            validación de errores), y usando la vista ayuda 'formPassword' (el
            cual no desplega el valor pasado). </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.radio"></a>Zend_Form_Element_Radio</h3></div></div></div>
        

        <p> elementos de Radio permite especificar muchas opciones, de los
            cuales se necesita retornar un solo valor.
                <code class="classname">Zend_Form_Element_Radio</code> extiende la clase
            base <code class="classname">Zend_Form_Element_Multi</code> , permitiendonos
            especificar un numero de opciones, y luego usa la vista ayuda
                <code class="methodname">formRadio</code> para desplegar. </p>

        <p> Por defecto, este elemento registra un validador
                <code class="methodname">InArray</code> el cual valida contra el array
            de llaves de opciones registradas. se puede deshabilitar esta
            caracteristica llamando a
                <code class="methodname">setRegisterInArrayValidator(false)</code> , o
            pasando un valor <code class="constant">FALSE</code> a la configuracion de llaves
                <code class="methodname">registerInArrayValidator</code> .
            configuration key. </p>

        <p>Como todos los elementos se extienden del elemento clase base
            Multi, los siguientes métodos pueden ser usados para manipular las
            opciones de radio desplegadas:</p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="methodname">addMultiOption($option, $value)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">addMultiOptions(array $options)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code>
                    (overwrites existing options) </p>
            </li>
<li class="listitem">
                <p>getMultiOption($option)</p>
            </li>
<li class="listitem">
                <p>getMultiOptions()</p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">removeMultiOption($option)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">clearMultiOptions()</code>
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.reset"></a>Zend_Form_Element_Reset</h3></div></div></div>
        

        <p>Botones Reset son tipicamente usados para limpiar un formulario, y
            no son parte de la información sometida. Como sea, como ellos sirven
            como propósito en el despliegue, son incluidos en los elementos
            estándar.</p>

        <p>
            <code class="classname">Zend_Form_Element_Reset</code> extends <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.submit" title="Zend_Form_Element_Submit">Zend_Form_Element_Submit</a> . Tal cual, la etiqueta es
            usada para desplegar el botón y será traducido si el adaptador
            traducción esta presente. Se utiliza sólo los decoradores
            'ViewHelper' y 'DtDdWrapper', nunca debería existir mensajes de
            error para tales elementos, no se necesitará una etiqueta. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.select"></a>Zend_Form_Element_Select</h3></div></div></div>
        

        <p> Cajas selectoras son una manera común de limitar espeficias
            opciones para un dado formulario datum.
                <code class="classname">Zend_Form_Element_Select</code> le permite
            generar esto rápido y fácil. </p>

        <p> Por defecto, este elemento registra un validador
                <code class="methodname">InArray</code> el cual valida contra el array
            de llaves de opciones registradas. se puede deshabilitar esta
            caracteristica llamando a
                <code class="methodname">setRegisterInArrayValidator(false)</code> , o
            pasando un valor <code class="constant">FALSE</code> a la configuracion de llaves
                <code class="methodname">registerInArrayValidator</code> .
            configuration key. </p>

        <p>Como se extiende el elemento base Multi, los siguientes métodos
            pueden ser usados para manipular las opciones seleccionadas:</p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="methodname">addMultiOption($option, $value)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">addMultiOptions(array $options)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code>
                    (overwrites existing options) </p>
            </li>
<li class="listitem">
                <p>getMultiOption($option)</p>
            </li>
<li class="listitem">
                <p>getMultiOptions()</p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">removeMultiOption($option)</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">clearMultiOptions()</code>
                </p>
            </li>
</ul></div>

        <p>
            <code class="classname">Zend_Form_Element_Select</code> usa la vista ayuda
            'formSelect' para decoración. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.submit"></a>Zend_Form_Element_Submit</h3></div></div></div>
        

        <p> Submit buttons are used to submit a form. You may use multiple
            submit buttons; you can use the button used to submit the form to
            decide what action to take with the data submitted.
                <code class="classname">Zend_Form_Element_Submit</code> makes this
            decisioning easy, by adding a <code class="methodname">isChecked()</code>
            method; as only one button element will be submitted by the form,
            after populating or validating the form, you can call this method on
            each submit button to determine which one was used. </p>

        <p>
            <code class="classname">Zend_Form_Element_Submit</code> usa la etiqueta como
            el "valor" del botón sometido, traduciendolo si el adaptador
            traducción esta presente. <code class="methodname">isChecked()</code>
            verifica el valor sometido contra la etiqueta en orden to determinar
            si el botón ha sido usado. </p>

        <p> El <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.viewHelper" title="Zend_Form_Decorator_ViewHelper">ViewHelper</a> y <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.dtDdWrapper" title="Zend_Form_Decorator_DtDdWrapper">DtDdWrapper</a> decoradores generan al elemento. no
            decorador de etiquetas es usado, como el botón etiqueta es usado
            cuando se generan los elementos; asi tipicamente, no se asociarán
            errores con el elemnto sometido. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.text"></a>Zend_Form_Element_Text</h3></div></div></div>
        

        <p> Lejos el mas prevaleciente tipo de formulario es el elemento
            texto, permitido para entrada de texto limitado; es un elemento
            ideal para la entrada de la información.
                <code class="classname">Zend_Form_Element_Text</code> simplemente usa la
            vista ayuda 'formText' para desplegar el elemento. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.textarea"></a>Zend_Form_Element_Textarea</h3></div></div></div>
        

        <p> Textareas son usadas cuando se espera una larga cantidad de texto
            y no limites en la cantidad de texto sometido ( otro que el máximo
            tamaño tomado por su servidor or <acronym class="acronym">PHP</acronym> ).
                <code class="classname">Zend_Form_Element_Textarea</code> usa la vista
            ayuda 'textArea' para desplegar tales elementos, ocupando el valor
            como el contendio del elemento. </p>
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.form.decorators.html">Anterior</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.form.html">Subir</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.form.standardDecorators.html">Siguiente</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Creando un personalizado marcado de formulario usando
        Zend_Form_Decorator </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td>
<td width="40%" align="right" valign="top"> Decoradores de Formulario (Form Decorartors) estándar contenidos en
        Zend Framework</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
