<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Clases de Validación Estándar</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Programmer's Guía de Referencia">
<link rel="up" href="zend.validate.html" title="Zend_Validate">
<link rel="prev" href="zend.validate.introduction.html" title="Introducción">
<link rel="next" href="zend.validate.validator_chains.html" title="Cadenas de Validadores">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Clases de Validación Estándar</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.validate.introduction.html">Anterior</a> </td>
<th width="60%" align="center">Zend_Validate</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.validate.validator_chains.html">Siguiente</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.validate.set"></a>Clases de Validación Estándar</h2></div></div></div>

    

    <p>Zend Framework viene con un conjunto estándar de clases de validación
        listas para usar.</p>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.alnum"></a>Alnum</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> contiene caracteres alfanuméricos
            únicamente. Este validador incluye una opción para considerar
            también al espacio en blanco como caracter válido. </p>
    </div>

    <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">
        <p>Los caracteres alfabéticos significan caracteres que componen
            palabras en cada idioma. Sin embargo, el alfabeto inglés es tratado
            como caracteres alfabéticos en los siguientes idiomas: chino,
            japonés, coreano. El lenguaje es especificado por
            Zend_Locale.</p>
    </td></tr>
</table></div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.alpha"></a>Alpha</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> sólo contiene caracteres alfabéticos.
            Este validador incluye una opción para considerar también al espacio
            en blanco como caracter válido. </p>
    </div>

    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.barcode"></a>Barcode</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Barcode</code> allows you to check if a given value can be
        represented as barcode.
    </p>

    <p>
        <code class="classname">Zend_Validate_Barcode</code> supports multiple barcode standards and can be
        extended with proprietary barcode implementations very easily. The following barcode
        standards are supported:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE25</em></span>: Often called "two of five" or "Code25 Industrial".
            </p>

            <p>
                This barcode has no length limitation. It supports only digits, and the last digit
                can be an optional checksum which is calculated with modulo 10. This standard is
                very old and nowadays not often used. Common usecases are within the industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE25INTERLEAVED</em></span>: Often called "Code 2 of 5 Interleaved".
            </p>

            <p>
                This standard is a variant of CODE25. It has no length limitation, but it must
                contain an even amount of characters. It supports only digits, and the last digit
                can be an optional checksum which is calculated with modulo 10. It is used worldwide
                and common on the market.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE39</em></span>: CODE39 is one of the oldest available codes.
            </p>

            <p>
                This barcode has a variable length. It supports digits, upper cased alphabetical
                characters and 7 special characters like whitespace, point and dollar sign. It can
                have an optional checksum which is calculated with modulo 43. This standard is used
                worldwide and common within the industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE39EXT</em></span>: CODE39EXT is an extension of CODE39.
            </p>

            <p>
                This barcode has the same properties as CODE39. Additionally it allows the usage of
                all 128 ASCII characters. This standard is used worldwide and common within the
                industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE93</em></span>: CODE93 is the successor of CODE39.
            </p>

            <p>
                This barcode has a variable length. It supports digits, alphabetical characters
                and 7 special characters. It has an optional checksum which is calculated with
                modulo 47 and contains 2 characters. This standard produces a denser code than
                CODE39 and is more secure.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE93EXT</em></span>: CODE93EXT is an extension of CODE93.
            </p>

            <p>
                This barcode has the same properties as CODE93. Additionally it allows the usage of
                all 128 ASCII characters. This standard is used worldwide and common within the
                industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN2</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                These barcode must have 2 characters. It supports only digits and does not have a
                checksum. This standard is mainly used as addition to EAN13 (ISBN) when printed on
                books.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN5</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                These barcode must have 5 characters. It supports only digits and does not have a
                checksum. This standard is mainly used as addition to EAN13 (ISBN) when printed on
                books.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN8</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                These barcode can have 7 or 8 characters. It supports only digits. When it has a
                length of 8 characters it includes a checksum. This standard is used worldwide but
                has a very limited range. It can be found on small articles where a longer barcode
                could not be printed.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN12</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                This barcode must have a length of 12 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                used within the USA and common on the market. It has been superceded by EAN13.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN13</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                This barcode must have a length of 13 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                used worldwide and common on the market.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN14</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                This barcode must have a length of 14 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                used worldwide and common on the market. It is the successor for EAN13.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN18</em></span>: EAN is the shortcut for "European Article Number".
            </p>

            <p>
                This barcode must have a length of 18 characters. It support only digits. The last
                digit is always a checksum digit which is calculated with modulo 10. This code is
                often used for the identification of shipping containers.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>GTIN12</em></span>: GTIN is the shortcut for "Global Trade Item Number".
            </p>

            <p>
                This barcode uses the same standard as EAN12 and is its successor. It's commonly
                used within the USA.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>GTIN13</em></span>: GTIN is the shortcut for "Global Trade Item Number".
            </p>

            <p>
                This barcode uses the same standard as EAN13 and is its successor. It is used
                worldwide by industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>GTIN14</em></span>: GTIN is the shortcut for "Global Trade Item Number".
            </p>

            <p>
                This barcode uses the same standard as EAN14 and is its successor. It is used
                worldwide and common on the market.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>IDENTCODE</em></span>: Identcode is used by Deutsche Post and DHL. It's an
                specialized implementation of Code25.
            </p>

            <p>
                This barcode must have a length of 12 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                mainly used by the companies DP and DHL.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>INTELLIGENTMAIL</em></span>: Intelligent Mail is a postal barcode.
            </p>

            <p>
                This barcode can have a length of 20, 25, 29 or 31 characters. It supports only
                digits, and contains no checksum. This standard is the successor of
                <acronym class="acronym">PLANET</acronym> and <acronym class="acronym">POSTNET</acronym>. It is mainly used by the
                United States Postal Services.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>ISSN</em></span>: <acronym class="acronym">ISSN</acronym> is the abbreviation for
                International Standard Serial Number.
            </p>

            <p>
                This barcode can have a length of 8 or 13 characters. It supports only digits,
                and the last digit must be a checksum digit which is calculated with modulo 11.
                It is used worldwide for printed publications.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>ITF14</em></span>: ITF14 is the GS1 implementation of an Interleaved Two
                of Five bar code.
            </p>

            <p>
                This barcode is a special variant of Interleaved 2 of 5. It must have a length of
                14 characters and is based on GTIN14. It supports only digits, and the last digit
                must be a checksum digit which is calculated with modulo 10. It is used worldwide
                and common within the market.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>LEITCODE</em></span>: Leitcode is used by Deutsche Post and DHL. It's an
                specialized implementation of Code25.
            </p>

            <p>
                This barcode must have a length of 14 characters. It supports only digits, and the
                last digit is always a checksum which is calculated with modulo 10. This standard is
                mainly used by the companies DP and DHL.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>PLANET</em></span>: Planet is the abbreviation for Postal Alpha Numeric
                Encoding Technique.
            </p>

            <p>
                This barcode can have a length of 12 or 14 characters. It supports only digits, and
                the last digit is always a checksum. This standard is mainly used by the United
                States Postal Services.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>POSTNET</em></span>: Postnet is used by the US Postal Service.
            </p>

            <p>
                This barcode can have a length of 6, 7, 10 or 12 characters. It supports only
                digits, and the last digit is always a checksum. This standard is mainly used
                by the United States Postal Services.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>ROYALMAIL</em></span>: Royalmail is used by Royal Mail.
            </p>

            <p>
                This barcode has no defined length. It supports digits, uppercased letters, and the
                last digit is always a checksum. This standard is mainly used by Royal Mail for
                their Cleanmail Service. It is also called <acronym class="acronym">RM4SCC</acronym>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>SSCC</em></span>: SSCC is the shortcut for "Serial Shipping Container
                Code".
            </p>

            <p>
                This barcode is a variant of EAN barcode. It must have a length of 18 characters and
                supports only digits. The last digit must be a checksum digit which is calculated
                with modulo 10. It is commonly used by the transport industry.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>UPCA</em></span>: UPC is the shortcut for "Univeral Product Code".
            </p>

            <p>
                This barcode preceeded EAN13. It must have a length of 12 characters and supports
                only digits. The last digit must be a checksum digit which is calculated with
                modulo 10. It is commonly used within the USA.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>UPCE</em></span>: UPCE is the short variant from UPCA.
            </p>

            <p>
                This barcode is a smaller variant of UPCA. It can have a length of 6, 7 or 8
                characters and supports only digits. When the barcode is 8 chars long it includes
                a checksum which is calculated with modulo 10. It is commonly used with small
                products where a UPCA barcode would not fit.
            </p>
        </li>
</ul></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.options"></a>Supported options for Zend_Validate_Barcode</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Barcode</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">adapter</span></em></span>: Sets the barcode adapter
                    which will be used. Supported are all above noted adapters. When using a self
                    defined adapter, then you have to set the complete classname.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">checksum</span></em></span>: <code class="constant">TRUE</code>
                    when the barcode should contain a checksum. The default value depends on the
                    used adapter. Note that some adapters don't allow to set this option.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">options</span></em></span>: Defines optional options for
                    a self written adapters.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            To validate if a given string is a barcode you just need to know its type. See the
            following example for an EAN13 barcode:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Barcode('EAN13');
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.checksum"></a>Optional checksum</h4></div></div></div>
        

        <p>
            Some barcodes can be provided with an optional checksum. These barcodes would be valid
            even without checksum. Still, when you provide a checksum, then you should also validate
            it. By default, these barcode types perform no checksum validation. By using the
            <span class="property">checksum</span> option you can define if the checksum will be validated or
            ignored.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Barcode(array(
    'adapter'  =&gt; 'EAN13',
    'checksum' =&gt; false,
));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <div class="note"><table border="0" summary="Note: Reduced security by disabling checksum validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Reduced security by disabling checksum validation</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                 By switching off checksum validation you will also reduce the security of the used
                 barcodes. Additionally you should note that you can also turn off the checksum
                 validation for those barcode types which must contain a checksum value. Barcodes
                 which would not be valid could then be returned as valid even if they are not.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.custom"></a>Writing custom adapters</h4></div></div></div>
        

        <p>
            You may write custom barcode validators for usage with
            <code class="classname">Zend_Validate_Barcode</code>; this is often necessary when dealing with
            proprietary barcode types. To write your own barcode validator, you need the following
            information.
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Length</em></span>: The length your barcode must have. It can have one
                    of the following values:
                </p>

                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>Integer</em></span>: A value greater 0, which means that the
                            barcode must have this length.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>-1</em></span>: There is no limitation for the length of this
                            barcode.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>"even"</em></span>: The length of this barcode must have a
                            even amount of digits.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>"odd"</em></span>: The length of this barcode must have a
                            odd amount of digits.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>array</em></span>: An array of integer values. The length of
                            this barcode must have one of the set array values.
                        </p>
                    </li>
</ul></div>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Characters</em></span>: A string which contains all allowed characters
                    for this barcode. Also the integer value 128 is allowed, which means the first
                    128 characters of the ASCII table.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Checksum</em></span>: A string which will be used as callback for a
                    method which does the checksum validation.
                </p>
            </li>
</ul></div>

        <p>
            Your custom barcode validator must extend
            <code class="classname">Zend_Validate_Barcode_AdapterAbstract</code> or implement
            <span class="interface">Zend_Validate_Barcode_AdapterInterface</span>.
        </p>

        <p>
            As an example, let's create a validator that expects an even number of characters that
            include all digits and the letters 'ABCDE', and which requires a checksum.
        </p>

        <pre class="programlisting">
class My_Barcode_MyBar extends Zend_Validate_Barcode_AdapterAbstract
{
    protected $_length     = 'even';
    protected $_characters = '0123456789ABCDE';
    protected $_checksum   = '_mod66';

    protected function _mod66($barcode)
    {
        // do some validations and return a boolean
    }
}

$valid = new Zend_Validate_Barcode('My_Barcode_MyBar');
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>
</div>
        

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.between"></a>Between</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> está entre los valores límites mínimo
            y máximo. La comparación es inclusiva por defecto (
                <code class="varname">$valor</code> puede ser igual a una valor límite),
            aunque esto puede ser anulado a fin de hacer una comparación
            estricta, donde <code class="varname">$valor</code> debe ser estrictamente
            mayor al mínimo y estrictamente menor al máximo. </p>
    </div>

    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.callback"></a>Callback</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Callback</code> allows you to provide a callback with which to
        validate a given value.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.options"></a>Supported options for Zend_Validate_Callback</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Callback</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">callback</span></em></span>: Sets the callback which will
                    be called for the validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">options</span></em></span>: Sets the additional options
                    which will be given to the callback.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            The simplest usecase is to have a single function and use it as a callback. Let's expect
            we have the following function.
        </p>

        <pre class="programlisting">
function myMethod($value)
{
    // some validation
    return true;
}
</pre>

        <p>
            To use it within <code class="classname">Zend_Validate_Callback</code> you just have to call it
            this way:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback('myMethod');
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.closure"></a>Usage with closures</h4></div></div></div>
        

        <p>
            <acronym class="acronym">PHP</acronym> 5.3 introduces <a class="ulink" href="http://php.net/functions.anonymous" target="_top">closures</a>, which are basically
            self-contained or <span class="emphasis"><em>anonymous</em></span> functions. <acronym class="acronym">PHP</acronym>
            considers closures another form of callback, and, as such, may be used with
            <code class="classname">Zend_Validate_Callback</code>. As an example:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(function($value){
    // some validation
    return true;
});

if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.class"></a>Usage with class-based callbacks</h4></div></div></div>
        

        <p>
            Of course it's also possible to use a class method as callback. Let's expect we have
            the following class method:
        </p>

        <pre class="programlisting">
class MyClass
{
    public function myMethod($value)
    {
        // some validation
        return true;
    }
}
</pre>

        <p>
            The definition of the callback is in this case almost the same. You have just to create
            an instance of the class before the method and create an array describing the callback:
        </p>

        <pre class="programlisting">
$object = new MyClass;
$valid = new Zend_Validate_Callback(array($object, 'myMethod'));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            You may also define a static method as a callback. Consider the following class
            definition and validator usage:
        </p>

        <pre class="programlisting">
class MyClass
{
    public static function test($value)
    {
        // some validation
        return true;
    }
}

$valid = new Zend_Validate_Callback(array('MyClass', 'test'));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            Finally, if you are using <acronym class="acronym">PHP</acronym> 5.3, you may define the magic method
            <code class="methodname">__invoke()</code> in your class. If you do so, simply providing an
            instance of the class as the callback will also work:
        </p>

        <pre class="programlisting">
class MyClass
{
    public function __invoke($value)
    {
        // some validation
        return true;
    }
}

$object = new MyClass();
$valid = new Zend_Validate_Callback($object);
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.options2"></a>Adding options</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Callback</code> also allows the usage of options which
            are provided as additional arguments to the callback.
        </p>

        <p>
            Consider the following class and method definition:
        </p>

        <pre class="programlisting">
class MyClass
{
    function myMethod($value, $option)
    {
        // some validation
        return true;
    }
}
</pre>

        <p>
            There are two ways to inform the validator of additional options: pass them in the
            constructor, or pass them to the <code class="methodname">setOptions()</code> method.
        </p>

        <p>
            To pass them to the constructor, you would need to pass an array containing two keys,
            "callback" and "options":
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(array(
    'callback' =&gt; array('MyClass', 'myMethod'),
    'options'  =&gt; $option,
));

if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            Otherwise, you may pass them to the validator after instantiation:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(array('MyClass', 'myMethod'));
$valid-&gt;setOptions($option);

if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            When there are additional values given to <code class="methodname">isValid()</code> then these
            values will be added immediately after <code class="varname">$value</code>.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(array('MyClass', 'myMethod'));
$valid-&gt;setOptions($option);

if ($valid-&gt;isValid($input, $additional)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            When making the call to the callback, the value to be validated will always be passed as
            the first argument to the callback followed by all other values given to
            <code class="methodname">isValid()</code>; all other options will follow it. The amount and
            type of options which can be used is not limited.
        </p>
    </div>
</div>
        
    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.creditcard"></a>CreditCard</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_CreditCard</code> allows you to validate if a given value
        could be a credit card number.
    </p>

    <p>
        A creditcard contains several items of metadata, including a hologram, account number, logo,
        expiration date, security code and the card holder name. The algorithms for verifying the
        combination of metadata are only known to the issuing company, and should be verified with
        them for purposes of payment. However, it's often useful to know whether or not a given
        number actually falls within the ranges of possible numbers <span class="emphasis"><em>prior</em></span> to
        performing such verification, and, as such, <code class="classname">Zend_Validate_CreditCard</code>
        simply verifies that the credit card number provided is well-formed.
    </p>

    <p>
        For those cases where you have a service that can perform comprehensive verification,
        <code class="classname">Zend_Validate_CreditCard</code> also provides the ability to attach a
        service callback to trigger once the credit card number has been deemed valid; this callback
        will then be triggered, and its return value will determine overall validity.
    </p>

    <p>
        The following issuing institutes are accepted:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <p>
                <span class="emphasis"><em>American Express</em></span>
            </p>

            <p>
                <span class="emphasis"><em>China UnionPay</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Diners Club Card Blanche</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Diners Club International</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Diners Club US &amp; Canada</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Discover Card</em></span>
            </p>

            <p>
                <span class="emphasis"><em>JCB</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Laser</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Maestro</em></span>
            </p>

            <p>
                <span class="emphasis"><em>MasterCard</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Solo</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Visa</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Visa Electron</em></span>
            </p>
        </li></ul></div>

    <div class="note"><table border="0" summary="Note: Invalid institutes">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Invalid institutes</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            The institutes <span class="emphasis"><em>Bankcard</em></span> and <span class="emphasis"><em>Diners Club
                enRoute</em></span> do not exist anymore. Therefore they are treated as invalid.
        </p>

        <p>
            <span class="emphasis"><em>Switch</em></span> has been rebranded to <span class="emphasis"><em>Visa</em></span> and is
            therefore also treated as invalid.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.options"></a>Supported options for Zend_Validate_CreditCard</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_CreditCard</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">service</span></em></span>: A callback to an online
                    service which will additionally be used for the validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span>: The type of creditcard which
                    will be validated. See the below list of institutes for details.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            There are several credit card institutes which can be validated by
            <code class="classname">Zend_Validate_CreditCard</code>. Per default, all known institutes will
            be accepted. See the folowing example:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard();
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            The above example would validate against all known credit card institutes.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.institute"></a>Accepting defined credit cards</h4></div></div></div>
        

        <p>
            Sometimes it is necessary to accept only defined credit card institutes instead of all;
            e.g., when you have a webshop which accepts only Visa and American Express cards.
            <code class="classname">Zend_Validate_CreditCard</code> allows you to do exactly this by
            limiting it to exactly these institutes.
        </p>

        <p>
            To use a limitation you can either provide specific institutes at initiation, or
            afterwards by using <code class="methodname">setType()</code>. Each can take several arguments.
        </p>

        <p>
            You can provide a single institute:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard(
    Zend_Validate_CreditCard::AMERICAN_EXPRESS
);
</pre>

        <p>
            When you want to allow multiple institutes, then you can provide them as array:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard(array(
    Zend_Validate_CreditCard::AMERICAN_EXPRESS,
    Zend_Validate_CreditCard::VISA
));
</pre>

        <p>
            And as with all validators, you can also pass an associative array of options or an
            instance of <code class="classname">Zend_Config</code>. In this case you have to provide the
            institutes with the <span class="property">type</span> array key as simulated here:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard(array(
    'type' =&gt; array(Zend_Validate_CreditCard::AMERICAN_EXPRESS)
));
</pre>

        <div class="table">
<a name="zend.validate.set.creditcard.institute.table"></a><p class="title"><b>Tabla 169. Constants for credit card institutes</b></p>
<div class="table-contents">
            

            <table class="table" summary="Constants for credit card institutes" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Institute</th>
<th>Constant</th>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>American Express</em></span></td>
<td><code class="constant">AMERICAN_EXPRESS</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>China UnionPay</em></span></td>
<td><code class="constant">UNIONPAY</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Diners Club Card Blanche</em></span></td>
<td><code class="constant">DINERS_CLUB</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Diners Club International</em></span></td>
<td><code class="constant">DINERS_CLUB</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Diners Club US &amp; Canada</em></span></td>
<td><code class="constant">DINERS_CLUB_US</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Discover Card</em></span></td>
<td><code class="constant">DISCOVER</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>JCB</em></span></td>
<td><code class="constant">JCB</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Laser</em></span></td>
<td><code class="constant">LASER</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Maestro</em></span></td>
<td><code class="constant">MAESTRO</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>MasterCard</em></span></td>
<td><code class="constant">MASTERCARD</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Solo</em></span></td>
<td><code class="constant">SOLO</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Visa</em></span></td>
<td><code class="constant">VISA</code></td>
</tr>
<tr>
<td><span class="emphasis"><em>Visa Electron</em></span></td>
<td><code class="constant">VISA</code></td>
</tr>
</tbody>
</table>
        </div>
</div>
<br class="table-break">

        <p>
            You can also set or add institutes afterward instantiation by using the methods
            <code class="methodname">setType()</code>, <code class="methodname">addType()</code> and
            <code class="methodname">getType()</code>.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard();
$valid-&gt;setType(array(
    Zend_Validate_CreditCard::AMERICAN_EXPRESS,
    Zend_Validate_CreditCard::VISA
));
</pre>

        <div class="note"><table border="0" summary="Note: Default institute">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Default institute</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                When no institute is given at initiation then <code class="constant">ALL</code> will be
                used, which sets all institutes at once.
            </p>

            <p>
                In this case the usage of <code class="methodname">addType()</code> is useless because all
                institutes are already added.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.servicecheck"></a>Validation by using foreign APIs</h4></div></div></div>
        

        <p>
            As said before <code class="classname">Zend_Validate_CreditCard</code> will only validate
            the credit card number. Fortunately, some institutes provide online
            <acronym class="acronym">API</acronym>s which can validate a credit card number by using algorithms
            which are not available to the public. Most of these services are paid services.
            Therefore, this check is deactivated per default.
        </p>

        <p>
            When you have access to such an <acronym class="acronym">API</acronym>, then you can use it as an addon
            for <code class="classname">Zend_Validate_CreditCard</code> and increase the security of the
            validation.
        </p>

        <p>
            To do so, you simply need to give a callback which will be called when the generic
            validation has passed. This prevents the <acronym class="acronym">API</acronym> from being called
            for invalid numbers, which increases the performance of the application.
        </p>

        <p>
            <code class="methodname">setService()</code> sets a new service, and
            <code class="methodname">getService()</code> returns the set service. As a configuration
            option,
            you can give the array key '<span class="property">service</span>' at initiation. For details
            about possible options take a look into <a class="link" href="zend.validate.set.html#zend.validate.set.callback" title="Callback">Callback</a>.
        </p>

        <pre class="programlisting">
// Your service class
class CcService
{
    public function checkOnline($cardnumber, $types)
    {
        // some online validation
    }
}

// The validation
$service = new CcService();
$valid   = new Zend_Validate_CreditCard(Zend_Validate_CreditCard::VISA);
$valid-&gt;setService(array($service, 'checkOnline'));
</pre>

        <p>
            As you can see the callback method will be called with the creditcard number as the
            first parameter, and the accepted types as the second parameter.
        </p>
    </div>
</div>
        

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.ccnum"></a>Ccnum</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> sigue el algoritmo Luhn (mod-10
            checksum) para tarjetas de crédito. </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Nota</th>
</tr>
<tr><td align="left" valign="top">
            <p> The <code class="classname">Ccnum</code> validator has been
                deprecated in favor of the <code class="classname">CreditCard</code>
                validator. For security reasons you should use CreditCard
                instead of Ccnum. </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.date"></a>Date</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> es una fecha válida en el formato
                <code class="methodname">YYYY-MM-DD</code> (AAAA-MM-DD). Si se usa la
            opción <code class="methodname">locale</code> entonces la fecha será
            validada de acuerdo a lo establecido para ese locale. Además, si se
            establece la opción <code class="methodname">format</code> ese formato se
            utiliza para la validación. Para más detalles acerca de los
            parámetros opcionales ver en: <a class="link" href="zend.date.overview.html#zend.date.others.comparison.table" title="Tabla 46. Date Comparison Methods">Zend_Date::isDate()</a> . </p>
    </div>

    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.Db"></a>Db_RecordExists and Db_NoRecordExists</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Db_RecordExists</code> and
        <code class="classname">Zend_Validate_Db_NoRecordExists</code> provide a means to test
        whether a record exists in a given table of a database, with a given
        value.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.db.options"></a>Supported options for Zend_Validate_Db_*</h4></div></div></div>
        

        <p>
            The following options are supported for
            <code class="classname">Zend_Validate_Db_NoRecordExists</code> and
            <code class="classname">Zend_Validate_Db_RecordExists</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">adapter</span></em></span>: The database adapter which
                    will be used for the search.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">exclude</span></em></span>: Sets records which will be
                    excluded from the search.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">field</span></em></span>: The database field within this
                    table which will be searched for the record.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">schema</span></em></span>: Sets the schema which will be
                    used for the search.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">table</span></em></span>: The table which will be
                    searched for the record.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.basic-usage"></a>Basic usage</h4></div></div></div>
        

        <p>
            An example of basic usage of the validators:
        </p>

        <pre class="programlisting">
//Check that the email address exists in the database
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'emailaddress'
    )
);

if ($validator-&gt;isValid($emailaddress)) {
    // email address appears to be valid
} else {
    // email address is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            The above will test that a given email address is in the database
            table. If no record is found containing the value of
            <code class="varname">$emailaddress</code> in the specified column, then an error
            message is displayed.
        </p>

        <pre class="programlisting">
//Check that the username is not present in the database
$validator = new Zend_Validate_Db_NoRecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'username'
    )
);
if ($validator-&gt;isValid($username)) {
    // username appears to be valid
} else {
    // username is invalid; print the reason
    $messages = $validator-&gt;getMessages();
    foreach ($messages as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            The above will test that a given username is not in the database
            table. If a record is found containing the value of
            <code class="varname">$username</code> in the specified column, then an error
            message is displayed.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.excluding-records"></a>Excluding records</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Db_RecordExists</code> and
            <code class="classname">Zend_Validate_Db_NoRecordExists</code> also provide a means
            to test the database, excluding a part of the table, either by
            providing a where clause as a string, or an array with the keys
            "field" and "value".
        </p>

        <p>
            When providing an array for the exclude clause, the <span class="emphasis"><em>!=</em></span>
            operator is used, so you can check the rest of a table for a value
            before altering a record (for example on a user profile form)
        </p>

        <pre class="programlisting">
//Check no other users have the username
$user_id   = $user-&gt;getId();
$validator = new Zend_Validate_Db_NoRecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'username',
        'exclude' =&gt; array(
            'field' =&gt; 'id',
            'value' =&gt; $user_id
        )
    )
);

if ($validator-&gt;isValid($username)) {
    // username appears to be valid
} else {
    // username is invalid; print the reason
    $messages = $validator-&gt;getMessages();
    foreach ($messages as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            The above example will check the table to ensure no records other
            than the one where <span class="command"><strong>id = $user_id</strong></span> contains the value
            $username.
        </p>

        <p>
            You can also provide a string to the exclude clause so you can use
            an operator other than <span class="emphasis"><em>!=</em></span>. This can be useful for
            testing against composite keys.
        </p>

        <pre class="programlisting">
$email     = 'user@example.com';
$clause    = $db-&gt;quoteInto('email = ?', $email);
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table'   =&gt; 'users',
        'field'   =&gt; 'username',
        'exclude' =&gt; $clause
    )
);

if ($validator-&gt;isValid($username)) {
    // username appears to be valid
} else {
    // username is invalid; print the reason
    $messages = $validator-&gt;getMessages();
    foreach ($messages as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            The above example will check the 'users' table
            to ensure that only a record with both the username
            <code class="varname">$username</code> and with the email
            <code class="varname">$email</code> is valid.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.database-adapters"></a>Database Adapters</h4></div></div></div>
        

        <p>
            You can also specify an adapter. This will allow you to work with
            applications using multiple database adapters, or where you have not
            set a default adapter. As in the example below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'id',
        'adapter' =&gt; $dbAdapter
    )
);
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.database-schemas"></a>Database Schemas</h4></div></div></div>
        

        <p>
            You can specify a schema within your database for adapters such as
            PostgreSQL and DB/2 by simply supplying an array with
            <span class="property">table</span> and <span class="property">schema</span> keys. As in the example
            below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table'  =&gt; 'users',
        'schema' =&gt; 'my',
        'field'  =&gt; 'id'
    )
);
</pre>
    </div>
</div>
        
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.digits"></a>Digits</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> contiene solamente dígitos. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.email_address"></a>Dirección de Email</h3></div></div></div>

    

    <p>
        <code class="classname">Zend_Validate_EmailAddress</code> Le permite validar una
        dirección de email. El validador primero divide la dirección de email en
        la parte local @ nombre de host e intenta igualar a estos contra
        especificaciones conocidas para direcciones y nombres de host para el
        correo electrónico. </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.basic"></a>Utilización básica</h4></div></div></div>
        

        <p> Un ejemplo básico de uso se ve a continuación: </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
if ($validator-&gt;isValid($email)) {
    // El email parece ser válido
} else {
    // El email es inválido; muestre las razones
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

        <p> Esto coincide con el correo electrónico <code class="varname">$email</code>
            y si fracasa, alimenta <code class="code">$validator-&gt;getMessages()</code> con
            mensajes de error útiles. </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.options"></a>&gt;Partes locales complejas</h4></div></div></div>

        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> supports several
            options which can either be set at initiation, by giving an array
            with the related options, or afterwards, by using
                <code class="methodname">setOptions()</code> . The following options
            are supported: </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>allow</em></span> : Defines which type of domain
                    names are accepted. This option is used in conjunction with
                    the hostname option to set the hostname validator. For more
                    informations about possible values of this option, look at
                        <a class="link" href="zend.validate.set.html#zend.validate.set.hostname" title="Hostname (Nombre de Host)">Hostname</a> and possible <code class="constant">ALLOW</code>
                    * constants. This option defaults to
                        <code class="constant">ALLOW_DNS</code> . </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>hostname</em></span> : Sets the hostname validator
                    with which the domain part of the email address will be
                    validated. </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>mx</em></span> : Defines if the MX records from the
                    server should be detected. If this option is defined to
                        <code class="constant">TRUE</code> then the MX records are used
                    to verify if the server accepts emails. This option defaults
                    to <code class="constant">FALSE</code> . </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>deep</em></span> : Defines if the servers MX
                    records should be verified by a deep check. When this option
                    is set to <code class="constant">TRUE</code> then additionally to MX
                    records also the A, A6 and <code class="constant">AAAA</code> records
                    are used to verify if the server accepts emails. This option
                    defaults to <code class="constant">FALSE</code> . </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>domain</em></span> : Defines if the domain part
                    should be checked. When this option is set to
                        <code class="constant">FALSE</code> , then only the local part of
                    the email address will be checked. In this case the hostname
                    validator will not be called. This option defaults to
                        <code class="constant">TRUE</code> . </p>
            </li>
</ul></div>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
$validator-&gt;setOptions(array('domain' =&gt; false));
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.complexlocal"></a>Complex local parts</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> se comparará con
            cualquier dirección de correo válida de acuardo a RFC2822. Por
            ejemplo, correos electrónicos válidos incluyen
                <code class="code">bob@domain.com</code> , <code class="code">bob+jones@domain.us</code> ,
                <code class="code">"bob@jones"@domain.com</code> y <code class="code">"bob
                jones"@domain.com</code>
        </p>

        <p> Algunos formatos obsoletos de email actualmente no validan (por
            ejemplo los retornos de carro o "\" un caracter en una dirección de
            correo electrónico). </p>

    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.purelocal"></a>Validating only the local part</h4></div></div></div>
        

        <p> If you need <code class="classname">Zend_Validate_EmailAddress</code> to
            check only the local part of an email address, and want to disable
            validation of the hostname, you can set the
                <span class="property">domain</span> option to <code class="constant">FALSE</code>
            . This forces <code class="classname">Zend_Validate_EmailAddress</code> not
            to validate the hostname part of the email address. </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
$validator-&gt;setOptions(array('domain' =&gt; FALSE));
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.hostnametype"></a>Validating different types of hostnames</h4></div></div></div>
        

        <p> La parte nombre de host de una dirección de correo es validado
            contra <a class="link" href="zend.validate.set.html#zend.validate.set.hostname" title="Hostname (Nombre de Host)">
                <code class="classname">Zend_Validate_Hostname</code>
            </a> . Por defecto sólo son aceptados nombres de host DNS de la
            forma <code class="methodname">domain.com</code> , aunque si lo desea
            también puede aceptar direcciones IP y nombres de host locales. </p>

        <p> Para ello necesita instanciar a
                <code class="classname">Zend_Validate_EmailAddress</code> pasando un
            parámetro para indicar el tipo de nombres de host que quiere
            aceptar. Más detalles están incluidos en
                <code class="classname">Zend_Validate_EmailAddress</code> , aunque abajo
            hay un ejemplo de cómo aceptar tanto nombres de host DNS y locales: </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress(
                    Zend_Validate_Hostname::ALLOW_DNS |
                    Zend_Validate_Hostname::ALLOW_LOCAL);
if ($validator-&gt;isValid($email)) {
    // email parece ser válido
} else {
    // email es inválido; muestre las razones
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

    </div>
    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.checkacceptance"></a>Verificar si el nombre de host realmente acepta email</h4></div></div></div>

        

        <p> Sólo porque una dirección de correo electrónico está en el
            formato correcto, no necesariamente significa que esa dirección de
            correo electrónico existe realmente. Para ayudar a resolver este
            problema, puede usar la validación MX para comprobar si existe una
            entrada MX (email) en el registro DNS para correo electrónico en ese
            nombre de host. Esto le dice que el nombre de host acepta email,
            pero no le dice si la dirección de correo electrónico exacta es
            válida en si misma. </p>

        <p> La comprobación MX no está activada por defecto y en este momento
            es soportada sólo por plataformas UNIX. Para habilitar el control MX
            puede pasar un segundo parámetro al constructor
                <code class="classname">Zend_Validate_EmailAddress</code> . </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress(
    array(
        'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
        'mx'    =&gt; true
    )
);
</pre>

        <div class="note"><table border="0" summary="Note: MX Check under Windows">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">MX Check under Windows</th>
</tr>
<tr><td align="left" valign="top">
            

            <p> Within Windows environments MX checking is only available
                when <acronym class="acronym">PHP</acronym> 5.3 or above is used. Below
                    <acronym class="acronym">PHP</acronym> 5.3 MX checking will not be used even
                if it's activated within the options. </p>
        </td></tr>
</table></div>

        <p> Alternativamente, para activar o desactivar la validación MX
            puede pasar <code class="constant">TRUE</code> o <code class="constant">FALSE</code> a
                <code class="methodname">$validator-&gt;setValidateMx()</code> . </p>

        <p> Al habilitarlo, se usarán las funciones de red para comprobar la
            presencia de un registro MX en el nombre de host de la dirección de
            correo electrónico que desea validar. Tenga en cuenta esto
            probablemente hará más lento su script. </p>

        <p> Sometimes validation for MX records returns false, even if emails
            are accepted. The reason behind this behaviour is, that servers can
            accept emails even if they do not provide a MX record. In this case
            they can provide A, A6 or <code class="constant">AAAA</code> records. To
            allow <code class="classname">Zend_Validate_EmailAddress</code> to check
            also for these other records, you need to set deep MX validation.
            This can be done at initiation by setting the
                <span class="property">deep</span> option or by using
                <code class="methodname">setOptions()</code> . </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress(
    array(
        'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
        'mx'    =&gt; true,
        'deep'  =&gt; true
    )
);
</pre>

        <div class="warning"><table border="0" summary="Warning: Performance warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Aviso]" src="images/warning.png"></td>
<th align="left">Performance warning</th>
</tr>
<tr><td align="left" valign="top">
            

            <p> You should be aware that enabling MX check will slow down you
                script because of the used network functions. Enabling deep
                check will slow down your script even more as it searches the
                given server for 3 additional types. </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: Disallowed IP addresses">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Disallowed IP addresses</th>
</tr>
<tr><td align="left" valign="top">
            

            <p> You should note that MX validation is only accepted for
                external servers. When deep MX validation is enabled, then local
                IP addresses like <span class="command"><strong>192.168.*</strong></span> or
                    <span class="command"><strong>169.254.*</strong></span> are not accepted. </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.validateidn"></a>Validating International Domains Names</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> también comparará
            caracteres internationales que existen en algunos dominios. Esto se
            conoce como soporte de International Domain Name (IDN). Está
            activado por defecto, aunque puede deshabilitarlo internamente
            cambiando el ajuste a través del objeto
                <code class="classname">Zend_Validate_Hostname</code> que existe en
                <code class="classname">Zend_Validate_EmailAddress</code> . </p>

        <pre class="programlisting">
$validator-&gt;getHostnameValidator()-&gt;setValidateIdn(false);
</pre>

        <p> Sobre el uso de <code class="methodname">setValidateIdn()</code>
            encontrará más información en la documentación de
                <code class="classname">Zend_Validate_Hostname</code> . </p>

        <p> Tenga en cuenta que los IDNs se validarán solo si usted permite
            que nombres de host DNS sean validados. </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.validatetld"></a>Validación de dominios de nivel superior</h4></div></div></div>
        

        <p> Por defecto, un nombre de host se cotejará con una lista conocida
            de TLDs. Está activado por defecto, aunque puede deshabilitarlo
            cambiando el ajuste a través del objeto interno
                <code class="classname">Zend_Validate_Hostname</code> que existe en
                <code class="classname">Zend_Validate_EmailAddress</code> . </p>

        <pre class="programlisting">
$validator-&gt;getHostnameValidator()-&gt;setValidateTld(false);
</pre>

        <p> Encontrará más información sobre el uso de
                <code class="methodname">setValidateTld()</code> en la documentación de
                <code class="classname">Zend_Validate_Hostname</code> . </p>

        <p> Tenga en cuenta que los TLDs se validarán solo si usted permite
            que nombres de host DNS sean validados. </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.setmessage"></a>Setting messages</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> makes also use of
                <code class="classname">Zend_Validate_Hostname</code> to check the
            hostname part of a given email address. As with Zend Framework 1.10
            you can simply set messages for
                <code class="classname">Zend_Validate_Hostname</code> from within
                <code class="classname">Zend_Validate_EmailAddress</code> . </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
$validator-&gt;setMessages(
    array(
        Zend_Validate_Hostname::UNKNOWN_TLD =&gt; 'I don't know the TLD you gave'
    )
);
</pre>

        <p> Before Zend Framework 1.10 you had to attach the messages to your
            own <code class="classname">Zend_Validate_Hostname</code> , and then set
            this validator within
                <code class="classname">Zend_Validate_EmailAddress</code> to get your
            own messages returned. </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.float"></a>Float</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$value</code> es un valor de punto flotante. Desde
            Zend Framework 1.8 toma en cuenta la localizacion actual del
            navegador, las variables o el uso. Puede usar get/setLocale para
            cambiar la configuracion regional o crear una instancia para este
            validador </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.greater_than"></a>GreaterThan</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> es mayor al límite mínimo. </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.hex"></a>Hex</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> contiene caracteres hexadecimales (0-9
            y A-F). </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.hostname"></a>Hostname (Nombre de Host)</h3></div></div></div>

    

    <p>
        <code class="classname">Zend_Validate_Hostname</code> le permite validar un
        nombre de host contra una serie de especificaciones conocidas. Es
        posible comprobar por tres diferentes tipos de nombres: el DNS Hostname
        (domain.com por ejemplo), dirección IP (es decir 1.2.3.4), y nombres de
        host locales (localhost, por ejemplo). Por defecto sólo se comprobarán
        nombres de host DNS. </p>

    <p>
        <span class="emphasis"><em>Uso básico</em></span>
    </p>

    <p> El siguiente es un ejemplo de uso básico: </p>
<pre class="programlisting">
$validator = new Zend_Validate_Hostname();
if ($validator-&gt;isValid($hostname)) {
    // hostname parece ser válido
} else {
    // hostname es inválido; muestre las razones
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>
<p> Comprobará el nombre de host <code class="varname">$hostname</code> y
        si fracasa alimentará a <code class="methodname">getMessages()</code> con
        mensajes de error. </p>

    <p>
        <span class="emphasis"><em>Validar diferentes tipos de nombres de host</em></span>
    </p>

    <p> También se puede encontrar coincidencias de direcciones IP, nombres
        de host locales, o una combinación de todos los tipos permitidos. Esto
        puede hacerse pasando un parámetro a
            <code class="classname">Zend_Validate_Hostname</code> cuando lo instancia.
        El parámetro debe ser un entero que determina qué tipos de nombres de
        host están permitidos. Se recomienda el uso de las constantes de
            <code class="classname">Zend_Validate_Hostname</code> para hacerlo. </p>

    <p> Las constantes de <code class="classname">Zend_Validate_Hostname</code> son:
            <code class="constant">ALLOW_DNS</code> para permitir sólo nombres de host
        DNS, <code class="constant">ALLOW_IP</code> para permitir direcciones IP,
            <code class="constant">ALLOW_LOCAL</code> para permitir nombres de host de la
        red local, y <code class="constant">ALLOW_ALL</code> para permitir todos estos
        tres tipos. Para comprobar que direcciones IP puede utilizar, vea el
        siguiente ejemplo: </p>
<pre class="programlisting">
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_IP);
if ($validator-&gt;isValid($hostname)) {
    // hostname parece ser válido
} else {
    // hostname es inválido; muestre las razones
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>
<p>
    </p>

    <p> Usando <code class="constant">ALLOW_ALL</code> para aceptar todos los tipos de
        nombres de host, también puede combinar estos tipos para realizar
        combinaciones. Por ejemplo, para aceptar nombres de host DNS y locales,
        instancie el objeto <code class="classname">Zend_Validate_Hostname</code> como: </p>
<pre class="programlisting">
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_DNS |
                                        Zend_Validate_Hostname::ALLOW_IP);
</pre>
<p>
    </p>

    <p>
        <span class="emphasis"><em>Validación de Nombres de Dominio Internacionales</em></span>
    </p>

    <p> Algunos (ccTLD), es decir países "Country Code Top Level Domains" ,
        como 'de' (Alemania), aceptan caracteres internacionales como nombres de
        dominio. Estos son conocidos como Nombres de Dominio Internacionales
        (IDN, por sus siglas en inglés). Se puede buscar una coincidencia de
        estos dominios con <code class="classname">Zend_Validate_Hostname</code> , a
        través de caracteres extendidos que se utilizan en el proceso de
        validación. </p>

    <p> Until now more than 50 ccTLDs support IDN domains. </p>

    <p> Cotejar dominios IDN es tan simple como usar el validador estándar
        Hostname, ya que este viene habilitado por defecto. Si desea desactivar
        la validación IDN, se puede hacer ya sea pasando un parámetro al
        constructor <code class="classname">Zend_Validate_Hostname</code> o a través del
        método <code class="methodname">setValidateIdn()</code> . </p>

    <p>Puede deshabilitar la validación IDN, pasando un segundo parámetro al
        constructor Zend_Validate_Hostname de la siguiente manera. </p>

    <pre class="programlisting">
$validator =
    new Zend_Validate_Hostname(
        array(
            'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
            'idn'   =&gt; false
        )
    );
</pre>

    <p> Alternativamente puede pasar <code class="constant">TRUE</code> o
            <code class="constant">FALSE</code> a
            <code class="methodname">setValidateIdn()</code> para activar o desactivar
        la validación IDN. Si está tratando de cotejar un nombre de host IDN que
        actualmente no está soportado, es probable que falle la validación si
        tiene caracteres internacionales en el nombre de host. Cuando un archivo
        ccTLD no existe en Zend/Validate/Hostname, especificando los caracteres
        adicionales se puede realizar una validación normal. </p>

    <p>Tenga en cuenta que una validación IDN solo se realizará si tiene
        habilidada la validación para nombres de host DNS.</p>

    <p>
        <span class="emphasis"><em>Validacuión de dominios de nivel superior</em></span>
    </p>

    <p>Por defecto un nombre de host se cotejará con una lista de TLDs
        conocidos. Si esta funcionalidad no es necesaria, puede ser desactivada
        en la misma forma que deshabilita el soporte IDN. Puede deshabilitar la
        validación TLD pasando un tercer parámetro al constructor
        Zend_Validate_Hostname. En el siguiente ejemplo estamos dando respaldo a
        la validación IDN a través del segundo parámetro. </p>
    <pre class="programlisting">
$validator =
    new Zend_Validate_Hostname(
        array(
            'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
            'idn'   =&gt; true,
            'tld'   =&gt; false
        )
    );
</pre>

    <p> Alternativamente puede pasar <code class="constant">TRUE</code> o
            <code class="constant">FALSE</code> a
            <code class="methodname">setValidateTld()</code> para activar o desactivar
        la validación TLD. </p>

    <p>Tenga en cuenta que una validación de TLDs solo se realizará si tiene
        habilidada la validación para nombres de host DNS.</p>

</div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.iban"></a>Iban</h3></div></div></div>
        
        <p> Returns <code class="constant">TRUE</code> if and only if
                <code class="varname">$value</code> contains a valid IBAN (International
            Bank Account Number). IBAN numbers are validated against the country
            where they are used and by a checksum. </p>

        <p>There are two ways to validate IBAN numbers. As first way you can
            give a locale which represents a country. Any given IBAN number will
            then be validated against this country.</p>
        <pre class="programlisting">
$validator = new Zend_Validate_Iban('de_AT');
$iban = 'AT611904300234573201';
if ($validator-&gt;isValid($iban)) {
    // IBAN appears to be valid
} else {
    // IBAN is invalid
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>
        <p>This should be done when you want to validate IBAN numbers for a
            single countries. The simpler way of validation is not to give a
            locale like shown in the next example.</p>
        <pre class="programlisting">
$validator = new Zend_Validate_Iban();
$iban = 'AT611904300234573201';
if ($validator-&gt;isValid($iban)) {
    // IBAN appears to be valid
} else {
    // IBAN is invalid
}
</pre>
        <p>But this shows one big problem: When you have to accept only IBAN
            numbers from one single country, for example france, then IBAN
            numbers from other countries would also be valid. Therefor just
            remember: When you have to validate a IBAN number against a defined
            country you should give the locale. And when you accept all IBAN
            numbers regardless of any country omit the locale for
            simplicity.</p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.in_array"></a>InArray</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> se encuentra en un array, y si la
            opción es estricta entonces también verificará el tipo de dato de
                <code class="varname">$valor</code> . </p>
    </div>

    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.identical"></a>Identical</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Identical</code> allows you to validate if a given value is
        identical with an set haystack.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.options"></a>Supported options for Zend_Validate_Identical</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Identical</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">strict</span></em></span>: Defines if the validation
                    should be done strict. The default value is <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">token</span></em></span>: Sets the token with which the
                    input will be validated against.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            To validate if two values are identical you need to set the origin value as haystack.
            See the following example which validates two strings.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical('origin');
if ($valid-&gt;isValid($value) {
    return true;
}
</pre>

        <p>
            The validation will only then return <code class="constant">TRUE</code> when both values are
            100% identical. In our example, when <code class="varname">$value</code> is 'origin'.
        </p>

        <p>
            You can set the wished token also afterwards by using the method
            <code class="methodname">setToken()</code> and <code class="methodname">getToken()</code> to get
            the actual set token.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.types"></a>Identical objects</h4></div></div></div>
        

        <p>
            Of course <code class="classname">Zend_Validate_Identical</code> can not only validate strings,
            but also any other variable type like Boolean, Integer, Float, Array or even Objects.
            As already noted Haystack and Value must be identical.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(123);
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <div class="note"><table border="0" summary="Note: Type comparison">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Type comparison</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                You should be aware that also the type of a variable is used for validation.
                This means that the string <span class="emphasis"><em>'3'</em></span> is not identical with the
                integer <span class="emphasis"><em>3</em></span>. When you want such a non strict validation you
                must set the <span class="property">strict</span> option.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.formelements"></a>Form elements</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Identical</code> supports also the comparison of form
            elements. This can be done by using the element's name as <span class="property">token</span>.
            See the following example:
        </p>

        <pre class="programlisting">
$form-&gt;addElement('password', 'elementOne');
$form-&gt;addElement('password', 'elementTwo', array(
    'validators' =&gt; array(
        array('identical', false, array('token' =&gt; 'elementOne'))
    )
));
</pre>

        <p>
            By using the elements name from the first element as <span class="property">token</span> for the
            second element, the validator validates if the second element is equal with the first
            element. In the case your user does not enter two identical values, you will get an
            validation error.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.strict"></a>Strict validation</h4></div></div></div>
        

        <p>
            As mentioned before <code class="classname">Zend_Validate_Identical</code> validates tokens
            strict. You can change this behaviour by using the <span class="property">strict</span> option.
            The default value for this property is <code class="constant">TRUE</code>.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(array('token' =&gt; 123, 'strict' =&gt; FALSE));
$input = '123';
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            The difference to the previous example is that the validation returns in this case
            <code class="constant">TRUE</code>, even if you compare a integer with string value as long
            as the content is identical but not the type.
        </p>

        <p>
            For convinience you can also use <code class="methodname">setStrict()</code> and
            <code class="methodname">getStrict()</code>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.configuration"></a>Configuration</h4></div></div></div>
        

        <p>
            As all other validators also <code class="classname">Zend_Validate_Identical</code> supports
            the usage of configuration settings as input parameter. This means that you can
            configure this validator with an <code class="classname">Zend_Config</code> object.
        </p>

        <p>
            But this adds one case which you have to be aware. When you are using an array as
            haystack then you should wrap it within an '<span class="property">token</span>' key when
            it could contain only one element.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(array('token' =&gt; 123));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>

        <p>
            The above example validates the integer 123. The reason for this special case is, that
            you can configure the token which has to be used by giving the
            '<span class="property">token</span>' key.
        </p>

        <p>
            So, when your haystack contains one element and this element is named
            '<span class="property">token</span>' then you have to wrap it like shown in the example below.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(array('token' =&gt; array('token' =&gt; 123)));
if ($valid-&gt;isValid($input)) {
    // input appears to be valid
} else {
    // input is invalid
}
</pre>
    </div>
</div>
        

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.int"></a>Int</h3></div></div></div>
        
        <p> Returns <code class="constant">TRUE</code> if and only if
                <code class="varname">$value</code> is a valid integer. Since Zend
            Framework 1.8 this validator takes into account the actual locale
            from browser, environment or application wide set locale. You can of
            course use the get/setLocale accessors to change the used locale or
            give it while creating a instance of this validator. </p>
    </div>

    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.ip"></a>Ip</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Ip</code> allows you to validate if a given value is an IP
        address. It supports the IPv4 and also the IPv6 standard.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.ip.options"></a>Supported options for Zend_Validate_Ip</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Ip</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowipv4</span></em></span>: Defines if the validator
                    allows IPv4 adresses. This option defaults to <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowipv6</span></em></span>: Defines if the validator
                    allows IPv6 adresses. This option defaults to <code class="constant">TRUE</code>.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.ip.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            A basic example of usage is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Ip();
if ($validator-&gt;isValid($ip)) {
    // ip appears to be valid
} else {
    // ip is invalid; print the reasons
}
</pre>

        <div class="note"><table border="0" summary="Note: Invalid IP addresses">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Invalid IP addresses</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Keep in mind that <code class="classname">Zend_Validate_Ip</code> only validates IP
                addresses. Addresses like '<code class="filename">mydomain.com</code>' or
                '<code class="filename">192.168.50.1/index.html</code>' are no valid
                IP addresses. They are either hostnames or valid <acronym class="acronym">URL</acronym>s but not IP
                addresses.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: IPv6 validation">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">IPv6 validation</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                <code class="classname">Zend_Validate_Ip</code> validates IPv6 addresses with regex. The
                reason is that the filters and methods from <acronym class="acronym">PHP</acronym> itself don't
                follow the <acronym class="acronym">RFC</acronym>. Many other available classes also don't follow
                it.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.ip.singletype"></a>Validate IPv4 or IPV6 alone</h4></div></div></div>
        

        <p>
            Sometimes it's useful to validate only one of the supported formats. For example when
            your network only supports IPv4. In this case it would be useless to allow IPv6 within
            this validator.
        </p>

        <p>
            To limit <code class="classname">Zend_Validate_Ip</code> to one protocol you can set the options
            <span class="property">allowipv4</span> or <span class="property">allowipv6</span> to
            <code class="constant">FALSE</code>. You can do this either by giving the option to the
            constructor or by using <code class="methodname">setOptions()</code> afterwards.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Ip(array('allowipv6' =&gt; false);
if ($validator-&gt;isValid($ip)) {
    // ip appears to be valid ipv4 address
} else {
    // ip is no ipv4 address
}
</pre>

        <div class="note"><table border="0" summary="Note: Default behaviour">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Default behaviour</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                The default behaviour which <code class="classname">Zend_Validate_Ip</code> follows is to
                allow both standards.
            </p>
        </td></tr>
</table></div>
    </div>
</div>
        
    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.isbn"></a>Isbn</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Isbn</code> allows you to validate an
        <acronym class="acronym">ISBN-10</acronym> or <acronym class="acronym">ISBN-13</acronym> value.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.options"></a>Supported options for Zend_Validate_Isbn</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_Isbn</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">separator</span></em></span>: Defines the allowed
                    separator for the <acronym class="acronym">ISBN</acronym> number. It defaults to an empty
                    string.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span>: Defines the allowed type of
                    <acronym class="acronym">ISBN</acronym> numbers. It defaults to
                    <code class="constant">Zend_Validate_Isbn::AUTO</code>. For details take a look at
                    <a class="link" href="zend.validate.set.html#zend.validate.set.isbn.type-explicit" title="Setting an explicit ISBN validation type">this section</a>.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.basic"></a>Basic usage</h4></div></div></div>
        

        <p>
            A basic example of usage is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Isbn();
if ($validator-&gt;isValid($isbn)) {
    // isbn is valid
} else {
    // isbn is not valid
}
</pre>

        <p>
            This will validate any <acronym class="acronym">ISBN-10</acronym> and <acronym class="acronym">ISBN-13</acronym> without
            separator.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.type-explicit"></a>Setting an explicit ISBN validation type</h4></div></div></div>
        

        <p>
            An example of an <acronym class="acronym">ISBN</acronym> type restriction is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Isbn();
$validator-&gt;setType(Zend_Validate_Isbn::ISBN13);
// OR
$validator = new Zend_Validate_Isbn(array(
    'type' =&gt; Zend_Validate_Isbn::ISBN13,
));

if ($validator-&gt;isValid($isbn)) {
    // this is a valid ISBN-13 value
} else {
    // this is an invalid ISBN-13 value
}
</pre>

        <p>
            The above will validate only <acronym class="acronym">ISBN-13</acronym> values.
        </p>

        <p>
            Valid types include:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="constant">Zend_Validate_Isbn::AUTO</code> (default)</p>
            </li>
<li class="listitem">
                <p><code class="constant">Zend_Validate_Isbn::ISBN10</code></p>
            </li>
<li class="listitem">
                <p><code class="constant">Zend_Validate_Isbn::ISBN13</code></p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.separator"></a>Specifying a separator restriction</h4></div></div></div>
        

        <p>
            An example of separator restriction is below:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Isbn();
$validator-&gt;setSeparator('-');
// OR
$validator = new Zend_Validate_Isbn(array(
    'separator' =&gt; '-',
));

if ($validator-&gt;isValid($isbn)) {
    // this is a valid ISBN with separator
} else {
    // this is an invalid ISBN with separator
}
</pre>

        <div class="note"><table border="0" summary="Note: Values without separator">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Values without separator</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                This will return <code class="constant">FALSE</code> if <code class="varname">$isbn</code> doesn't
                contain a separator <span class="emphasis"><em>or</em></span> if it's an invalid
                <acronym class="acronym">ISBN</acronym> value.
            </p>
        </td></tr>
</table></div>

        <p>
            Valid separators include:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><p>"" (empty) (default)</p></li>
<li class="listitem"><p>"-" (hyphen)</p></li>
<li class="listitem"><p>" " (space)</p></li>
</ul></div>
    </div>
</div>
        

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.less_than"></a>LessThan</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> es menor al límite máximo. </p>
    </div>

    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.notempty"></a>NotEmpty</h3></div></div></div>
    

    <p>
        This validator allows you to validate if a given value is not empty. This is often useful
        when working with form elements or other user input, where you can use it to ensure required
        elements have values associated with them.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.notempty.options"></a>Supported options for Zend_Validate_NotEmpty</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_NotEmpty</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span>: Sets the type of validation
                    which will be processed. For details take a look into <a class="link" href="zend.validate.set.html#zend.validate.set.notempty.types" title="Changing behaviour for Zend_Validate_NotEmpty">this section</a>.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.notempty.default"></a>Default behaviour for Zend_Validate_NotEmpty</h4></div></div></div>
        

        <p>
            By default, this validator works differently than you would expect when you've worked
            with <acronym class="acronym">PHP</acronym>'s <code class="methodname">empty()</code> function. In
            particular, this validator will evaluate both the integer <span class="emphasis"><em>0</em></span> and
            string '<span class="emphasis"><em>0</em></span>' as empty.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_NotEmpty();
$value  = '';
$result = $valid-&gt;isValid($value);
// returns false
</pre>

        <div class="note"><table border="0" summary="Note: Default behaviour differs from PHP">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Default behaviour differs from PHP</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Without providing configuration, <code class="classname">Zend_Validate_NotEmpty</code>'s
                behaviour differs from <acronym class="acronym">PHP</acronym>.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.notempty.types"></a>Changing behaviour for Zend_Validate_NotEmpty</h4></div></div></div>
        

        <p>
            Some projects have differing opinions of what is considered an "empty" value: a string
            with only whitespace might be considered empty, or <span class="emphasis"><em>0</em></span> may be
            considered non-empty (particularly for boolean sequences). To accomodate differing
            needs, <code class="classname">Zend_Validate_NotEmpty</code> allows you to configure which types
            should be validated as empty and which not.
        </p>

        <p>
            The following types can be handled:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>boolean</em></span>: Returns <code class="constant">FALSE</code> when the
                    boolean value is <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>integer</em></span>: Returns <code class="constant">FALSE</code> when an integer
                    <span class="emphasis"><em>0</em></span> value is given. Per default this validation is not
                    activated and returns <code class="constant">TRUE</code> on any integer values.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>float</em></span>: Returns <code class="constant">FALSE</code> when an float
                    <span class="emphasis"><em>0.0</em></span> value is given. Per default this validation is not
                    activated and returns <code class="constant">TRUE</code> on any float values.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>string</em></span>: Returns <code class="constant">FALSE</code> when an empty
                    string <span class="emphasis"><em>''</em></span> is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>zero</em></span>: Returns <code class="constant">FALSE</code> when the single
                    character zero (<span class="emphasis"><em>'0'</em></span>) is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>empty_array</em></span>: Returns <code class="constant">FALSE</code> when an
                    empty <span class="emphasis"><em>array</em></span> is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>null</em></span>: Returns <code class="constant">FALSE</code> when an
                    <code class="constant">NULL</code> value is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>php</em></span>: Returns <code class="constant">FALSE</code> on the same reasons
                    where <acronym class="acronym">PHP</acronym> method <code class="methodname">empty()</code> would
                    return <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>space</em></span>: Returns <code class="constant">FALSE</code> when an string
                    is given which contains only whitespaces.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>object</em></span>: Returns <code class="constant">TRUE</code>.
                    <code class="constant">FALSE</code> will be returned when <span class="property">object</span> is
                    not allowed but an object is given.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>object_string</em></span>: Returns <code class="constant">FALSE</code> when an
                    object is given and it's <code class="methodname">__toString()</code> method returns an
                   empty string.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>object_count</em></span>: Returns <code class="constant">FALSE</code> when an
                    object is given, it has an <code class="classname">Countable</code> interface and it's
                    count is 0.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>all</em></span>: Returns <code class="constant">FALSE</code> on all above types.
                </p>
            </li>
</ul></div>

        <p>
            All other given values will return <code class="constant">TRUE</code> per default.
        </p>

        <p>
            There are several ways to select which of the above types are validated. You can give
            one or multiple types and add them, you can give an array, you can use constants, or you
            can give a textual string. See the following examples:
        </p>

        <pre class="programlisting">
// Returns false on 0
$validator = new Zend_Validate_NotEmpty(Zend_Validate_NotEmpty::INTEGER);

// Returns false on 0 or '0'
$validator = new Zend_Validate_NotEmpty(
    Zend_Validate_NotEmpty::INTEGER + Zend_NotEmpty::ZERO
);

// Returns false on 0 or '0'
$validator = new Zend_Validate_NotEmpty(array(
    Zend_Validate_NotEmpty::INTEGER,
    Zend_Validate_NotEmpty::ZERO
));

// Returns false on 0 or '0'
$validator = new Zend_Validate_NotEmpty(array(
    'integer',
    'zero',
));
</pre>

        <p>
            You can also provide an instance of <code class="classname">Zend_Config</code> to set the
            desired types. To set types after instantiation, use the
            <code class="methodname">setType()</code> method.
        </p>
    </div>
</div>
        

    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.post_code"></a>PostCode</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_PostCode</code> allows you to determine if a given value is a
        valid postal code. Postal codes are specific to cities, and in some locales termed
        <acronym class="acronym">ZIP</acronym> codes.
    </p>

    <p>
        <code class="classname">Zend_Validate_PostCode</code> knows more than 160 different postal code
        formates. To select the correct format there are 2 ways. You can either use a fully
        qualified locale or you can set your own format manually.
    </p>

    <p>
        Using a locale is more convenient as Zend Framework already knows the appropriate postal
        code format for each locale; however, you need to use the fully qualified locale (one
        containing a region specifier) to do so. For instance, the locale "de" is a locale but
        could not be used with <code class="classname">Zend_Validate_PostCode</code> as it does not include
        the region; "de_AT", however, would be a valid locale, as it specifies the region code
        ("AT", for Austria).
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_PostCode('de_AT');
</pre>

    <p>
        When you don't set a locale yourself, then <code class="classname">Zend_Validate_PostCode</code>
        will use the application wide set locale, or, when there is none, the locale returned by
        <code class="classname">Zend_Locale</code>.
    </p>

    <pre class="programlisting">
// application wide locale within your bootstrap
$locale = new Zend_Locale('de_AT');
Zend_Registry::set('Zend_Locale', $locale);

$validator = new Zend_Validate_PostCode();
</pre>

    <p>
        You can also change the locale afterwards by calling <code class="methodname">setLocale()</code>.
        And of course you can get the actual used locale by calling
        <code class="methodname">getLocale()</code>.
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_PostCode('de_AT');
$validator-&gt;setLocale('en_GB');
</pre>

    <p>
        Postal code formats themself are simply regular expression strings. When the international
        postal code format, which is used by setting the locale, does not fit your needs, then you
        can also manually set a format by calling <code class="methodname">setFormat()</code>.
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_PostCode('de_AT');
$validator-&gt;setFormat('AT-\d{5}');
</pre>

    <div class="note"><table border="0" summary="Note: Conventions for self defined formats">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td>
<th align="left">Conventions for self defined formats</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            When using self defined formats you should omit the starting (<span class="command"><strong>'/^'</strong></span>)
            and ending tags (<span class="command"><strong>'$/'</strong></span>). They are attached automatically.
        </p>

        <p>
            You should also be aware that postcode values are always be validated in a strict way.
            This means that they have to be written standalone without additional characters when
            they are not covered by the format.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.post_code.constructor"></a>Constructor options</h4></div></div></div>
        

        <p>
            At it's most basic, you may pass either a <code class="classname">Zend_Locale</code> object or a
            string representing a fully qualified locale to the constructor of
            <code class="classname">Zend_Validate_PostCode</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_PostCode('de_AT');
$validator = new Zend_Validate_PostCode($locale);
</pre>

        <p>
            Additionally, you may pass either an array or a <code class="classname">Zend_Config</code>
            object to the constructor. When you do so, you must include either the key "locale" or
            "format"; these will be used to set the appropriate values in the validator object.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_PostCode(array(
    'locale' =&gt; 'de_AT',
    'format' =&gt; 'AT_\d+'
));
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.post_code.options"></a>Supported options for Zend_Validate_PostCode</h4></div></div></div>
        

        <p>
            The following options are supported for <code class="classname">Zend_Validate_PostCode</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">format</span></em></span>: Sets a postcode format which
                    will be used for validation of the input.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: Sets a locale from which the
                    postcode will be taken from.
                </p>
            </li>
</ul></div>
    </div>
</div>
        

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.regex"></a>Regex</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si
                <code class="varname">$valor</code> coincide con el patrón de una
            expresión regular. </p>
    </div>

    
            <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.sitemap"></a>Sitemap Validators</h3></div></div></div>
    

    <p>
        The following validators conform to the <a class="ulink" href="http://www.sitemaps.org/protocol.php" target="_top">Sitemap <acronym class="acronym">XML</acronym>
            protocol</a>.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.changefreq"></a>Sitemap_Changefreq</h4></div></div></div>
        

        <p>
            Validates whether a string is valid for using as a 'changefreq'
            element in a Sitemap <acronym class="acronym">XML</acronym> document. Valid values are: 'always',
            'hourly', 'daily', 'weekly', 'monthly', 'yearly', or 'never'.
        </p>

        <p>
            Returns <code class="constant">TRUE</code> if and only if the value is a string
            and is equal to one of the frequencies specified above.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.lastmod"></a>Sitemap_Lastmod</h4></div></div></div>
        

        <p>
            Validates whether a string is valid for using as a 'lastmod'
            element in a Sitemap <acronym class="acronym">XML</acronym> document. The lastmod element should
            contain a <acronym class="acronym">W3C</acronym> date string, optionally discarding information
            about time.
        </p>

        <p>
            Returns <code class="constant">TRUE</code> if and only if the given value is
            a string and is valid according to the protocol.
        </p>

        <div class="example">
<a name="zend.validate.sitemap.lastmod.example"></a><p class="title"><b>Ejemplo 933. Sitemap Lastmod Validator</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$validator = new Zend_Validate_Sitemap_Lastmod();

$validator-&gt;isValid('1999-11-11T22:23:52-02:00'); // true
$validator-&gt;isValid('2008-05-12T00:42:52+02:00'); // true
$validator-&gt;isValid('1999-11-11'); // true
$validator-&gt;isValid('2008-05-12'); // true

$validator-&gt;isValid('1999-11-11t22:23:52-02:00'); // false
$validator-&gt;isValid('2008-05-12T00:42:60+02:00'); // false
$validator-&gt;isValid('1999-13-11'); // false
$validator-&gt;isValid('2008-05-32'); // false
$validator-&gt;isValid('yesterday'); // false
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.loc"></a>Sitemap_Loc</h4></div></div></div>
        

        <p>
            Validates whether a string is valid for using as a 'loc'
            element in a Sitemap <acronym class="acronym">XML</acronym> document. This uses
            <code class="methodname">Zend_Form::check()</code> internally. Read more at
            <a class="link" href="zend.uri.chapter.html#zend.uri.validation" title="URI Validation">URI Validation</a>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.priority"></a>Sitemap_Priority</h4></div></div></div>
        

        <p>
            Validates whether a value is valid for using as a 'priority'
            element in a Sitemap <acronym class="acronym">XML</acronym> document. The value should be a
            decimal between 0.0 and 1.0. This validator accepts both numeric
            values and string values.
        </p>

        <div class="example">
<a name="zend.validate.sitemap.priority.example"></a><p class="title"><b>Ejemplo 934. Sitemap Priority Validator</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$validator = new Zend_Validate_Sitemap_Priority();

$validator-&gt;isValid('0.1'); // true
$validator-&gt;isValid('0.789'); // true
$validator-&gt;isValid(0.8); // true
$validator-&gt;isValid(1.0); // true

$validator-&gt;isValid('1.1'); // false
$validator-&gt;isValid('-0.4'); // false
$validator-&gt;isValid(1.00001); // false
$validator-&gt;isValid(0xFF); // false
$validator-&gt;isValid('foo'); // false
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.sitemap.options"></a>Supported options for Zend_Validate_Sitemap_*</h4></div></div></div>
        

        <p>
            There are no supported options for any of the Sitemap validators.
        </p>
    </div>
</div>
        

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.string_length"></a>StringLength</h3></div></div></div>
        
        <p> Devuelve <code class="constant">TRUE</code> si y sólo si la longitud del
            string <code class="varname">$valor</code> es por lo menos un mínimo y no
            mayor a un máximo (cuando la opción max no es
                <code class="constant">NULL</code> ). Desde la versión 1.5.0, el método
                <code class="methodname">setMin()</code> lanza una excepción si la
            longitud mínima tiene un valor mayor que la longitud máxima
            establecida, y el método <code class="methodname">setMax()</code> lanza una
            excepción si la longitud máxima se fija a un valor inferior que la
            longitud mínima establecida. Desde la versión 1.0.2, esta clase
            soporta UTF-8 y a otras codificaciones, basado en el valor actual
            de: <a class="ulink" href="http://www.php.net/manual/en/ref.iconv.php#iconv.configuration" target="_top"> iconv.internal_encoding </a> . If you need a different
            encoding you can set it with the accessor methods getEncoding and
            setEncoding. </p>
    </div>

</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.validate.introduction.html">Anterior</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.validate.html">Subir</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.validate.validator_chains.html">Siguiente</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Introducción </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td>
<td width="40%" align="right" valign="top"> Cadenas de Validadores</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
