<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Standard Form Elements Shipped With Zend Framework</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Programmer's Reference Guide">
<link rel="up" href="zend.form.html" title="Zend_Form">
<link rel="prev" href="zend.form.decorators.html" title="Creating Custom Form Markup Using Zend_Form_Decorator">
<link rel="next" href="zend.form.standardDecorators.html" title="Standard Form Decorators Shipped With Zend Framework">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Standard Form Elements Shipped With Zend Framework</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.form.decorators.html">Prev</a> </td>
<th width="60%" align="center">Zend_Form</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.form.standardDecorators.html">Next</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.form.standardElements"></a>Standard Form Elements Shipped With Zend Framework</h2></div></div></div>
    

    <p>
        Zend Framework ships with concrete element classes covering most <acronym class="acronym">HTML</acronym>
        form elements. Most simply specify a particular view helper for use when
        decorating the element, but several offer additional functionality. The
        following is a list of all such classes, as well as descriptions of the
        functionality they offer.
    </p>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.button"></a>Zend_Form_Element_Button</h3></div></div></div>
        

        <p>
            Used for creating <acronym class="acronym">HTML</acronym> button elements,
            <code class="classname">Zend_Form_Element_Button</code> extends <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.submit" title="Zend_Form_Element_Submit">Zend_Form_Element_Submit</a>,
            specifying some custom functionality. It specifies the 'formButton'
            view helper for decoration.
        </p>

        <p>
            Like the submit element, it uses the element's label as the element
            value for display purposes; in other words, to set the text of the
            button, set the value of the element. The label will be translated
            if a translation adapter is present.
        </p>

        <p>
            Because the label is used as part of the element, the button element
            uses only the <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.viewHelper" title="Zend_Form_Decorator_ViewHelper">ViewHelper</a>
            and <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.dtDdWrapper" title="Zend_Form_Decorator_DtDdWrapper">DtDdWrapper</a>
            decorators.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.captcha"></a>Zend_Form_Element_Captcha</h3></div></div></div>
        

        <p>
            CAPTCHAs are used to prevent automated submission of forms by bots
            and other automated processes.
        </p>

        <p>
            The Captcha form element allows you to specify which <a class="link" href="zend.captcha.adapters.html" title="CAPTCHA Adapters">Zend_Captcha adapter</a> you
            wish to utilize as a form CAPTCHA. It then sets this adapter as a
            validator to the object, and uses a Captcha decorator for rendering
            (which proxies to the CAPTCHA adapter).
        </p>

        <p>
            Adapters may be any adapters in <code class="classname">Zend_Captcha</code>, as well
            as any custom adapters you may have defined elsewhere. To allow
            this, you may pass an additional plugin loader type key, 'CAPTCHA'
            or 'captcha', when specifying a plugin loader prefix path:
        </p>

        <pre class="programlisting">
$element-&gt;addPrefixPath('My_Captcha', 'My/Captcha/', 'captcha');
</pre>

        <p>
            Captcha's may then be registered using the <code class="methodname">setCaptcha()</code>
            method, which can take either a concrete CAPTCHA instance, or the
            short name of a CAPTCHA adapter:
        </p>

        <pre class="programlisting">
// Concrete instance:
$element-&gt;setCaptcha(new Zend_Captcha_Figlet());

// Using shortnames:
$element-&gt;setCaptcha('Dumb');
</pre>

        <p>
            If you wish to load your element via configuration, specify either
            the key 'captcha' with an array containing the key 'captcha', or
            both the keys 'captcha' and 'captchaOptions':
        </p>

        <pre class="programlisting">
// Using single captcha key:
$element = new Zend_Form_Element_Captcha('foo', array(
    'label' =&gt; "Please verify you're a human",
    'captcha' =&gt; array(
        'captcha' =&gt; 'Figlet',
        'wordLen' =&gt; 6,
        'timeout' =&gt; 300,
    ),
));

// Using both captcha and captchaOptions:
$element = new Zend_Form_Element_Captcha('foo', array(
    'label' =&gt; "Please verify you're a human",
    'captcha' =&gt; 'Figlet',
    'captchaOptions' =&gt; array(
        'captcha' =&gt; 'Figlet',
        'wordLen' =&gt; 6,
        'timeout' =&gt; 300,
    ),
));
</pre>

        <p>
            The decorator used is determined by querying the captcha adapter. By
            default, the <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.captcha" title="Zend_Form_Decorator_Captcha">Captcha
                decorator</a> is used, but an adapter may specify a different
            one via its <code class="methodname">getDecorator()</code> method.
        </p>

        <p>
            As noted, the captcha adapter itself acts as a validator for the
            element. Additionally, the NotEmpty validator is not used, and the
            element is marked as required. In most cases, you should need to do
            nothing else to have a captcha present in your form.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.checkbox"></a>Zend_Form_Element_Checkbox</h3></div></div></div>
        

        <p>
            <acronym class="acronym">HTML</acronym> checkboxes allow you return a specific value, but basically
            operate as booleans. When checked, the checkbox's value is submitted.
            When the checkbox is not checked, nothing is submitted. Internally,
            <code class="classname">Zend_Form_Element_Checkbox</code> enforces this state.
        </p>

        <p>
            By default, the checked value is '1', and the unchecked value '0'.
            You can specify the values to use using the <code class="methodname">setCheckedValue()</code>
            and <code class="methodname">setUncheckedValue()</code> accessors, respectively. Internally,
            any time you set the value, if the provided value matches the checked value, then it is
            set, but any other value causes the unchecked value to be set.
        </p>

        <p>
            Additionally, setting the value sets the <span class="property">checked</span>
            property of the checkbox. You can query this using
            <code class="methodname">isChecked()</code> or simply accessing the property. Using the
            <code class="methodname">setChecked($flag)</code> method will both set the state of the
            flag as well as set the appropriate checked or unchecked value in the
            element. Please use this method when setting the checked state of a
            checkbox element to ensure the value is set properly.
        </p>

        <p>
            <code class="classname">Zend_Form_Element_Checkbox</code> uses the 'formCheckbox' view
            helper. The checked value is always used to populate it.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.file"></a>Zend_Form_Element_File</h3></div></div></div>
        

        <p>
            The File form element provides a mechanism for supplying file upload
            fields to your form. It utilizes <a class="link" href="zend.file.transfer.introduction.html" title="Zend_File_Transfer">Zend_File_Transfer</a>
            internally to provide this functionality, and the
            <code class="classname">FormFile</code> view helper as also the <code class="classname">File</code>
            decorator to display the form element.
        </p>

        <p>
            By default, it uses the <code class="classname">Http</code> transfer adapter, which
            introspects the <code class="varname">$_FILES</code> array and allows you to attach
            validators and filters. Validators and filters attached to the form
            element are in turn attached to the transfer adapter.
        </p>

        <div class="example">
<a name="zend.form.standardElements.file.usage"></a><p class="title"><b>Example 448. File form element usage</b></p>
<div class="example-contents">
            

            <p>
                The above explanation of using the File form element may seem
                arcane, but actual usage is relatively trivial:
            </p>

            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload');
// ensure only 1 file
$element-&gt;addValidator('Count', false, 1);
// limit to 100K
$element-&gt;addValidator('Size', false, 102400);
// only JPEG, PNG, and GIFs
$element-&gt;addValidator('Extension', false, 'jpg,png,gif');
$form-&gt;addElement($element, 'foo');
</pre>

            <p>
                You also need to ensure that the correct encoding type is provided to
                the form; you should use 'multipart/form-data'. You can do this
                by setting the 'enctype' attribute on the form:
            </p>

            <pre class="programlisting">
$form-&gt;setAttrib('enctype', 'multipart/form-data');
</pre>

            <p>
                After the form is validated successfully, you must receive the file
                to store it in the final destination using <code class="methodname">receive()</code>.
                Additionally you can determinate the final location using
                <code class="methodname">getFileName()</code>:
            </p>

            <pre class="programlisting">
if (!$form-&gt;isValid()) {
    print "Uh oh... validation error";
}

if (!$form-&gt;foo-&gt;receive()) {
    print "Error receiving the file";
}

$location = $form-&gt;foo-&gt;getFileName();
</pre>
        </div>
</div>
<br class="example-break">

        <div class="note"><table border="0" summary="Note: Default Upload Location">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">Default Upload Location</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                By default, files are uploaded to the system temp directory.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: File values">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">File values</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Within <acronym class="acronym">HTTP</acronym> a file element has no value. For this reason and
                because of security concerns <code class="methodname">getValue()</code> returns only the
                uploaded filename and not the complete path. If you need the file path, call
                <code class="methodname">getFileName()</code>, which returns both the path and the name of
                the file.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: Return value of getFileName()">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">Return value of getFileName()</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                The result returned by the getFileName() method will change depending on how many files the Zend_Form_Element_File uploaded:
            </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        A single file: string containing the single file name.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Multiple files: an array, where each item is a string containing a single file name.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        No files: an empty array
                    </p>
                </li>
</ul></div>
<p>
            </p>
        </td></tr>
</table></div>

        <p>
            Per default the file will automatically be received when you call
            <code class="methodname">getValues()</code> on the form. The reason behind this behaviour is,
            that the file itself is the value of the file element.
        </p>

        <pre class="programlisting">
$form-&gt;getValues();
</pre>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Therefor another call of <code class="methodname">receive()</code> after calling
                <code class="methodname">getValues()</code> will not have an effect. Also creating a
                instance of <code class="classname">Zend_File_Transfer</code> will not have an effect as
                there no file anymore to receive.
            </p>
        </td></tr>
</table></div>

        <p>
            Still, sometimes you may want to call <code class="methodname">getValues()</code> without
            receiving the file. You can archive this by calling
            <code class="methodname">setValueDisabled(true)</code>. To get the actual value of this flag
            you can call <code class="methodname">isValueDisabled()</code>.
        </p>

        <div class="example">
<a name="zend.form.standardElements.file.retrievement"></a><p class="title"><b>Example 449. Explicit file retrievement</b></p>
<div class="example-contents">
            

            <p>
                First call <code class="methodname">setValueDisabled(true)</code>.
            </p>

            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload')
        -&gt;setValueDisabled(true);
</pre>

            <p>
                Now the file will not be received when you call
                <code class="methodname">getValues()</code>. So you must call
                <code class="methodname">receive()</code> on the file element, or an instance of
                <code class="classname">Zend_File_Transfer</code> yourself.
            </p>

            <pre class="programlisting">
$values = $form-&gt;getValues();

if ($form-&gt;isValid($form-&gt;getPost())) {
    if (!$form-&gt;foo-&gt;receive()) {
        print "Upload error";
    }
}
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            There are several states of the uploaded file which can be checked
            with the following methods:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="methodname">isUploaded()</code>: Checks if the file element has
                    been uploaded or not.
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">isReceived()</code>: Checks if the file element has
                    already been received.
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">isFiltered()</code>: Checks if the filters have already
                    been applied to the file element or not.
                </p>
            </li>
</ul></div>

        <div class="example">
<a name="zend.form.standardElements.file.isuploaded"></a><p class="title"><b>Example 450. Checking if an optional file has been uploaded</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload')
        -&gt;setRequired(false);
$element-&gt;addValidator('Size', false, 102400);
$form-&gt;addElement($element, 'foo');

// The foo file element is optional but when it's given go into here
if ($form-&gt;foo-&gt;isUploaded()) {
    // foo file given... do something
}
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            <code class="classname">Zend_Form_Element_File</code> also supports multiple files.
            By calling the <code class="methodname">setMultiFile($count)</code> method you can set
            the number of file elements you want to create. This keeps you
            from setting the same settings multiple times.
        </p>

        <div class="example">
<a name="zend.form.standardElements.file.multiusage"></a><p class="title"><b>Example 451. Setting multiple files</b></p>
<div class="example-contents">
            

            <p>
                Creating a multifile element is the same as setting a single element.
                Just call <code class="methodname">setMultiFile()</code> after the element is created:
            </p>

            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload');
// ensure minimum 1, maximum 3 files
$element-&gt;addValidator('Count', false, array('min' =&gt; 1, 'max' =&gt; 3));
// limit to 100K
$element-&gt;addValidator('Size', false, 102400);
// only JPEG, PNG, and GIFs
$element-&gt;addValidator('Extension', false, 'jpg,png,gif');
// defines 3 identical file elements
$element-&gt;setMultiFile(3);
$form-&gt;addElement($element, 'foo');
</pre>

            <p>
                You now have 3 identical file upload elements
                with the same settings. To get the set multifile number simply call
                <code class="methodname">getMultiFile()</code>.
            </p>

        </div>
</div>
<br class="example-break">

        <div class="note"><table border="0" summary="Note: File elements in Subforms">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">File elements in Subforms</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                When you use file elements in subforms you must set unique names.
                For example, if you name a file element in subform1 "file", you must give
                any file element in subform2 a different name.
            </p>

            <p>
                If there are 2 file elements with the same name, the second
                element is not be displayed or submitted.
            </p>

            <p>
                Additionally, file elements are not rendered within the sub-form. So when
                you add a file element into a subform, then the element will be rendered
                within the main form.
            </p>
        </td></tr>
</table></div>

        <p>
            To limit the size of the file uploaded, you can
            specify the maximum file size by setting the <code class="constant">MAX_FILE_SIZE</code>
            option on the form. When you set this value by using the
            <code class="methodname">setMaxFileSize($size)</code> method, it will be rendered with the
            file element.
        </p>

        <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload an image:')
        -&gt;setDestination('/var/www/upload')
        -&gt;addValidator('Size', false, 102400) // limit to 100K
        -&gt;setMaxFileSize(102400); // limits the filesize on the client side
$form-&gt;addElement($element, 'foo');
</pre>

        <div class="note"><table border="0" summary="Note: MaxFileSize with Multiple File Elements">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">MaxFileSize with Multiple File Elements</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                When you use multiple file elements in your form you should set
                the <code class="constant">MAX_FILE_SIZE</code> only once. Setting it again will
                overwrite the previous value.
            </p>

            <p>
                Note, that this is also the case when you use multiple forms.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.hidden"></a>Zend_Form_Element_Hidden</h3></div></div></div>
        

        <p>
            Hidden elements inject data that should be submitted, but that should not manipulated by
            the user . <code class="classname">Zend_Form_Element_Hidden</code> accomplishes this with the
            'formHidden' view helper.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.hash"></a>Zend_Form_Element_Hash</h3></div></div></div>
        

        <p>
            This element provides protection from CSRF attacks on forms,
            ensuring the data is submitted by the user session that generated
            the form and not by a rogue script. Protection is achieved by adding
            a hash element to a form and verifying it when the form is
            submitted.
        </p>

        <p>
            The name of the hash element should be unique. We recommend using
            the <code class="literal">salt</code> option for the element- two hashes with
            same names and different salts would not collide:
        </p>

        <pre class="programlisting">
$form-&gt;addElement('hash', 'no_csrf_foo', array('salt' =&gt; 'unique'));
</pre>

        <p>
            You can set the salt later using the <code class="methodname">setSalt($salt)</code>
            method.
        </p>

        <p>
            Internally, the element stores a unique identifier using
            <code class="classname">Zend_Session_Namespace</code>, and checks for it at
            submission (checking that the TTL has not expired). The 'Identical'
            validator is then used to ensure the submitted hash matches the
            stored hash.
        </p>

        <p>
            The 'formHidden' view helper is used to render the element in the
            form.
        </p>

        <div class="note"><table border="0" summary="Note: Testing forms containing Zend_Form_Element_Hash">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">Testing forms containing Zend_Form_Element_Hash</th>
</tr>
<tr><td align="left" valign="top">
            
            <p>
                When unit testing a form containing a <code class="classname">Zend_Form_Element_Hash</code> 
                it is necessary to call <code class="methodname">initCsrfToken</code> and 
                <code class="methodname">initCsrfValidator</code> before attempting to
                validate the form.  The hash value of the <code class="classname">Zend_Form_Element_Hash</code> 
                element must also be injected into the array of values passed as the
                argument to <code class="methodname">Zend_Form::isValid</code>
            </p>
            <div class="example">
<a name="zend.form.standardElements.hash.unittesting"></a><p class="title"><b>Example 452. Simple example of testing a CSRF-protected form</b></p>
<div class="example-contents">
                
                <pre class="programlisting">
public function testCsrfProtectedForm() 
{
    $form = new Zend_Form();
    $form-&gt;addElement(new Zend_Form_Element_Hash('csrf'));

    $csrf = $form-&gt;getElement('csrf');
    $csrf-&gt;initCsrfToken();
    $csrf-&gt;initCsrfValidator();

    $this-&gt;assertTrue($form-&gt;isValid(array(
        'csrf' =&gt; $csrf-&gt;getHash()
    )));
}</pre>

            </div>
</div>
<br class="example-break">
        </td></tr>
</table></div>
        
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.Image"></a>Zend_Form_Element_Image</h3></div></div></div>
        

        <p>
            Images can be used as form elements, and you can use these images as
            graphical elements on form buttons.
        </p>

        <p>
            Images need an image source. <code class="classname">Zend_Form_Element_Image</code>
            allows you to specify this by using the <code class="methodname">setImage()</code>
            accessor (or 'image' configuration key). You can also optionally specify a value to use
            when submitting the image using the <code class="methodname">setImageValue()</code> accessor
            (or 'imageValue' configuration key). When the value set for the
            element matches the <span class="property">imageValue</span>, then the accessor
            <code class="methodname">isChecked()</code> will return <code class="constant">TRUE</code>.
        </p>

        <p>
            Image elements use the
            <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.image" title="Zend_Form_Decorator_Image">Image
                Decorator</a> for rendering, in addition to the standard Errors,
            HtmlTag, and Label decorators. You can optionally specify a tag to
            the <code class="classname">Image</code> decorator that will then wrap the image
            element.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.multiCheckbox"></a>Zend_Form_Element_MultiCheckbox</h3></div></div></div>
        

        <p>
            Often you have a set of related checkboxes, and you wish to group
            the results. This is much like a <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.multiselect" title="Zend_Form_Element_Multiselect">Multiselect</a>,
            but instead of them being in a dropdown list, you need to show
            checkbox/value pairs.
        </p>

        <p>
            <code class="classname">Zend_Form_Element_MultiCheckbox</code> makes this a snap. Like
            all other elements extending the base Multi element, you can specify
            a list of options, and easily validate against that same list. The
            'formMultiCheckbox' view helper ensures that these are returned as
            an array in the form submission.
        </p>

        <p>
            By default, this element registers an <code class="classname">InArray</code> validator
            which validates against the array keys of registered options. You
            can disable this behavior by either calling
            <code class="methodname">setRegisterInArrayValidator(false)</code>, or by passing a
            <code class="constant">FALSE</code> value to the <span class="property">registerInArrayValidator</span>
            configuration key.
        </p>

        <p>
            You may manipulate the various checkbox options using the following
            methods:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="methodname">addMultiOption($option, $value)</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">addMultiOptions(array $options)</code></p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code> (overwrites existing
                    options)
                </p>
            </li>
<li class="listitem"><p><code class="methodname">getMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">getMultiOptions()</code></p></li>
<li class="listitem"><p><code class="methodname">removeMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">clearMultiOptions()</code></p></li>
</ul></div>

        <p>
            To mark checked items, you need to pass an array of values to
            <code class="methodname">setValue()</code>. The following will check the values "bar"
            and "bat":
        </p>

        <pre class="programlisting">
$element = new Zend_Form_Element_MultiCheckbox('foo', array(
    'multiOptions' =&gt; array(
        'foo' =&gt; 'Foo Option',
        'bar' =&gt; 'Bar Option',
        'baz' =&gt; 'Baz Option',
        'bat' =&gt; 'Bat Option',
    )
));

$element-&gt;setValue(array('bar', 'bat'));
</pre>

        <p>
            Note that even when setting a single value, you must pass an array.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.multiselect"></a>Zend_Form_Element_Multiselect</h3></div></div></div>
        

        <p>
            <acronym class="acronym">XHTML</acronym> <span class="emphasis"><em>select</em></span> elements allow a 'multiple'
            attribute, indicating multiple options may be selected for submission, instead
            of the usual one. <code class="classname">Zend_Form_Element_Multiselect</code> extends
            <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.select" title="Zend_Form_Element_Select">Zend_Form_Element_Select</a>,
            and sets the <span class="property">multiple</span> attribute to 'multiple'. Like
            other classes that inherit from the base
            <code class="classname">Zend_Form_Element_Multi</code> class, you can manipulate the
            options for the select using:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="methodname">addMultiOption($option, $value)</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">addMultiOptions(array $options)</code></p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code> (overwrites existing
                    options)
                </p>
            </li>
<li class="listitem"><p><code class="methodname">getMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">getMultiOptions()</code></p></li>
<li class="listitem"><p><code class="methodname">removeMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">clearMultiOptions()</code></p></li>
</ul></div>

        <p>
            If a translation adapter is registered with the form and/or element,
            option values will be translated for display purposes.
        </p>

        <p>
            By default, this element registers an <code class="classname">InArray</code> validator
            which validates against the array keys of registered options. You
            can disable this behavior by either calling
            <code class="methodname">setRegisterInArrayValidator(false)</code>, or by passing a
            <code class="constant">FALSE</code> value to the <span class="property">registerInArrayValidator</span>
            configuration key.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.password"></a>Zend_Form_Element_Password</h3></div></div></div>
        

        <p>
            Password elements are basically normal text elements -- except that
            you typically do not want the submitted password displayed in error
            messages or the element itself when the form is re-displayed.
        </p>

        <p>
            <code class="classname">Zend_Form_Element_Password</code> achieves this by calling
            <code class="methodname">setObscureValue(true)</code> on each validator (ensuring that
            the password is obscured in validation error messages), and using
            the 'formPassword' view helper (which does not display the value
            passed to it).
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.radio"></a>Zend_Form_Element_Radio</h3></div></div></div>
        

        <p>
            Radio elements allow you to specify several options, of which you
            need a single value returned. <code class="classname">Zend_Form_Element_Radio</code>
            extends the base <code class="classname">Zend_Form_Element_Multi</code> class,
            allowing you to specify a number of options, and then uses the
            <span class="emphasis"><em>formRadio</em></span> view helper to display these.
        </p>

        <p>
            By default, this element registers an <code class="classname">InArray</code> validator
            which validates against the array keys of registered options. You
            can disable this behavior by either calling
            <code class="methodname">setRegisterInArrayValidator(false)</code>, or by passing a
            <code class="constant">FALSE</code> value to the <span class="property">registerInArrayValidator</span>
            configuration key.
        </p>

        <p>
            Like all elements extending the Multi element base class, the
            following methods may be used to manipulate the radio options
            displayed:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="methodname">addMultiOption($option, $value)</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">addMultiOptions(array $options)</code></p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code>
                    (overwrites existing options)
                </p>
            </li>
<li class="listitem"><p><code class="methodname">getMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">getMultiOptions()</code></p></li>
<li class="listitem"><p><code class="methodname">removeMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">clearMultiOptions()</code></p></li>
</ul></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.reset"></a>Zend_Form_Element_Reset</h3></div></div></div>
        

        <p>
            Reset buttons are typically used to clear a form, and are not part
            of submitted data. However, as they serve a purpose in the display,
            they are included in the standard elements.
        </p>

        <p>
            <code class="classname">Zend_Form_Element_Reset</code> extends <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.submit" title="Zend_Form_Element_Submit">Zend_Form_Element_Submit</a>.
            As such, the label is used for the button display, and will be
            translated if a translation adapter is present. It utilizes only the
            'ViewHelper' and 'DtDdWrapper' decorators, as there should never be
            error messages for such elements, nor will a label be necessary.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.select"></a>Zend_Form_Element_Select</h3></div></div></div>
        

        <p>
            Select boxes are a common way of limiting to specific choices for a
            given form datum. <code class="classname">Zend_Form_Element_Select</code> allows you
            to generate these quickly and easily.
        </p>

        <p>
            By default, this element registers an <code class="classname">InArray</code> validator
            which validates against the array keys of registered options. You
            can disable this behavior by either calling
            <code class="methodname">setRegisterInArrayValidator(false)</code>, or by passing a
            <code class="constant">FALSE</code> value to the <span class="property">registerInArrayValidator</span>
            configuration key.
        </p>

        <p>
            As it extends the base Multi element, the following methods may be
            used to manipulate the select options:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="methodname">addMultiOption($option, $value)</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">addMultiOptions(array $options)</code></p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code>
                    (overwrites existing options)
                </p>
            </li>
<li class="listitem"><p><code class="methodname">getMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">getMultiOptions()</code></p></li>
<li class="listitem"><p><code class="methodname">removeMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">clearMultiOptions()</code></p></li>
</ul></div>

        <p>
            <code class="classname">Zend_Form_Element_Select</code> uses the 'formSelect' view
            helper for decoration.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.submit"></a>Zend_Form_Element_Submit</h3></div></div></div>
        

        <p>
            Submit buttons are used to submit a form. You may use multiple
            submit buttons; you can use the button used to submit the form to
            decide what action to take with the data submitted.
            <code class="classname">Zend_Form_Element_Submit</code> makes this decisioning easy,
            by adding a <code class="methodname">isChecked()</code> method; as only one button
            element will be submitted by the form, after populating or
            validating the form, you can call this method on each submit button
            to determine which one was used.
        </p>

        <p>
            <code class="classname">Zend_Form_Element_Submit</code> uses the label as the "value"
            of the submit button, translating it if a translation adapter is
            present. <code class="methodname">isChecked()</code> checks the submitted value against
            the label in order to determine if the button was used.
        </p>

        <p>
            The <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.viewHelper" title="Zend_Form_Decorator_ViewHelper">ViewHelper</a>
            and <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.dtDdWrapper" title="Zend_Form_Decorator_DtDdWrapper">DtDdWrapper</a>
            decorators to render the element. No label decorator is used, as the
            button label is used when rendering the element; also, typically,
            you will not associate errors with a submit element.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.text"></a>Zend_Form_Element_Text</h3></div></div></div>
        

        <p>
            By far the most prevalent type of form element is the text element,
            allowing for limited text entry; it's an ideal element for most data
            entry. <code class="classname">Zend_Form_Element_Text</code> simply uses the
            'formText' view helper to display the element.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.textarea"></a>Zend_Form_Element_Textarea</h3></div></div></div>
        

        <p>
            Textareas are used when large quantities of text are expected, and
            place no limits on the amount of text submitted (other than maximum
            size limits as dictated by your server or <acronym class="acronym">PHP</acronym>).
            <code class="classname">Zend_Form_Element_Textarea</code> uses the 'textArea' view
            helper to display such elements, placing the value as the content of
            the element.
        </p>
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.form.decorators.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.form.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.form.standardDecorators.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Creating Custom Form Markup Using Zend_Form_Decorator </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Standard Form Decorators Shipped With Zend Framework</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
