<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Zend_Cache Frontends</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Programmer's Reference Guide">
<link rel="up" href="zend.cache.html" title="Zend_Cache">
<link rel="prev" href="zend.cache.theory.html" title="The Theory of Caching">
<link rel="next" href="zend.cache.backends.html" title="Zend_Cache Backends">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Zend_Cache Frontends</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.cache.theory.html">Prev</a> </td>
<th width="60%" align="center">Zend_Cache</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.cache.backends.html">Next</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.cache.frontends"></a>Zend_Cache Frontends</h2></div></div></div>
    

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.core"></a>Zend_Cache_Core</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.core.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Core</code> is a special frontend because it is the core
                of the module. It is a generic cache frontend and is extended by other classes.
            </p>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    All frontends inherit from <code class="classname">Zend_Cache_Core</code> so that its
                    methods and options (described below) would also be available in other
                    frontends, therefore they won't be documented there.
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.core.options"></a>Available options</h4></div></div></div>
            

            <p>
                These options are passed to the factory method as demonstrated in previous examples.
            </p>

            <div class="table">
<a name="zend.cache.frontends.core.options.table"></a><p class="title"><b>Table 20. Core Frontend Options</b></p>
<div class="table-contents">
                

                <table class="table" summary="Core Frontend Options" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Data Type</th>
<th>Default Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>caching</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">TRUE</code></td>
<td>
                                enable / disable caching (can be very useful for the debug of
                                cached scripts)
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>cache_id_prefix</em></span></td>
<td><span class="type">String</span></td>
<td><code class="constant">NULL</code></td>
<td>
                                A prefix for all cache ids, if set to <code class="constant">NULL</code>,
                                no cache id prefix will be used. The cache id prefix essentially
                                creates a namespace in the cache, allowing multiple applications
                                or websites to use a shared cache. Each application or website can
                                use a different cache id prefix so specific cache ids can be used
                                more than once.
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>lifetime</em></span></td>
<td><span class="type">Integer</span></td>
<td>3600</td>
<td>
                                cache lifetime (in seconds), if set to <code class="constant">NULL</code>,
                                the cache is valid forever.
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>logging</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                if set to <code class="constant">TRUE</code>, logging through
                                <code class="classname">Zend_Log</code> is
                                activated (but the system is slower)
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>write_control</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">TRUE</code></td>
<td>
                                Enable / disable write control (the cache is read just after
                                writing to detect corrupt entries), enabling write_control will
                                lightly slow the cache writing but not the cache reading (it can
                                detect some corrupt cache files but it's not a perfect control)
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>automatic_serialization</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                Enable / disable automatic serialization, it can be used to save
                                directly datas which aren't strings (but it's slower)
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>automatic_cleaning_factor</em></span></td>
<td><span class="type">Integer</span></td>
<td>10</td>
<td>
                                Disable / Tune the automatic cleaning process (garbage collector):
                                0 means no automatic cache cleaning, 1 means systematic cache
                                cleaning and x &gt; 1 means automatic random cleaning 1 times in x
                                write operations.
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>ignore_user_abort</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                if set to <code class="constant">TRUE</code>, the core will set the
                                ignore_user_abort <acronym class="acronym">PHP</acronym> flag inside the
                                <code class="methodname">save()</code> method to avoid cache
                                corruptions in some cases
                            </td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.core.examples"></a>Examples</h4></div></div></div>
            

            <p>
                An example is given in the manual at the very beginning.
            </p>

            <p>
                If you store only strings into cache (because with "automatic_serialization" option,
                it's possible to store some booleans), you can use a more compact construction like:
            </p>

            <pre class="programlisting">
// we assume you already have $cache

$id = 'myBigLoop'; // cache id of "what we want to cache"

if ( ($data = $cache-&gt;load($id)) === false ) {
    // cache miss

    $data = '';
    for ($i = 0; $i &lt; 10000; $i++) {
        $data = $data . $i;
    }

    $cache-&gt;save($data);

}

// [...] do something with $data (echo it, pass it on etc.)
</pre>

            <p>
                If you want to cache multiple blocks or data instances, the idea is the same:
            </p>

            <pre class="programlisting">
// make sure you use unique identifiers:
$id1 = 'foo';
$id2 = 'bar';

// block 1
if ( ($data = $cache-&gt;load($id1)) === false ) {
    // cache missed

    $data = '';
    for ($i=0;$i&lt;10000;$i++) {
        $data = $data . $i;
    }

    $cache-&gt;save($data);

}
echo($data);

// this isn't affected by caching
echo('NEVER CACHED! ');

// block 2
if ( ($data = $cache-&gt;load($id2)) === false ) {
    // cache missed

    $data = '';
    for ($i=0;$i&lt;10000;$i++) {
        $data = $data . '!';
    }

    $cache-&gt;save($data);

}
echo($data);
</pre>

            <p>
                If you want to cache special values (boolean with "automatic_serialization" option)
                or empty strings you can't use the compact construction given above. You have to
                test formally the cache record.
            </p>

            <pre class="programlisting">
// the compact construction
// (not good if you cache empty strings and/or booleans)
if ( ($data = $cache-&gt;load($id)) === false ) {

    // cache missed

    // [...] we make $data

    $cache-&gt;save($data);

}

// we do something with $data

// [...]

// the complete construction (works in any case)
if (!($cache-&gt;test($id))) {

    // cache missed

    // [...] we make $data

    $cache-&gt;save($data);

} else {

    // cache hit

    $data = $cache-&gt;load($id);

}

// we do something with $data
</pre>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.output"></a>Zend_Cache_Frontend_Output</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.output.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Output</code> is an output-capturing frontend.
                It utilizes output buffering in <acronym class="acronym">PHP</acronym> to capture everything
                between its <code class="methodname">start()</code> and <code class="methodname">end()</code>
                methods.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.output.options"></a>Available Options</h4></div></div></div>
            

            <p>
                This frontend doesn't have any specific options other than those of
                <code class="classname">Zend_Cache_Core</code>.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.output.examples"></a>Examples</h4></div></div></div>
            

            <p>
                An example is given in the manual at the very beginning. Here it is with minor
                changes:
            </p>

            <pre class="programlisting">
// if it is a cache miss, output buffering is triggered
if (!($cache-&gt;start('mypage'))) {

    // output everything as usual
    echo 'Hello world! ';
    echo 'This is cached ('.time().') ';

    $cache-&gt;end(); // output buffering ends

}

echo 'This is never cached ('.time().').';
</pre>

            <p>
                Using this form it is fairly easy to set up output caching in your already working
                project with little or no code refactoring.
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.function"></a>Zend_Cache_Frontend_Function</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.function.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Function</code> caches the results of function
                calls. It has a single main method named <code class="methodname">call()</code> which takes
                a function name and parameters for the call in an array.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.function.options"></a>Available Options</h4></div></div></div>
            

            <div class="table">
<a name="zend.cache.frontends.function.options.table"></a><p class="title"><b>Table 21. Function Frontend Options</b></p>
<div class="table-contents">
                

                <table class="table" summary="Function Frontend Options" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Data Type</th>
<th>Default Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>cache_by_default</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">TRUE</code></td>
<td>
                                if <code class="constant">TRUE</code>, function calls will be cached by
                                default
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>cached_functions</em></span></td>
<td><span class="type">Array</span></td>
<td> </td>
<td>function names which will always be cached</td>
</tr>
<tr>
<td><span class="emphasis"><em>non_cached_functions</em></span></td>
<td><span class="type">Array</span></td>
<td> </td>
<td>function names which must never be cached</td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.function.examples"></a>Examples</h4></div></div></div>
            

            <p>
                Using the <code class="methodname">call()</code> function is the same as using
                <code class="methodname">call_user_func_array()</code> in <acronym class="acronym">PHP</acronym>:
            </p>

            <pre class="programlisting">
$cache-&gt;call('veryExpensiveFunc', $params);

// $params is an array
// For example to call veryExpensiveFunc(1, 'foo', 'bar') with
// caching, you can use
// $cache-&gt;call('veryExpensiveFunc', array(1, 'foo', 'bar'))
</pre>

            <p>
                <code class="classname">Zend_Cache_Frontend_Function</code> is smart enough to cache both
                the return value of the function and its internal output.
            </p>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    You can pass any built in or user defined function with the exception of
                    <code class="methodname">array()</code>, <code class="methodname">echo()</code>,
                    <code class="methodname">empty()</code>, <code class="methodname">eval()</code>,
                    <code class="methodname">exit()</code>, <code class="methodname">isset()</code>,
                    <code class="methodname">list()</code>, <code class="methodname">print()</code> and
                    <code class="methodname">unset()</code>.
                </p>
            </td></tr>
</table></div>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.class"></a>Zend_Cache_Frontend_Class</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.class.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Class</code> is different from
                <code class="classname">Zend_Cache_Frontend_Function</code> because it allows caching of
                object and static method calls.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.class.options"></a>Available Options</h4></div></div></div>
            

            <div class="table">
<a name="zend.cache.frontends.class.options.table"></a><p class="title"><b>Table 22. Class Frontend Options</b></p>
<div class="table-contents">
                

                <table class="table" summary="Class Frontend Options" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Data Type</th>
<th>Default Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>
<span class="emphasis"><em>cached_entity</em></span> (required)</td>
<td><span class="type">Mixed</span></td>
<td> </td>
<td>
                                  if set to a class name, we will cache an abstract class and will
                                  use only static calls; if set to an object, we will cache this
                                  object methods
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>cache_by_default</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">TRUE</code></td>
<td>
                                  if <code class="constant">TRUE</code>, calls will be cached by default
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>cached_methods</em></span></td>
<td><span class="type">Array</span></td>
<td> </td>
<td>method names which will always be cached</td>
</tr>
<tr>
<td><span class="emphasis"><em>non_cached_methods</em></span></td>
<td><span class="type">Array</span></td>
<td> </td>
<td>method names which must never be cached</td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.class.examples"></a>Examples</h4></div></div></div>
            

            <p>
                For example, to cache static calls :
            </p>

            <pre class="programlisting">
class Test {

    // Static method
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' =&gt; 'Test' // The name of the class
);
// [...]

// The cached call
$result = $cache-&gt;foobar('1', '2');
</pre>

            <p>
                To cache classic method calls :
            </p>

            <pre class="programlisting">
class Test {

    private $_string = 'hello !';

    public function foobar2($param1, $param2) {
        echo($this-&gt;_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' =&gt; new Test() // An instance of the class
);
// [...]

// The cached call
$result = $cache-&gt;foobar2('1', '2');
</pre>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.file"></a>Zend_Cache_Frontend_File</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.file.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_File</code> is a frontend driven by the
                modification time of a "master file". It's really interesting for examples
                in configuration or templates issues. It's also possible to use multiple
                master files.
            </p>

            <p>
                For instance, you have an <acronym class="acronym">XML</acronym> configuration file which is parsed
                by a function which returns a "config object" (like with
                <code class="classname">Zend_Config</code>). With
                <code class="classname">Zend_Cache_Frontend_File</code>, you can store the "config object"
                into cache (to avoid the parsing of the <acronym class="acronym">XML</acronym> config file at each
                time) but with a sort of strong dependency on the "master file". So, if the
                <acronym class="acronym">XML</acronym> config file is modified, the cache is immediately
                invalidated.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.file.options"></a>Available Options</h4></div></div></div>
            
            <div class="table">
<a name="zend.cache.frontends.file.options.table"></a><p class="title"><b>Table 23. File Frontend Options</b></p>
<div class="table-contents">
                
                <table class="table" summary="File Frontend Options" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Data Type</th>
<th>Default Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>master_file (deprecated)</em></span></td>
<td><span class="type">String</span></td>
<td>''</td>
<td>the complete path and name of the master file</td>
</tr>
<tr>
<td><span class="emphasis"><em>master_files</em></span></td>
<td><span class="type">Array</span></td>
<td><code class="methodname">array()</code></td>
<td>an array of complete path of master files</td>
</tr>
<tr>
<td><span class="emphasis"><em>master_files_mode</em></span></td>
<td><span class="type">String</span></td>
<td><code class="constant">Zend_Cache_Frontend_File::MODE_OR</code></td>
<td>
                                <code class="constant">Zend_Cache_Frontend_File::MODE_AND</code> or
                                <code class="constant">Zend_Cache_Frontend_File::MODE_OR</code> ; if
                                <code class="constant">MODE_AND</code>, then all master files have to be
                                touched to get a cache invalidation if
                                <code class="constant">MODE_OR</code>, then a single touched master file is
                                enough to get a cache invalidation
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>ignore_missing_master_files</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                if <code class="constant">TRUE</code>, missing master files are ignored
                                silently (an exception is raised else)
                            </td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.file.examples"></a>Examples</h4></div></div></div>
            

            <p>
                Use of this frontend is the same than of <code class="classname">Zend_Cache_Core</code>.
                There is no need of a specific example - the only thing to do is to
                define the <span class="emphasis"><em>master_file</em></span> when using the factory.
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.page"></a>Zend_Cache_Frontend_Page</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.page.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Page</code> is like
                <code class="classname">Zend_Cache_Frontend_Output</code> but designed for a complete page.
                It's impossible to use <code class="classname">Zend_Cache_Frontend_Page</code> for caching
                only a single block.
            </p>

            <p>
                On the other hand, the "cache id" is calculated automatically with
                <code class="varname">$_SERVER['REQUEST_URI']</code> and (depending on options)
                <code class="varname">$_GET</code>, <code class="varname">$_POST</code>, <code class="varname">$_SESSION</code>,
                <code class="varname">$_COOKIE</code>, <code class="varname">$_FILES</code>. More over, you have only
                one method to call (<code class="methodname">start()</code>) because the
                <code class="methodname">end()</code> call is fully automatic when the page is ended.
            </p>

            <p>
                For the moment, it's not implemented but we plan to add a <acronym class="acronym">HTTP</acronym>
                conditional system to save bandwidth (the system will send a
                <acronym class="acronym">HTTP</acronym> 304 Not Modified if the cache is hit and if the browser
                has already the good version).
            </p>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    This frontend operates by registering a callback function to be called
                    when the output buffering it uses is cleaned. In order for this to operate
                    correctly, it must be the final output buffer in the request. To guarantee
                    this, the output buffering used by the Dispatcher <span class="emphasis"><em>must</em></span> be
                    disabled by calling <code class="classname">Zend_Controller_Front</code>'s
                    <code class="methodname">setParam()</code> method, for example,
                    <span class="command"><strong>$front-&gt;setParam('disableOutputBuffering', true);</strong></span> or adding
                    "resources.frontcontroller.params.disableOutputBuffering = true"
                    to your bootstrap configuration file (assumed <acronym class="acronym">INI</acronym>) if using
                    <code class="classname">Zend_Application</code>.
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.page.options"></a>Available Options</h4></div></div></div>
            

            <div class="table">
<a name="zend.cache.frontends.page.options.table"></a><p class="title"><b>Table 24. Page Frontend Options</b></p>
<div class="table-contents">
                

                <table class="table" summary="Page Frontend Options" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Data Type</th>
<th>Default Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>http_conditional</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                use the http_conditional system (not implemented for the moment)
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>debug_header</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                if <code class="constant">TRUE</code>, a debug text is added before each
                                cached pages
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>default_options</em></span></td>
<td><span class="type">Array</span></td>
<td><code class="methodname">array(...see below...)</code></td>
<td>
                                an associative array of default options:
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> by
                                                default) cache</em></span>: cache is on if
                                            <code class="constant">TRUE</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> by
                                                default) cache_with_get_variables</em></span>: if
                                            <code class="constant">TRUE</code>,
                                            cache is still on even if there are some variables in
                                            <code class="varname">$_GET</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> by
                                                default) cache_with_post_variables</em></span>: if
                                            <code class="constant">TRUE</code>,
                                            cache is still on even if there are some variables in
                                            <code class="varname">$_POST</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> by
                                                default) cache_with_session_variables</em></span>:
                                            if <code class="constant">TRUE</code>,
                                            cache is still on even if there are some variables in
                                            <code class="varname">$_SESSION</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> by
                                                default) cache_with_files_variables</em></span>:
                                            if <code class="constant">TRUE</code>,
                                            cache is still on even if there are some variables in
                                            <code class="varname">$_FILES</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> by
                                                default) cache_with_cookie_variables</em></span>:
                                            if <code class="constant">TRUE</code>,
                                            cache is still on even if there are some variables in
                                            <code class="varname">$_COOKIE</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> by
                                                default) make_id_with_get_variables</em></span>:
                                            if <code class="constant">TRUE</code>,
                                            the cache id will be dependent of the content of the
                                            <code class="varname">$_GET</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> by
                                                default) make_id_with_post_variables</em></span>:
                                            if <code class="constant">TRUE</code>,
                                            the cache id will be dependent of the content of the
                                            <code class="varname">$_POST</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> by
                                                default)
                                                make_id_with_session_variables</em></span>: if
                                            <code class="constant">TRUE</code>,
                                            the cache id will be dependent of the content of
                                            the <code class="varname">$_SESSION</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> by
                                                default) make_id_with_files_variables</em></span>:
                                            if <code class="constant">TRUE</code>,
                                            the cache id will be dependent of the content of the
                                            <code class="varname">$_FILES</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> by
                                                default)
                                                make_id_with_cookie_variables</em></span>: if
                                            <code class="constant">TRUE</code>,
                                            the cache id will be dependent of the content of
                                            the <code class="varname">$_COOKIE</code> array
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(int, <code class="constant">FALSE</code> by
                                                default) specific_lifetime</em></span>: if not
                                            <code class="constant">FALSE</code>, the
                                            given lifetime will be used for the chosen regexp
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(array, <code class="methodname">array()</code> by
                                                default) tags</em></span>: tags for the cache
                                            record
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(int, <code class="constant">NULL</code> by default)
                                                priority</em></span>: priority (if the backend
                                            supports it)
                                        </p>
                                    </li>
</ul></div>
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>regexps</em></span></td>
<td><span class="type">Array</span></td>
<td><code class="methodname">array()</code></td>
<td>
                                an associative array to set options only for some
                                <code class="constant">REQUEST_URI</code>, keys are
                                (<acronym class="acronym">PCRE</acronym>) regexps, values are associative arrays
                                with specific options to set if the regexp matchs on
                                <code class="varname">$_SERVER['REQUEST_URI']</code> (see default_options
                                for the list of available options); if several regexps match the
                                <code class="varname">$_SERVER['REQUEST_URI']</code>, only the last one
                                will be used
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>memorize_headers</em></span></td>
<td><span class="type">Array</span></td>
<td><code class="methodname">array()</code></td>
<td>
                                an array of strings corresponding to some
                                <acronym class="acronym">HTTP</acronym> headers name. Listed headers will be
                                stored with cache datas and "replayed" when the cache is hit
                            </td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.page.examples"></a>Examples</h4></div></div></div>
            

            <p>
                Use of <code class="classname">Zend_Cache_Frontend_Page</code> is really trivial:
            </p>

            <pre class="programlisting">
// [...] // require, configuration and factory

$cache-&gt;start();
// if the cache is hit, the result is sent to the browser
// and the script stop here

// rest of the page ...
</pre>

            <p>
                a more complex example which shows a way to get a centralized cache management in a
                bootstrap file (for using with <code class="classname">Zend_Controller</code> for example)
            </p>

            <pre class="programlisting">
/*
 * You should avoid putting too many lines before the cache section.
 * For example, for optimal performances, "require_once" or
 * "Zend_Loader::loadClass" should be after the cache section.
 */

$frontendOptions = array(
   'lifetime' =&gt; 7200,
   'debug_header' =&gt; true, // for debugging
   'regexps' =&gt; array(
       // cache the whole IndexController
       '^/$' =&gt; array('cache' =&gt; true),

       // cache the whole IndexController
       '^/index/' =&gt; array('cache' =&gt; true),

       // we don't cache the ArticleController...
       '^/article/' =&gt; array('cache' =&gt; false),

       // ... but we cache the "view" action of this ArticleController
       '^/article/view/' =&gt; array(
           'cache' =&gt; true,

           // and we cache even there are some variables in $_POST
           'cache_with_post_variables' =&gt; true,

           // but the cache will be dependent on the $_POST array
           'make_id_with_post_variables' =&gt; true
       )
   )
);

$backendOptions = array(
    'cache_dir' =&gt; '/tmp/'
);

// getting a Zend_Cache_Frontend_Page object
$cache = Zend_Cache::factory('Page',
                             'File',
                             $frontendOptions,
                             $backendOptions);

$cache-&gt;start();
// if the cache is hit, the result is sent to the browser and the
// script stop here

// [...] the end of the bootstrap file
// these lines won't be executed if the cache is hit
</pre>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.page.cancel"></a>The Specific Cancel Method</h4></div></div></div>
            

            <p>
                Because of design issues, in some cases (for example when using non
                <acronym class="acronym">HTTP</acronym> 200 return codes), you could need to cancel the current
                cache process. So we introduce for this particular frontend, the
                <code class="methodname">cancel()</code> method.
            </p>

            <pre class="programlisting">
// [...] // require, configuration and factory

$cache-&gt;start();

// [...]

if ($someTest) {
    $cache-&gt;cancel();
    // [...]
}

// [...]
</pre>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.capture"></a>Zend_Cache_Frontend_Capture</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.capture.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Capture</code> is like
                <code class="classname">Zend_Cache_Frontend_Output</code> but designed for a complete page.
                It's impossible to use <code class="classname">Zend_Cache_Frontend_Capture</code> for
                caching only a single block. This class is specifically designed to operate in
                concert only with the <code class="classname">Zend_Cache_Backend_Static</code> backend to
                assist in caching entire pages of <acronym class="acronym">HTML</acronym> / <acronym class="acronym">XML</acronym>
                or other content to a physical static file on the local filesystem.
            </p>

            <p>
                Please refer to the documentation on
                <code class="classname">Zend_Cache_Backend_Static</code> for all use cases pertaining to
                this class.
            </p>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/assets/manual/img/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    This frontend operates by registering a callback function to be called
                    when the output buffering it uses is cleaned. In order for this to operate
                    correctly, it must be the final output buffer in the request. To guarantee
                    this, the output buffering used by the Dispatcher <span class="emphasis"><em>must</em></span> be
                    disabled by calling <code class="classname">Zend_Controller_Front</code>'s
                    <code class="methodname">setParam()</code> method, for example,
                    <span class="command"><strong>$front-&gt;setParam('disableOutputBuffering', true);</strong></span> or adding
                    "resources.frontcontroller.params.disableOutputBuffering = true"
                    to your bootstrap configuration file (assumed <acronym class="acronym">INI</acronym>) if using
                    <code class="classname">Zend_Application</code>.
                </p>
            </td></tr>
</table></div>
        </div>
     </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.cache.theory.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.cache.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.cache.backends.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">The Theory of Caching </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Zend_Cache Backends</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
