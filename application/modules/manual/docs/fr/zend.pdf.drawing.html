<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Dessiner</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.pdf.html" title="Zend_Pdf">
<link rel="prev" href="zend.pdf.pages.html" title="Les pages d'un document">
<link rel="next" href="zend.pdf.interactive-features.html" title="Interactive Features">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Dessiner</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.pdf.pages.html">Précédent</a> </td>
<th width="60%" align="center">Zend_Pdf</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.pdf.interactive-features.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.pdf.drawing"></a>Dessiner</h2></div></div></div>
    

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.geometry"></a>Géométrie</h3></div></div></div>
        

        <p>
            Le format <acronym class="acronym">PDF</acronym> utilise la même géométrie que le format PostScript. Elle démarre
            d'en bas à gauche et est mesuré en points (1/72 inch soit 0,352778 mm).
        </p>

        <p>La taille d'une page peut-être récupéré depuis un objet page :</p>

        <p>
            </p>
<pre class="programlisting">
$width  = $pdfPage-&gt;getWidth();
$height = $pdfPage-&gt;getHeight();
</pre>
        </div>

        <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.color"></a>Couleurs</h3></div></div></div>
            

        <p>
            Le format <acronym class="acronym">PDF</acronym> a d'excellentes capacités dans la représentation des couleurs. Le
            module <code class="classname">Zend_Pdf</code> supporte les espaces de couleur : niveaux de
            gris, RGB et CMJN. Chacun d'entre eux peut-être utilisé à chaque fois qu'un objet
            <code class="classname">Zend_Pdf_Color</code> est requis. Les classes
            <code class="classname">Zend_Pdf_Color_GrayScale</code>,
            <code class="classname">Zend_Pdf_Color_RGB</code> et <code class="classname">Zend_Pdf_Color_CMYK</code>
            fournissent cette fonctionnalité :
        </p>

        <pre class="programlisting">
// $grayLevel (float). 0.0 (noir) - 1.0 (blanc)
$color1 = new Zend_Pdf_Color_GrayScale($grayLevel);

// $r, $g, $b (float).
// 0.0 (intensité mimimum) - 1.0 (intensité maximum)
$color2 = new Zend_Pdf_Color_RGB($r, $g, $b);

// $c, $m, $y, $k (float).
// 0.0 (intensité mimimum) - 1.0 (intensité maximum)
$color3 = new Zend_Pdf_Color_CMYK($c, $m, $y, $k);
</pre>

        <p>
            Les différentes couleurs HTML sont aussi fourni avec la classe
            <code class="classname">Zend_Pdf_Color_Html</code> :
        </p>

        <pre class="programlisting">
$color1 = new Zend_Pdf_Color_Html('#3366FF');
$color2 = new Zend_Pdf_Color_Html('silver');
$color3 = new Zend_Pdf_Color_Html('forestgreen');
</pre>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.shape-drawing"></a>Dessiner des formes</h3></div></div></div>
        

        <p>
            Toutes les opérations de dessins peuvent être réalisées dans le contexte d'une
            page <acronym class="acronym">PDF</acronym>.
        </p>

        <p>
            La classe <code class="classname">Zend_Pdf_Page</code> fournit les outils de dessins
            :
        </p>

        <p>
            </p>
<pre class="programlisting">
/**
 * Dessine une ligne de x1,y1 à x2,y2.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @return Zend_Pdf_Page
 */
public function drawLine($x1, $y1, $x2, $y2);
</pre>

         <pre class="programlisting">
 /**
 * Draw a rounded rectangle.
 *
 * Fill types:
 * Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE - fill rectangle
                                               and stroke (default)
 * Zend_Pdf_Page::SHAPE_DRAW_STROKE      - stroke rectangle
 * Zend_Pdf_Page::SHAPE_DRAW_FILL        - fill rectangle
 *
 * radius is an integer representing radius of the four corners, or an array
 * of four integers representing the radius starting at top left, going
 * clockwise
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param integer|array $radius
 * @param integer $fillType
 * @return Zend_Pdf_Page
 */
public function drawRoundedRectangle($x1, $y1, $x2, $y2, $radius,
                       $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Dessine un rectangle.
 *
 * Type de remplissage:
 * Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE
 * - remplit le rectangle et dessine le contour (par défaut)
 * Zend_Pdf_Page::SHAPE_DRAW_STROKE
 * - trace uniquement le contour du rectangle
 * Zend_Pdf_Page::SHAPE_DRAW_FILL
 * - remplit le rectangle
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @return Zend_Pdf_Page
 * @param integer $fillType
 * @return Zend_Pdf_Page
 */
public function drawRectangle(
    $x1, $y1, $x2, $y2, $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Dessine un polygone.
 *
 * Si $fillType est Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE
 * ou Zend_Pdf_Page::SHAPE_DRAW_FILL,
 * le polygone est automatiquement fermé.
 * Regardez la description détaillée de ces méthodes dans la
 * documentation du format PDF
 * (section 4.4.2 Path painting Operators, Filling)
 *
 * @param array $x  - tableau de float (les coordonnés X des sommets)
 * @param array $y  - tableau de float (les coordonnés Y des sommets)
 * @param integer $fillType
 * @param integer $fillMethod
 * @return Zend_Pdf_Page
 */
public function drawPolygon(
    $x, $y,
    $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE,
    $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Dessine un cercle avec comme centre  x, y et comme rayon radius.
 *
 * Les angles sont en radian
 *
 * Signatures des méthodes:
 * drawCircle($x, $y, $radius);
 * drawCircle($x, $y, $radius, $fillType);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle, $fillType);
 *
 *
 * Ce n'est pas réellement un cercle, car le format supporte
 * uniquement des courbe de Bezier cubique.
 * Mais c'est une très bonne approximation.
 * La différence avec un vrai cercle est de au maximum 0.00026 radians
 * (avec les angles PI/8, 3*PI/8, 5*PI/8, 7*PI/8, 9*PI/8, 11*PI/8,
 * 13*PI/8 et 15*PI/8).
 * Avec les angles 0, PI/4, PI/2, 3*PI/4, PI, 5*PI/4, 3*PI/2 et 7*PI/4
 * c'est exactement la tangente d'un cercle.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param mixed $param4
 * @param mixed $param5
 * @param mixed $param6
 * @return Zend_Pdf_Page
 */
public function drawCircle(
    $x, $y, $radius, $param4 = null, $param5 = null, $param6 = null);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Dessine une ellipse dans le rectangle spécifié.
 *
 * Signatures des méthodes:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $fillType);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle, $fillType);
 *
 * Les angles sont en radians
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param mixed $param5
 * @param mixed $param6
 * @param mixed $param7
 * @return Zend_Pdf_Page
 */
public function drawEllipse(
    $x1, $y1, $x2, $y2, $param5 = null, $param6 = null, $param7 = null);
</pre>
        </div>

        <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.text-drawing"></a>Dessiner du texte</h3></div></div></div>
            

        <p>
            Les opérations de dessins existent bien sûr dans le contexte d'une page
            <acronym class="acronym">PDF</acronym>. Vous pouvez dessiner une seule ligne de texte à n'importe quel
            endroit dans la page en fournissant les coordonnées x et y de la ligne de base. La
            police courant ainsi que sa taille et la couleur de remplissage seront utilisées pour
            le dessin (voir la description ci-dessous).
        </p>

        <p>
            </p>
<pre class="programlisting">
/**
 * Dessine une ligne de texte à la position x,y.
 *
 * @param string $text
 * @param float $x
 * @param float $y
 * @param string $charEncoding (optionnel) encodage des caractères du texte.
 * Par défaut le réglage système est utilisé.
 * @throws Zend_Pdf_Exception
 * @return Zend_Pdf_Page
 */
public function drawText($text, $x, $y, $charEncoding = '');
</pre>

        <div class="example">
<a name="zend.pdf.drawing.text-drawing.example-1"></a><p class="title"><b>Exemple 638. Dessiner une ligne dans la page</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
$pdfPage-&gt;drawText('Bonjour le monde!', 72, 720);
...
</pre>
        </div>
</div>
<br class="example-break">

        <div class="example">
<a name="zend.pdf.drawing.text-drawing.example-2"></a><p class="title"><b>Exemple 639. Régler la couleur du texte</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
$pdfPage-&gt;setFillColor(Zend_Pdf_Color_Html::color('#990000'))
        -&gt;drawText('Bonjour le monde (en rouge) !', 72, 720);
....
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Par défaut, les chaînes de texte sont interprétées en utilisant l'encodage du
            système. Si vous avez une chaîne qui utilise un encodage différent (comme les chaînes
            UTF-8 lues depuis une fichier sur le disque, ou une chaîne MacRoman obtenue depuis une
            base de données), vous pouvez indiquer l'encodage au moment du dessin et Zend_Pdf gérera
            la conversion pour vous. Vous pouvez fournir des chaînes dans n'importe quel encodage
            supporté par la fonction <a class="ulink" href="http://www.php.net/manual/function.iconv.php" target="_top">iconv()</a> de <acronym class="acronym">PHP</acronym>:
        </p>

        <div class="example">
<a name="zend.pdf.drawing.text-drawing.example-3"></a><p class="title"><b>Exemple 640. Dessiner une chaîne UTF-8 sur une page</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
// Lit une chaîne UTF-8 à partir du disque
$unicodeString = fread($fp, 1024);

// Dessine une chaîne dans la page
$pdfPage-&gt;drawText($unicodeString, 72, 720, 'UTF-8');
...
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.using-fonts"></a>Utiliser des polices de caractères</h3></div></div></div>
        

        <p>
            <code class="methodname">Zend_Pdf_Page::drawText()</code> utilise la police courante ainsi
            que sa taille, qui sont définies avec la méthode
            <code class="methodname">Zend_Pdf_Page::setFont()</code> :
        </p>

        <p>
            </p>
<pre class="programlisting">
/**
 * Choisit la police courante.
 *
 * @param Zend_Pdf_Resource_Font $font
 * @param float $fontSize
 * @return Zend_Pdf_Page
 */
public function setFont(Zend_Pdf_Resource_Font $font, $fontSize);
</pre>

        <p>
            Les documents <acronym class="acronym">PDF</acronym> supportent PostScript Type 1 et les polices TrueType, mais
            également deux types spécifiques <acronym class="acronym">PDF</acronym>, Type3 et les polices composites. Il y a aussi 14
            polices Type 1 standard intégré dans tout lecteur de <acronym class="acronym">PDF</acronym> : Courier (4 styles), Helvetica
            (4 styles), Times (4 styles), Symbol, et Zapf Dingbats.
        </p>

        <p>
            Zend_Pdf supporte actuellement les 14 polices standard mais également vos propres
            police TrueType. Les objets de police obtenus via une des deux fabriques méthodes :
            <code class="methodname">Zend_Pdf_Font::fontWithName($fontName)</code> pour les 14 polices <acronym class="acronym">PDF</acronym>
            standard ou <code class="methodname">Zend_Pdf_Font::fontWithPath($filePath)</code> pour les
            polices personnalisées.
        </p>

        <div class="example">
<a name="zend.pdf.drawing.using-fonts.example-1"></a><p class="title"><b>Exemple 641. Créer une police standard</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
// Crée une nouvelle police
$font = Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_HELVETICA);

// Applique la police
$pdfPage-&gt;setFont($font, 36);
...
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Les constantes pour les 14 polices standard sont définis dans la classe
            <code class="classname">Zend_Pdf_Font</code> : </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_COURIER</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_COURIER_BOLD</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_COURIER_ITALIC</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_COURIER_BOLD_ITALIC</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_TIMES</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_TIMES_BOLD</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_TIMES_ITALIC</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_TIMES_BOLD_ITALIC</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_HELVETICA</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_HELVETICA_BOLD</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_HELVETICA_ITALIC</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_HELVETICA_BOLD_ITALIC</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_SYMBOL</p>
                    </li>
<li class="listitem">
                        <p>Zend_Pdf_Font::FONT_ZAPFDINGBATS</p>
                    </li>
</ul></div>
<p>
            </p>

        <p>
            Vous pouvez aussi prendre n'importe quelle police TrueType (extension habituelle
            ".ttf") ou OpenType (".otf") si elles ont une silhouette TrueType. Pour l'instant non
            supportée, les polices Mac Os X ".dfont" et les collections TrueType Microsoft (".ttc")
            seront intégrées dans une version future.
        </p>

        <p>
            Pour utiliser une police TrueType, vous devez fournir le chemin de fichier complet
            vers cette police. Si la police ne peut pas être lue pour une quelconque raison, ou si
            ce n'est pas une police TrueType, la méthode lèvera une exception :
        </p>

        <div class="example">
<a name="zend.pdf.drawing.using-fonts.example-2"></a><p class="title"><b>Exemple 642. Créer une police TrueType</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
// Crée la nouvelle police
$goodDogCoolFont = Zend_Pdf_Font::fontWithPath('/chemin/vers/GOODDC__.TTF');

// Applique cette police
$pdfPage-&gt;setFont($goodDogCoolFont, 36);
...
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Par défaut, les polices personnalisées seront incorporées dans le document <acronym class="acronym">PDF</acronym>
            résultant. Cela permet aux destinataires de voir la page comme prévu, même s'ils ne font
            pas installer les polices appropriées sur leur système. En cas de problème avec la
            taille du fichier généré, vous pouvez demander que la police ne soit pas incorporé en
            passant l'option 'ne pas inclure' à la méthode de création :
        </p>

        <div class="example">
<a name="zend.pdf.drawing.using-fonts.example-3"></a><p class="title"><b>Exemple 643. Créer une police TrueType sans l'incorporer dans le document PDF</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
// Crée la nouvelle police
$goodDogCoolFont =
    Zend_Pdf_Font::fontWithPath('/chemin/vers/GOODDC__.TTF',
                                Zend_Pdf_Font::EMBED_DONT_EMBED);

// Applique cette police
$pdfPage-&gt;setFont($goodDogCoolFont, 36);
...
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Si les polices ne sont pas incorporées mais que le destinataire du fichier <acronym class="acronym">PDF</acronym> a
            ces polices installées sur son système, il verra le document comme prévu. Si la police
            correcte n'est pas installée, l'application de visualisation du <acronym class="acronym">PDF</acronym> fera de son mieux
            pour synthétiser une police de remplacement.
        </p>

        <p>
            Quelques polices ont les règles de licence très spécifiques qui les empêchent
            d'être incorporées dans des documents <acronym class="acronym">PDF</acronym>. Donc vous devez faire attention, si vous
            essayez d'utiliser une police qui ne peut pas être incorporée, la méthode de création
            lèvera une exception.
        </p>

        <p>
            Vous pouvez toujours utiliser ces polices, mais vous devez passer le paramètre 'ne
            pas inclure' comme décrit ci-dessous, ou vous pouvez simplement bloquer l'exception
            :
        </p>

        <div class="example">
<a name="zend.pdf.drawing.using-fonts.example-4"></a><p class="title"><b>Exemple 644. Ne pas lever d'exception pour les polices ne pouvant être incorporées</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
$font =
    Zend_Pdf_Font::fontWithPath('/chemin/vers/PoliceNonIncorporable.ttf',
                                Zend_Pdf_Font::EMBED_SUPPRESS_EMBED_EXCEPTION);
...
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Cette technique de suppression est préférée si vous permettez aux utilisateurs de
            choisir leurs propres polices. Les polices qui peuvent être incorporées dans le document
            <acronym class="acronym">PDF</acronym> le seront ; les autres ne le seront pas.
        </p>

        <p>
            Les fichiers de police peuvent être assez grands, certains peuvent atteindre des
            dizaines de méga-octets. Par défaut, toutes les polices incorporées sont comprimées en
            utilisant le schéma de compression Flate, ayant pour résultat un gain d'espace de 50% en
            moyenne. Si, pour une quelconque raison, vous ne voulez pas comprimer la police, vous
            pouvez le neutraliser avec une option :
        </p>

        <div class="example">
<a name="zend.pdf.drawing.using-fonts.example-5"></a><p class="title"><b>Exemple 645. Ne pas compresser une police incorporée</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
$font =
    Zend_Pdf_Font::fontWithPath('/chemin/vers/PoliceDeGrandeTaille.ttf',
                                Zend_Pdf_Font::EMBED_DONT_COMPRESS);
...
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            En conclusion, si nécessaire, vous pouvez combiner les options d'incorporation en
            employant l'opérateur binaire OR :
        </p>

        <div class="example">
<a name="zend.pdf.drawing.using-fonts.example-6"></a><p class="title"><b>Exemple 646. Combiner les options de polices incorporées</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
$font = Zend_Pdf_Font::fontWithPath(
    $cheminVersPoliceQuelconque,
    (Zend_Pdf_Font::EMBED_SUPPRESS_EMBED_EXCEPTION |
     Zend_Pdf_Font::EMBED_DONT_COMPRESS));
...
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.standard-fonts-limitations"></a>Limitations des polices standard PDF</h3></div></div></div>
        

        <p>
            Les polices standard <acronym class="acronym">PDF</acronym> emploient en interne plusieurs encodages sur un seul
            octet (voir <a class="ulink" href="http://www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf" target="_top">PDF Reference,
            Sixth Edition, version 1.7</a> - Annexe D pour plus de détails). Elles sont
            généralement avec un jeu de caractère de type Latin1(excepté les polices Symbol and
            ZapfDingbats).
        </p>

        <p>
            <code class="classname">Zend_Pdf</code> utilise l'encodage CP1252 (WinLatin1) pour tracer
            les textes avec les polices standard.
        </p>

        <p>
            Le texte peut encore être fourni dans n'importe quel autre encodage, qui doit être
            spécifié s'il diffère de celui en cours. Seulement les caractères WinLatin1 seront
            tracés réellement.
        </p>

        <div class="example">
<a name="zend.pdf.drawing.using-fonts.example-7"></a><p class="title"><b>Exemple 647. Combiner les options de polices embarqués</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
$font = Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_COURIER);
$pdfPage-&gt;setFont($font, 36)
        -&gt;drawText('Euro sign - €', 72, 720, 'UTF-8')
        -&gt;drawText('Text with umlauts - à è ì', 72, 650, 'UTF-8');
...
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.extracting-fonts"></a>Extraction des polices</h3></div></div></div>
        

        <p>
            Depuis la version 1.5, <code class="classname">Zend_Pdf</code> fournit la possibilité
            d'extraire les polices des documents chargés.
        </p>

        <p>
            Ceci peut être utile lors des mises à jour de document avec ajout de texte. Sans
            cette fonctionnalité vous devez attacher et probablement intégrer la police dans le
            document chaque fois que vous voulez le mettre à jour.
        </p>

        <p>
            Les objets <code class="classname">Zend_Pdf</code> et <code class="classname">Zend_Pdf_Page</code>
            fournissent une méthode spéciale pour extraire toutes les polices mentionnés à
            l'intérieur d'un document ou d'une page :
        </p>

        <div class="example">
<a name="zend.pdf.drawing.extracting-fonts.example-1"></a><p class="title"><b>Exemple 648. Extraction de polices à partir d'un document chargé</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
$pdf = Zend_Pdf::load($cheminVersDocument);
...
// Récupère toutes les polices du document
$listePolice = $pdf-&gt;extractFonts();
$pdf-&gt;pages[] = ($page = $pdf-&gt;newPage(Zend_Pdf_Page::SIZE_A4));
$yPosition = 700;
foreach ($listePolice as $police) {
    $page-&gt;setFont($police, 15);
    $page-&gt;drawText(
        $police-&gt;getFontName(Zend_Pdf_Font::NAME_POSTSCRIPT, 'fr', 'UTF-8')
      . ': Le renard brun rapide saute par-dessus le chien paresseux',
        100,
        $yPosition,
        'UTF-8');
    $yPosition -= 30;
}
...
// Récupère toutes les polices référencées dans la première page du document
$firstPage = reset($pdf-&gt;pages);
$firstPageFonts = $firstPage-&gt;extractFonts();
...
</pre>
        </div>
</div>
<br class="example-break">

        <div class="example">
<a name="zend.pdf.drawing.extracting-fonts.example-2"></a><p class="title"><b>Exemple 649. Extraction d'une police à partir d'un document chargé en spécifiant le nom de
            police</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
$pdf = new Zend_Pdf();
...
$pdf-&gt;pages[] = ($page = $pdf-&gt;newPage(Zend_Pdf_Page::SIZE_A4));

$police = Zend_Pdf_Font::fontWithPath($cheminVersPolices);
$page-&gt;setFont($police, $taillePolice);
$page-&gt;drawText($texte, $x, $y);
...
// Ce nom de police peut être stocké quelquepart...
$fontName = $font-&gt;getFontName(Zend_Pdf_Font::NAME_POSTSCRIPT, 'fr', 'UTF-8');
...
$pdf-&gt;save($cheminVersDocument);
...
</pre>

            <pre class="programlisting">
...
$pdf = Zend_Pdf::load($cheminVersDocument);
...
$pdf-&gt;pages[] = ($page = $pdf-&gt;newPage(Zend_Pdf_Page::SIZE_A4));

$police = $pdf-&gt;extractFont($nomPolice);
/* $pageSource-&gt;extractFont($nomPolice) peut aussi être utilisé ici */
$page-&gt;setFont($police, $taillePolice);
$page-&gt;drawText($texte, $x, $y);
...
$pdf-&gt;save($cheminVersDocument, true /* mise à jour de type incrémental */);
...
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Les polices extraites peuvent être utilisées à la place de n'importe quelle autre
            police avec les limitations suivantes : </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        La police extraite peut être employée seulement dans le cadre du
                        document à partir duquel elle a été extraite.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Les possibles programmes de polices incorporées ne sont pas extraits
                        réellement. La police ainsi extraite ne peut pas fournir la métrique
                        correcte de police et la police originale doit être utilisée pour les
                        calculs de largeur des textes : </p>
<pre class="programlisting">
...
$police = $pdf-&gt;extractFont($fontName);
$policeOriginal = Zend_Pdf_Font::fontWithPath($cheminVersPolices);

/* utilisation d'une police extraite */
$page-&gt;setFont($police, $taillePolice);
$xPosition = $x;
for ($charIndex = 0; $charIndex &lt; strlen($text); $charIndex++) {
    $page-&gt;drawText($text[$charIndex], $xPosition, $y);

    // Use original font for text width calculation
    $width = $originalFont-&gt;widthForGlyph(
                $originalFont-&gt;glyphNumberForCharacter($text[$charIndex])
             );
    $xPosition += $width / $originalFont-&gt;getUnitsPerEm() * $taillePolice;
}
...
</pre>
                    </li>
</ul></div>
<p>
            </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.image-drawing"></a>Insertion d'images</h3></div></div></div>
        

        <p>
            La classe <code class="classname">Zend_Pdf_Page</code> fournis la méthode
            <code class="methodname">drawImage()</code> pour dessiner une image :
        </p>

        <p>
            </p>
<pre class="programlisting">
/**
 * Insère une image à la position spécifiée dans la page
 *
 * @param Zend_Pdf_Resource_Image $image
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @return Zend_Pdf_Page
 */
public function drawImage(Zend_Pdf_Resource_Image $image, $x1, $y1, $x2, $y2);
</pre>

        <p>
            Les objets Image peuvent être créés avec la méthode
            <code class="methodname">Zend_Pdf_Image::imageWithPath($filePath)</code> (les images JPG, PNG et
            TIFF sont maintenant supportées) :
        </p>

        <div class="example">
<a name="zend.pdf.drawing.image-drawing.example-1"></a><p class="title"><b>Exemple 650. Insertion d'images</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
//Charger une image
$image = Zend_Pdf_Image::imageWithPath('mon_image.jpg');

$pdfPage-&gt;drawImage($image, 100, 100, 400, 300);
...
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            <span class="emphasis"><em>Important ! Le support JPEG nécessite que l'extension <acronym class="acronym">PHP</acronym> GD soit
            installé.</em></span> <span class="emphasis"><em>Important ! Le support PNG nécessite que l'extension ZLIB
            soit configuré pour accepter les images avec canaux Alpha.</em></span>
        </p>

        <p>
            Lisez la documentation de <acronym class="acronym">PHP</acronym> pour plus d'informations (<a class="ulink" href="http://www.php.net/manual/fr/ref.image.php" target="_top">http://www.php.net/manual/fr/ref.image.php</a>
            et <a class="ulink" href="http://www.php.net/manual/fr/ref.zlib.php" target="_top">http://www.php.net/manual/fr/ref.zlib.php</a>).
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.line-drawing-style"></a>Style de lignes</h3></div></div></div>
        

        <p>
            Le style de ligne est définit par l'épaisseur, la couleur et le style de tiret.
            Tout ces paramètres peuvent être assignés par les méthodes de la classe
            <code class="classname">Zend_Pdf_Page</code> :
        </p>

        <p>
            </p>
<pre class="programlisting">
/** Choisit la couleur de ligne. */
public function setLineColor(Zend_Pdf_Color $color);

/** Choisit l'épaisseur de ligne. */
public function setLineWidth(float $width);

/**
 * Choisit le modèle de tiret.
 *
 * modele est un tableau de floats: array(longueur_visible,
 * longueur_invisible, longueur_visible, longueur_invisible,
 * ...)
 * phase est le décalage à partir du début de la ligne.
 *
 * @param array $modele
 * @param array $phase
 * @return Zend_Pdf_Page
 */
public function setLineDashingPattern($pattern, $phase = 0);
</pre>
        </div>

        <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.fill-style"></a>Style de remplissage</h3></div></div></div>
            

        <p>
            Les méthodes <code class="methodname">Zend_Pdf_Page::drawRectangle()</code>,
            <code class="methodname">Zend_Pdf_Page::drawPoligon()</code>,
            <code class="methodname">Zend_Pdf_Page::drawCircle()</code> et
            <code class="methodname">Zend_Pdf_Page::drawEllipse()</code> prennent en argument optionnel le
            type de remplissage: <code class="varname">$fillType</code>. Il peut être :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>Zend_Pdf_Page::SHAPE_DRAW_STROKE - trace le contour de la forme</p>
            </li>
<li class="listitem">
                <p>Zend_Pdf_Page::SHAPE_DRAW_FILL - remplit uniquement la forme</p>
            </li>
<li class="listitem">
                <p>
                    Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE - remplissage et contour (par
                    défaut)
                </p>
            </li>
</ul></div>

        <p>
            La méthode <code class="methodname">Zend_Pdf_Page::drawPoligon()</code> prend aussi
            paramètre supplémentaire <code class="varname">$fillMethod</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING (par
                    défaut)
                </p>

                <p>
                    La <em class="citetitle">référence du format <acronym class="acronym">PDF</acronym></em> décrit la règle comme
                    ceci : </p>
<div class="blockquote"><blockquote class="blockquote">
                        <p>
                            The nonzero winding number rule determines whether a given point
                            is inside a path by conceptually drawing a ray from that point to
                            infinity in any direction and then examining the places where a segment
                            of the path crosses the ray. Starting with a count of 0, the rule adds 1
                            each time a path segment crosses the ray from left to right and
                            subtracts 1 each time a segment crosses from right to left. After
                            counting all the crossings, if the result is 0 then the point is outside
                            the path; otherwise it is inside. Note: The method just described does
                            not specify what to do if a path segment coincides with or is tangent to
                            the chosen ray. Since the direction of the ray is arbitrary, the rule
                            simply chooses a ray that does not encounter such problem intersections.
                            For simple convex paths, the nonzero winding number rule defines the
                            inside and outside as one would intuitively expect. The more interesting
                            cases are those involving complex or self-intersecting paths like the
                            ones shown in Figure 4.10 (in a <acronym class="acronym">PDF</acronym> Reference). For a path consisting of
                            a five-pointed star, drawn with five connected straight line segments
                            intersecting each other, the rule considers the inside to be the entire
                            area enclosed by the star, including the pentagon in the center. For a
                            path composed of two concentric circles, the areas enclosed by both
                            circles are considered to be inside, provided that both are drawn in the
                            same direction. If the circles are drawn in opposite directions, only
                            the "doughnut" shape between them is inside, according to the rule; the
                            "doughnut hole" is outside.
                        </p>
                        </blockquote></div>
<p>
                    </p>
            </li>
<li class="listitem">
                <p>Zend_Pdf_Page::FILL_METHOD_EVEN_ODD</p>

                <p>
                    La <em class="citetitle">référence du format <acronym class="acronym">PDF</acronym></em> décrit la règle comme
                    ceci : </p>
<div class="blockquote"><blockquote class="blockquote">
                        <p>
                            An alternative to the nonzero winding number rule is the even-odd
                            rule. This rule determines the "insideness" of a point by drawing a ray
                            from that point in any direction and simply counting the number of path
                            segments that cross the ray, regardless of direction. If this number is
                            odd, the point is inside; if even, the point is outside. This yields the
                            same results as the nonzero winding number rule for paths with simple
                            shapes, but produces different results for more complex shapes. Figure
                            4.11 (in a <acronym class="acronym">PDF</acronym> Reference) shows the effects of applying the even-odd
                            rule to complex paths. For the five-pointed star, the rule considers the
                            triangular points to be inside the path, but not the pentagon in the
                            center. For the two concentric circles, only the "doughnut" shape
                            between the two circles is considered inside, regardless of the
                            directions in which the circles are drawn.
                        </p>
                        </blockquote></div>
<p>
                    </p>
            </li>
</ul></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.linear-transformations"></a>Transformations linéaires</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.pdf.drawing.linear-transformations.rotations"></a>Rotations</h4></div></div></div>
            

            <p>
                La page <acronym class="acronym">PDF</acronym> page peut être tourné avant d'appliquer toute opération de dessin.
                Ceci peut être fait avec la méthode <code class="methodname">Zend_Pdf_Page::rotate()</code>
                :
            </p>

            <pre class="programlisting">
/**
 * Rotation de la page
 *
 * @param float $x  - la coordonnée X du point de rotation
 * @param float $y  - la coordonnée X du point de rotation
 * @param float $angle - angle de rotation
 * @return Zend_Pdf_Page
 */
public function rotate($x, $y, $angle);
</pre>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.pdf.drawing.linear-transformations.scale"></a>A partir de Zend Framework 1.8, mise à l'échelle</h4></div></div></div>
            

            <p>
                La mise à l'échelle est fournie par la méthode
                <code class="methodname">Zend_Pdf_Page::scale()</code> :
            </p>

            <pre class="programlisting">
/**
 * Mise à l'échelle
 *
 * @param float $xScale - X dimention scale factor
 * @param float $yScale - Y dimention scale factor
 * @return Zend_Pdf_Page
 */
public function scale($xScale, $yScale);
</pre>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.pdf.drawing.linear-transformations.translate"></a>A partir de Zend Framework 1.8, décalage</h4></div></div></div>
            

            <p>
                Le décalage du système de coordonnées est réalisé par la méthode
                <code class="methodname">Zend_Pdf_Page::translate()</code> :
            </p>

            <pre class="programlisting">
/**
 * Décalage du système de coordonnées
 *
 * @param float $xShift - coordonnées X du décalage
 * @param float $yShift - coordonnées Y du décalage
 * @return Zend_Pdf_Page
 */
public function translate($xShift, $yShift);
</pre>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.pdf.drawing.linear-transformations.skew"></a>A partir de Zend Framework 1.8, mise en biais</h4></div></div></div>
            

            <p>
                La mise en biais de la page peut être réalisé par la méthode
                <code class="methodname">Zend_Pdf_Page::skew()</code> :
            </p>

            <pre class="programlisting">
/**
 * Mise en biais du système de coordonnées
 *
 * @param float $x  - the X co-ordinate of axis skew point
 * @param float $y  - the Y co-ordinate of axis skew point
 * @param float $xAngle - X axis skew angle
 * @param float $yAngle - Y axis skew angle
 * @return Zend_Pdf_Page
 */
public function skew($x, $y, $xAngle, $yAngle);
</pre>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.save-restore"></a>Sauvegarder et restaurer l'état graphique</h3></div></div></div>
        

        <p>
            L'état graphique (police courante, taille de caractère, couleur de ligne, couleur
            de remplissage, style de ligne, sens de la page, zone de dessin) peut-être sauvegarder à
            tout moment. L'opération de sauvegarde empile le contexte dans une pile de contexte
            graphique, l'opération de restauration récupère le contexte depuis la pile.
        </p>

        <p>
            Il y a deux méthodes dans la classe <code class="classname">Zend_Pdf_Page</code> pour
            réaliser ces opérations :
        </p>

        <p>
            </p>
<pre class="programlisting">
/**
 * Sauvegarde l'état graphique de la page.
 * Cela prend un instantané des styles courants, des zones de dessins
 * et de toutes les rotations/translations/changements de taille appliqués.
 *
 * @return Zend_Pdf_Page
 */
public function saveGS();

/**
 * Restaure le dernier état graphique sauvegarder avec saveGS().
 *
 * @return Zend_Pdf_Page
 */
public function restoreGS();
</pre>
        </div>

        <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.clipping"></a>Zone de dessin</h3></div></div></div>
            

        <p>
            Le format <acronym class="acronym">PDF</acronym> et le module Zend_Pdf supporte le découpage de la zone de dessin. La
            zone de dessin courante limite la zone de la page affectée par l'utilisation des
            opérateurs de dessins. Initialement c'est toute la page.
        </p>

        <p>
            La classe <code class="classname">Zend_Pdf_Page</code> fournit des méthodes pour les
            opérations de découpage.
        </p>

        <p>
            </p>
<pre class="programlisting">
/**
 * Découpe la zone courante avec un rectangle.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @return Zend_Pdf_Page
 */
public function clipRectangle($x1, $y1, $x2, $y2);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Découpe la zone courante avec un polygone.
 *
 * @param array $x  - tableau de float (les coordonnées X des sommets)
 * @param array $y  - tableau de float (les coordonnées Y des sommets)
 * @param integer $fillMethod
 * @return Zend_Pdf_Page
 */
public function clipPolygon(
    $x, $y, $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Découpe la zone courante avec un cercle.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param float $startAngle
 * @param float $endAngle
 * @return Zend_Pdf_Page
 */
public function clipCircle(
    $x, $y, $radius, $startAngle = null, $endAngle = null);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Découpe la zone courante avec une ellipse.
 *
 * Signatures des méthodes:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 *
 * @todo s'occuper des cas spéciaux avec $x2-$x1 == 0 ou $y2-$y1 == 0
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param float $startAngle
 * @param float $endAngle
 * @return Zend_Pdf_Page
 */
public function clipEllipse(
    $x1, $y1, $x2, $y2, $startAngle = null, $endAngle = null);
</pre>
        </div>

        <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.styles"></a>Styles</h3></div></div></div>
            

        <p>
            La classe <code class="classname">Zend_Pdf_Style</code> fournit les fonctionnalités de
            style.
        </p>

        <p>
            Les styles peuvent être utilisés pour stocker des paramètre d'état graphique et de
            les appliquer à une page <acronym class="acronym">PDF</acronym> en une seule opération :
        </p>

        <p>
            </p>
<pre class="programlisting">
/**
 * Choisit le style à utiliser pour les futures opérations
 * de dessin sur cette page
 *
 * @param Zend_Pdf_Style $style
 * @return Zend_Pdf_Page
 */
public function setStyle(Zend_Pdf_Style $style);

/**
 * Renvoie le style appliqué à la page.
 *
 * @return Zend_Pdf_Style|null
 */
public function getStyle();
</pre>

        <p>
            La classe <code class="classname">Zend_Pdf_Style</code> fournit des méthodes pour choisir
            ou récupérer différents paramètres de l'état graphique :
        </p>

        <p>
            </p>
<pre class="programlisting">
/**
 * Choisit la couleur de ligne.
 *
 * @param Zend_Pdf_Color $color
 * @return Zend_Pdf_Page
 */
public function setLineColor(Zend_Pdf_Color $color);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Récupère la couleur de ligne.
 *
 * @return Zend_Pdf_Color|null
 * @return Zend_Pdf_Page
 */
public function getLineColor();
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Choisit l'épaisseur de ligne.
 *
 * @param float $width
 * @return Zend_Pdf_Page
 */
public function setLineWidth($width);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Récupère l'épaisseur de ligne.
 *
 * @return float
 * @return Zend_Pdf_Page
 */
public function getLineWidth($width);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Choisit le style de tiret
 *
 * @param array $pattern
 * @param float $phase
 * @return Zend_Pdf_Page
 */
public function setLineDashingPattern($pattern, $phase = 0);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Récupère le style de tiret
 *
 * @return array
 */
public function getLineDashingPattern();
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Récupère le modèle de tiret
 *
 * @return float
 */
public function getLineDashingPhase();
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Choisit la couleur de remplissage.
 *
 * @param Zend_Pdf_Color $color
 * @return Zend_Pdf_Page
 */
public function setFillColor(Zend_Pdf_Color $color);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Récupère la couleur de remplissage.
 *
 * @return Zend_Pdf_Color|null
 */
public function getFillColor();
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Choisit la police.
 *
 * @param Zend_Pdf_Font $font
 * @param Zend_Pdf_Resource_Font $font
 * @param float $fontSize
 */
public function setFont(Zend_Pdf_Resource_Font $font, $fontSize);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Modifie la taille de police.
 *
 * @param float $fontSize
 * @return Zend_Pdf_Page
 */
public function setFontSize($fontSize);
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Récupère la police courante
 *
 * @return Zend_Pdf_Resource_Font $font
 */
public function getFont();
</pre>

        <p>
            </p>
<pre class="programlisting">
/**
 * Récupère la taille de la police
 *
 * @return float $fontSize
 */
public function getFontSize();
</pre>
        </div>

        <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.pdf.drawing.alpha"></a>Transparence</h3></div></div></div>
            

        <p>
            Le module <code class="classname">Zend_Pdf</code> supporte la gestion de la
            transparence.
        </p>

        <p>
            La transparence peut être paramétré en utilisant la méthode
            <code class="methodname">Zend_Pdf_Page::setAlpha()</code> : </p>
<pre class="programlisting">
/**
 * Règle la transparence
 *
 * $alpha == 0  - transparent
 * $alpha == 1  - opaque
 *
 * Transparency modes, supported by PDF:
 * Normal (default), Multiply, Screen, Overlay, Darken,
 * Lighten, ColorDodge, ColorBurn, HardLight,
 * SoftLight, Difference, Exclusion
 *
 * @param float $alpha
 * @param string $mode
 * @throws Zend_Pdf_Exception
 * @return Zend_Pdf_Page
 */
public function setAlpha($alpha, $mode = 'Normal');
</pre>
        </div>
    </div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.pdf.pages.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.pdf.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.pdf.interactive-features.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Les pages d'un document </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Interactive Features</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
