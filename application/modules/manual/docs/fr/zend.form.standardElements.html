<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Les éléments standards fournis avec Zend Framework</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.form.html" title="Zend_Form">
<link rel="prev" href="zend.form.decorators.html" title="Créer un visuel personnalisé en utilisant Zend_Form_Decorator">
<link rel="next" href="zend.form.standardDecorators.html" title="Décorateurs standards fournis avec Zend Framework">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Les éléments standards fournis avec Zend Framework</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.form.decorators.html">Précédent</a> </td>
<th width="60%" align="center">Zend_Form</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.form.standardDecorators.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.form.standardElements"></a>Les éléments standards fournis avec Zend Framework</h2></div></div></div>
    
    <p>
        Zend Framework est fournis avec des classes d'éléments couvrant la
        plupart des éléments de formulaire HTML. La plupart spécifie un helper de
        vue en particulier à utiliser pour décorer un élément, mais plusieurs
        d'entre elles offrent des fonctionnalités supplémentaires. Ce qui suit est
        une liste de toutes ces classes, ainsi que des descriptions des
        fonctionnalités offertes.
    </p>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.button"></a>Zend_Form_Element_Button</h3></div></div></div>
        
        <p>
            Utilisé pour créer des éléments boutons,
            <code class="classname">Zend_Form_Element_Button</code> étend <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.submit" title="Zend_Form_Element_Submit">Zend_Form_Element_Submit</a>,
            spécifie quelques fonctionnalités personnalisées. Il spécifie le
            helper de vue 'formButton' pour la décoration.
        </p>
        <p>
            Comme l'élément submit, il utilise le label de l'élément en tant que
            valeur de l'élément lors de l'affichage ; autrement dit, pour définir
            le text du bouton, définissez la valeur de l'élément. Le label sera
            traduit si l'adapteur de traduction est présent.
        </p>
        <p>
            Comme le label est utilisé comme faisant partie de l'élément,
            l'élément bouton utilise seulement <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.viewHelper" title="Zend_Form_Decorator_ViewHelper">ViewHelper</a>
            et les décorateurs <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.dtDdWrapper" title="Zend_Form_Decorator_DtDdWrapper">DtDdWrapper</a>.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.captcha"></a>Zend_Form_Element_Captcha</h3></div></div></div>
        
        <p>
            Les CAPTCHAs sont utilisé pour empêcher la soumission automatique des
            formulaires par des bots et autre processus automatisés.
        </p>
        <p>
            L'élément de formulaire Captcha permet de spécifier quel <a class="link" href="zend.captcha.adapters.html" title="Adaptateurs CAPTCHA">Adapteur Zend_Captcha</a> vous
                désirez utiliser. Il définit ensuite cet adapteur comme
                validateur à l'objet, et utilise le décorateur du Captcha pour
                l'affichage (ce qui fait office de proxy vers l'adapteur CAPTCHA).
        </p>
        <p>
            Les adapteurs peuvent être n'importe quel adapteur de
            <code class="classname">Zend_Captcha</code>, ou n'importe quel adapteur que
            vous avez défini par ailleurs. Pour permettre ceci, vous devrez passer
            une clé supplémentaire de plugin loader, 'CAPTCHA'
            ou 'captcha', lorsque vous spécifiez un prefixe de chemin de plugin loader :
        </p>
        <pre class="programlisting">
$element-&gt;addPrefixPath('My_Captcha', 'My/Captcha/', 'captcha');
</pre>
        <p>
            Le Captcha peut ensuite être enregistré en utilisant la méthode
            <code class="methodname">setCaptcha()</code>, qui prend en paramètre soit
            une instance concrête de CAPTCHA soit le nom court d'un adapteur CAPTCHA :
        </p>
        <pre class="programlisting">
// Instance concrête:
$element-&gt;setCaptcha(new Zend_Captcha_Figlet());
// Utilisation d'un nom court :
$element-&gt;setCaptcha('Dumb');
</pre>
        <p>
            Si vous souhaitez charger votre élément via la configuration, spécifiez soit
            la clé 'captcha' avec un tableau contenant la clé 'captcha', soit les clés
            'captcha' et 'captchaOptions' :
        </p>
        <pre class="programlisting">
// Utilisation d'une clé captcha :
$element = new Zend_Form_Element_Captcha('foo', array(
    'label' =&gt; "Merci de confirmer que vous êtes humain",
    'captcha' =&gt; array(
        'captcha' =&gt; 'Figlet',
        'wordLen' =&gt; 6,
        'timeout' =&gt; 300,
    ),
));
// Utilisation simultanée des clés captcha et captchaOption :
$element = new Zend_Form_Element_Captcha('foo', array(
    'label' =&gt; "Merci de confirmer que vous êtes humain",
    'captcha' =&gt; 'Figlet',
    'captchaOptions' =&gt; array(
        'captcha' =&gt; 'Figlet',
        'wordLen' =&gt; 6,
        'timeout' =&gt; 300,
    ),
));
</pre>
        <p>
            Le décorateur utilisé est déterminé lors de la récupération de l'adapteur
            du captcha. Par défaut, le <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.captcha" title="Zend_Form_Decorator_Captcha"> décorateur
                du captcha</a> est utilisé, mais un adapteur peut spécifier un décorateur
                différent via sa méthode <code class="methodname">getDecorator()</code>.
        </p>
        <p>
            Comme noté, l'adapteur de captcha lui même agit comme un validateur pour
            l'élément. De plus, le validateur NotEmpty n'est pas utilisé, et l'élément
            est marqué comme requis. Dans la plupart des cas, vous n'aurez besoin de
            rien d'autre pour que le captcha soit présent dans votre formulaire.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.checkbox"></a>Zend_Form_Element_Checkbox</h3></div></div></div>
        
        <p>
            Les cases à cocher HTML vous permettent de retourner une valeur spécifique,
            mais elles fonctionnent essentiellement comme des booléens. Lorsque elle
            est cochée, la valeur de la case à cocher est soumise. Lorsque la case à
            cocher n'est pas cochée, rien n'est soumis. En interne,
            <code class="classname">Zend_Form_Element_Checkbox</code> applique cet état.
        </p>
        <p>
            Par défaut, la valeur cochée est '1', et la valeur non cochée est '0'.
            Vous pouvez spécifier les valeurs en utilisant respectivement les accesseurs
            <code class="methodname">setCheckedValue()</code>
            et <code class="methodname">setUncheckedValue()</code>. En interne, à chaque fois que
            vous définissez une valeur, si la valeur fournie correspond à la valeur cochée,
            alors elle sera définie, mais toutes autres valeurs aura pour effet que la valeur
            non cochée sera sélectionnée.
        </p>
        <p>
            En sus, définir la valeur définit la propriété <code class="code">checked</code>
            de la case à cocher. Vous pouvez la récupérer en utilisant
            <code class="methodname">isChecked()</code> ou simplement en accédant à la propriété.
            Utiliser la méthode <code class="methodname">setChecked($flag)</code> l'état du flag
            ainsi que la valeur cochée ou non cochée de l'élément.
            Veillez à utiliser cette méthode lorsque vous définissez l'état coché d'un élément
            case à cocher afin d'être sûr que la valeur est correctement définie.
        </p>
        <p>
            <code class="classname">Zend_Form_Element_Checkbox</code> utilise le helper de vue
            'formCheckbox'. La valeur cochée est toujours utilisé pour le remplir.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.file"></a>Zend_Form_Element_File</h3></div></div></div>
        
        <p>
            L'élément de formulaire File fournit un mécanisme pour fournir des champs
            d'upload de fichier à votre formulaire. Il utilise <a class="link" href="zend.file.transfer.introduction.html" title="Zend_File_Transfer">Zend_File_Transfer</a>
            en interne pour fournir cette fonctionnalité et le helper de vue
            <code class="code">FormFile</code> ainsi que le décorateur <code class="code">File</code>
            pour afficher l'élément de formulaire.
        </p>
        <p>
            Par défaut, il utilise l'adapteur de transfert<code class="code">Http</code> qui
            inspecte le tableau <code class="varname">$_FILES</code> et vous permet d'attacher
            des validateurs et des filtres. Les validateurs et les filtres attachés
            au formulaire sont à leur tour attachés à l'adapteur de transfert.
        </p>
        <div class="example">
<a name="zend.form.standardElements.file.usage"></a><p class="title"><b>Exemple 445. Utilisation de l'élément de formulaire File</b></p>
<div class="example-contents">
            
            <p>
                L'explication d'utilisation de l'élément de formulaire File ci-dessous
                peut sembler ésotérique, mais l'usage est en fait relativement trivial :
            </p>
            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Upload une image:')
        -&gt;setDestination('/var/www/upload');
// Fait en sorte qu'il y ait un seul fichier
$element-&gt;addValidator('Count', false, 1);
// limite à 100K
$element-&gt;addValidator('Size', false, 102400);
// seulement des JPEG, PNG, et GIFs
$element-&gt;addValidator('Extension', false, 'jpg,png,gif');
$form-&gt;addElement($element, 'foo');
</pre>
            <p>
                Vous devez aussi vous assurer que le type d'encodage correct est fourni au
                formulaire ; vous devez utiliser 'multipart/form-data'. Vous pouvez faire
                cela en définissant l'attribut 'enctype' du formulaire:
            </p>
            <pre class="programlisting">
$form-&gt;setAttrib('enctype', 'multipart/form-data');
</pre>
            <p>
                Après que le formulaire soit validé avec succès, vous devriez recevoir
                le fichier afin de le stocker dans sa destination finale en utilisant
                <code class="methodname">receive()</code>.
                De plus, vous pouvez déterminer son emplacement finale en utilisant
                <code class="methodname">getFileName()</code>:
            </p>
            <pre class="programlisting">
if (!$form-&gt;isValid()) {
    print "Uh oh... erreur de validation";
}
if (!$form-&gt;foo-&gt;receive()) {
    print "Erreur de réception de fichier";
}
$location = $form-&gt;foo-&gt;getFileName();
</pre>
        </div>
</div>
<br class="example-break">
        <div class="note"><table border="0" summary="Note: Emplacement d'upload par défaut">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Emplacement d'upload par défaut</th>
</tr>
<tr><td align="left" valign="top">
            
            <p>
                Par défaut, les fichiers sont uploadés dans le répertoire temp
                du système.
            </p>
        </td></tr>
</table></div>
        <div class="note"><table border="0" summary="Note: Valeur de fichier">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Valeur de fichier</th>
</tr>
<tr><td align="left" valign="top">
            
            <p>
                Au sein du <acronym class="acronym">HTTP</acronym> un élément fichier n'a aucune valeur.
                Pour cette raison et pour des raisons de sécurité
                <code class="methodname">getValue()</code> retourne seulement le nom du fichier
                uploadé et non le chemin complet. Si vous avez besoin du chemin du fichier,
                appellez <code class="methodname">getFileName()</code>, qui retourne à la fois le
                chemin et le nom du fichier.
            </p>
        </td></tr>
</table></div>
        <p>
            Par défaut, le fichier sera automatiquement reçu quand vous appellerez
            <code class="methodname">getValues()</code> sur le formulaire. La raison derrière
            ce comportement est que le fichier lui même est la valeur de l'élément fichier.
        </p>
        <pre class="programlisting">
$form-&gt;getValues();
</pre>
        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Ainsi, un appel supplémentaire de <code class="methodname">receive()</code> après avoir
                appellé <code class="methodname">getValues()</code> n'aura aucun effet. De même, créer
                une instance de <code class="classname">Zend_File_Transfer</code> n'aura aucun effet non
                plus puisqu'il n'y aura plus de fichier à recevoir.
            </p>
        </td></tr>
</table></div>
        <p>
            Cela dit, parfois vous aurez besoin d'appeller <code class="methodname">getValues()</code> sans
            recevoir le fichier. Vous pouvez l'archiver en appellant
            <code class="methodname">setValueDisabled(true)</code>. Afin de recevoir la véritable valeur de
            ce flag vous pouvez appeller <code class="methodname">isValueDisabled()</code>.
        </p>
        <div class="example">
<a name="zend.form.standardElements.file.retrievement"></a><p class="title"><b>Exemple 446. Récupération explicite de fichier</b></p>
<div class="example-contents">
            
            <p>
                Tout d'abord appellez<code class="methodname">setValueDisabled(true)</code>.
            </p>
            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Uploadez une image:')
        -&gt;setDestination('/var/www/upload')
        -&gt;setValueDisabled(true);
</pre>
            <p>
                Désormais le fichier sera reçu lorsque vous appellerez
                <code class="methodname">getValues()</code>. Donc vous devez appeller vous même
                <code class="methodname">receive()</code> sur l'élément fichier, ou une instance de
                <code class="classname">Zend_File_Transfer</code> .
            </p>
            <pre class="programlisting">
$values = $form-&gt;getValues();
if ($form-&gt;isValid($form-&gt;getPost())) {
    if (!$form-&gt;foo-&gt;receive()) {
        print "Erreur d'upload";
    }
}
</pre>
        </div>
</div>
<br class="example-break">
        <p>
            Il ya plusieurs étapes du fichier uploadés qui peuvent être vérifiées
            avec les méthodes suivantes :
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="methodname">isUploaded()</code> : Vérifie si l'élément fichier
                    a été uploadé ou non.
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">isReceived()</code> : Vérifie si l'élément fichier
                    a déjà été reçu.
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">isFiltered()</code> : Vérifie si les filtres ont
                    déjà été appliqué ou non sur l'élément fichier.
                </p>
            </li>
</ul></div>
        <div class="example">
<a name="zend.form.standardElements.file.isuploaded"></a><p class="title"><b>Exemple 447. Vérifier si un fichier optionnel a été uploadé</b></p>
<div class="example-contents">
            
            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Uploader une image:')
        -&gt;setDestination('/var/www/upload')
        -&gt;setRequired(false);
$element-&gt;addValidator('Size', false, 102400);
$form-&gt;addElement($element, 'foo');
// L'élément fichier foo est optionnel mais quand il est renseigné va là
if ($form-&gt;foo-&gt;isUploaded()) {
    // fichier foo donné, faire quelque chose
}
</pre>
        </div>
</div>
<br class="example-break">
        <p>
            <code class="classname">Zend_Form_Element_File</code> supporte aussi les fichiers multiples.
            En appellant la méthode <code class="methodname">setMultiFile($count)</code> vous pouvez définir,
            le nombre d'éléments fichier à créer. Ceci vous évite de définir les mêmes
            réglages plusieurs fois.
        </p>
        <div class="example">
<a name="zend.form.standardElements.file.multiusage"></a><p class="title"><b>Exemple 448. Définir plusieurs fichiers</b></p>
<div class="example-contents">
            
            <p>
                Créer un élément multifichier est identique à la création d'un élément unique.
                Appellez simplement <code class="methodname">setMultiFile()</code> après que l'élément soit créé:
            </p>
            <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Uploadez une image:')
        -&gt;setDestination('/var/www/upload');
// s'assure qu'il y a un fichier au minimum, 3 au maximum
$element-&gt;addValidator('Count', false, array('min' =&gt; 1, 'max' =&gt; 3));
// Limite à 100K
$element-&gt;addValidator('Size', false, 102400);
// seulement des JPEG, PNG, et des GIF
$element-&gt;addValidator('Extension', false, 'jpg,png,gif');
// définit 3 éléments fichiers identiques
$element-&gt;setMultiFile(3);
$form-&gt;addElement($element, 'foo');
</pre>
            <p>
                Vous avez maintenant 3 éléments d'upload de fichier identiques
                avec les mêmes paramètres. Pour obtenir le nombre de fichiers multiples
                défini, appellez simplement
                <code class="methodname">getMultiFile()</code>.
            </p>
        </div>
</div>
<br class="example-break">
        <div class="note"><table border="0" summary="Note: Eléments de fichier dans un sous formulaire">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Eléments de fichier dans un sous formulaire</th>
</tr>
<tr><td align="left" valign="top">
            
            <p>
                Quand vous l'utilisez dans des sous formulaires, vous devez définir
                des noms uniques.
                Par exemple, si vous nommez un élément fichier "file" dans le subform1,
                vous devez un nom différent à tout autre élément fichier dans subform2.
            </p>
            <p>
                Si il y a deux éléments fichier portant le même nom, le second élément
                n'est pas affiché ou soumis.
            </p>
            <p>
                De plus, les éléments fichiers ne sont pas affichés au sein du sous formulaire.
                Donc lorsque vous ajouter un élément fichier dans un sous formulaire, l'élément
                sera affiché dans le formulaire principal.
            </p>
        </td></tr>
</table></div>
        <p>
            Afin de limiter, vous pouvez spécifier la taille maximum d'un fichier en définissant
            l'option <code class="constant">MAX_FILE_SIZE</code> sur le formulaire. Quand vous définissez
            cette valeur en utilisant la méthode
            <code class="methodname">setMaxFileSize($size)</code>, elle sera affiché avec l'élément
            fichier.
        </p>
        <pre class="programlisting">
$element = new Zend_Form_Element_File('foo');
$element-&gt;setLabel('Uploadez une image:')
        -&gt;setDestination('/var/www/upload')
        -&gt;addValidator('Size', false, 102400) // limit to 100K
        -&gt;setMaxFileSize(102400); // limite la taille de fichier coté client
$form-&gt;addElement($element, 'foo');
</pre>
        <div class="note"><table border="0" summary="Note: MaxFileSize et Eléments fichier multiple">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">MaxFileSize et Eléments fichier multiple</th>
</tr>
<tr><td align="left" valign="top">
            
            <p>
                Quand vous utilisez des éléments fichiers multiples dans votre formulaire
                vous devez définir <code class="constant">MAX_FILE_SIZE</code> seulement une fois.
                La redéfinir écrasera la valeur précédente.
            </p>
            <p>
                Notez que c'est aussi le cas lorsque vous utilisez des formulaires multiples.
            </p>
        </td></tr>
</table></div>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.hidden"></a>Zend_Form_Element_Hidden</h3></div></div></div>
        
        <p>
            Les éléments cachés injectent des données qui doivent être soumises, mais pas manipulées
            par l'utilisateur. <code class="classname">Zend_Form_Element_Hidden</code> remplit cette tâche
            avec le helper de vue 'formHidden'.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.hash"></a>Zend_Form_Element_Hash</h3></div></div></div>
        
        <p>
            Cette élément fournit une proctection contre les attaques CSRF sur les formulaires,
            en s'assurant que les données sont soumises par la session utilisateur qui a
            générée le formulaire et non par un script malveillant. La protection est réalisée
            en ajouté un élément de hachage au formulaire et en le vérifiant lors de la soumission
            du formulaire.
        </p>
        <p>
            Le nom de l'élément de hachage doit être unique. Nous recommandons d'utiliser
            l'option <code class="literal">salt</code> pour l'élément - deux hachages ayant le même nom
            mais des salt différent ne causeront pas de collision :
        </p>
        <pre class="programlisting">
$form-&gt;addElement('hash', 'no_csrf_foo', array('salt' =&gt; 'unique'));
</pre>
        <p>
            Vous pouvez définir le salt ultérieurement en utilisant la méthode
            <code class="methodname">setSalt($salt)</code>.
        </p>
        <p>
            En interne, l'élément stocke un identifiant unique en utilisant
            <code class="classname">Zend_Session_Namespace</code>, et le vérifie lors de la soumission
            (en vérifiant que le TTL n'a pas expiré). Le validateur 'Identical' est ensuite
            utilisé pour s'assurer que le hachage soumis correspond au hachage stocké.
        </p>
        <p>
            Le helper de vue 'formHidden' est utilisé pour rendre l'élément dans le formulaire.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.Image"></a>Zend_Form_Element_Image</h3></div></div></div>
        
        <p>
            Des images peuvent être utilisées comme éléments de formulaires, et vous
            pouvez utiliser ces images en tant qu'éléments graphiques sur les
            boutons de formulaires.
        </p>
        <p>
            Les images ont besoin d'une image source. <code class="classname">Zend_Form_Element_Image</code>
            permet de la spécifier en utilisant l'accesseur <code class="methodname">setImage()</code>
            (ou la clé de configuration 'imageValue'). Quant la valeur définie pour l'élément
            corresponde à <code class="code">imageValue</code>, alors l'accesseur
            <code class="methodname">isChecked()</code> retournera <code class="constant">TRUE</code>.
        </p>
        <p>
            Les éléments image utilise le
            <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.image" title="Zend_Form_Decorator_Image"> décorateur Image
                </a> pour le rendu, en plus des décorateur standard Errors,
            HtmlTag et Label. Vous pouvez spécifier une balise en option au décorateur
            <code class="code">Image</code> qui entourera l'élément image.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.multiCheckbox"></a>Zend_Form_Element_MultiCheckbox</h3></div></div></div>
        
        <p>
            Souvent, vous pouvez avoir un ensemble de case à cocher apparenté, et vous
            souhaitez grouper ces résultat. Cela ressemble beaucoup à <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.multiselect" title="Zend_Form_Element_Multiselect"> Multiselect</a>,
            mais au lieu que ce soit une liste déroulant, vous avez besoin d'afficher
            des paires case à cocher/valeur.
        </p>
        <p>
            <code class="classname">Zend_Form_Element_MultiCheckbox</code> rend cela simple
            comme bonjour. Comme tous les éléments qui étendent l'élément de base Multi,
            vous pouvez spécifier une liste d'options et les valider simplement à l'aide
            de cette même liste. Le helper de vue 'formMultiCheckbox' s'assure qu'elles
            seront retournées dans un tableau lors la soumission du formulaire.
        </p>
        <p>
            Par défaut, cet élément enregistre un validateur <code class="code">InArray</code>
            qui effectue la validation à l'aide des clés du tableau d'options enregistrées.
            Vous pouvez désactiver ce comportement, soit en appellant
            <code class="methodname">setRegisterInArrayValidator(false)</code>, soit en passant
            une valeur <code class="constant">FALSE</code> à la clé de configuration
            <code class="code">registerInArrayValidator</code>.
        </p>
        <p>
            Vous pouvez manipuler les diverses options de case à cocher en utilisant
            les méthodes suivantes :
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="methodname">addMultiOption($option, $value)</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">addMultiOptions(array $options)</code></p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code> (écrase les options
                    existantes)
                </p>
            </li>
<li class="listitem"><p><code class="methodname">getMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">getMultiOptions()</code></p></li>
<li class="listitem"><p><code class="methodname">removeMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">clearMultiOptions()</code></p></li>
</ul></div>
        <p>
            Pour marquer les éléments cochés, vous devez passer un tableau de valeur à
            <code class="methodname">setValue()</code>. Ce qui suit cochera les valeur "bar"
            et "bat":
        </p>
        <pre class="programlisting">
$element = new Zend_Form_Element_MultiCheckbox('foo', array(
    'multiOptions' =&gt; array(
        'foo' =&gt; 'Foo Option',
        'bar' =&gt; 'Bar Option',
        'baz' =&gt; 'Baz Option',
        'bat' =&gt; 'Bat Option',
    )
));
$element-&gt;setValue(array('bar', 'bat'));
</pre>
        <p>
            Notez que même en définissant une valeur unique vous devrez passer un tableau.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.multiselect"></a>Zend_Form_Element_Multiselect</h3></div></div></div>
        
        <p>
            Les éléments <code class="code">select</code> <acronym class="acronym">XHTML</acronym>  autorisent un attribut
            'multiple', indiquant que plusieurs options peuvent être sélectionné pour la soumission
            du formulaire, au lieu d'une seule habituellement.
            <code class="classname">Zend_Form_Element_Multiselect</code> étend
            <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.select" title="Zend_Form_Element_Select">Zend_Form_Element_Select</a>,
            et définit l'attribut <code class="code">multiple</code> à 'multiple'. Comme les autres classes qui
            hétite la classe de base
            <code class="classname">Zend_Form_Element_Multi</code>, vous pouvez manipuler les options
            du select en utilisant :
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="methodname">addMultiOption($option, $value)</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">addMultiOptions(array $options)</code></p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code> (écrase les options
                    existantes)
                </p>
            </li>
<li class="listitem"><p><code class="methodname">getMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">getMultiOptions()</code></p></li>
<li class="listitem"><p><code class="methodname">removeMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">clearMultiOptions()</code></p></li>
</ul></div>
        <p>
            Si un adapteur de traduction est enregistré au niveau du formulaire et/ou
            de l'élément, les valeurs des options seront traduites dans le cadre de
            l'affichage.
        </p>
        <p>
            Par défaut, cette élément utilise un validateur <code class="code">InArray</code>
            qui effectue sa validation à partir des clés de tableau des options enregistrées.
            Vous pouvez désactiver ce comportement, soit en appellant
            <code class="methodname">setRegisterInArrayValidator(false)</code>, ou en passant une valeur
            <code class="constant">FALSE</code> à la clé de configuration
            <code class="code">registerInArrayValidator</code>.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.password"></a>Zend_Form_Element_Password</h3></div></div></div>
        
        <p>
            Les éléments mot de passe sont fondamentalement des éléments texte normaux
            -- à l'exception du fait que vous ne voulez pas que le mot de passe soumis
            soit affiché dans les messages d'erreurs ou lorsque le formulaire est
            affiché à nouveau.
        </p>
        <p>
            <code class="classname">Zend_Form_Element_Password</code> effectue cela en appellant
            <code class="methodname">setObscureValue(true)</code> sur chaque validateur (s'assurant
            ainsi que le mot de passe est dissimulé dans les messages d'erreur de validation),
            et utilise le helper de vue 'formPassword' qui n'affiche pas la valeur qui lui est
            passé).
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.radio"></a>Zend_Form_Element_Radio</h3></div></div></div>
        
        <p>
            Les éléments radio vous permettend de spécifier plusieurs options, parmi
            lesquelles vous n'avez besoin que d'une seule. <code class="classname">Zend_Form_Element_Radio</code>
            étend la classe de base <code class="classname">Zend_Form_Element_Multi</code>,
            vous permettant ainsi de spécifier un nombre indéfini d'options, et utilise
            ensuite le helper de vue <code class="code">formRadio</code> pour les afficher.
        </p>
        <p>
            Par défaut, cette élément utilise un validateur <code class="code">InArray</code>
            qui effectue sa validation à partir des clés de tableau des options enregistrées.
            Vous pouvez désactiver ce comportement, soit en appellant
            <code class="methodname">setRegisterInArrayValidator(false)</code>, ou en passant une valeur
            <code class="constant">FALSE</code> à la clé de configuration
            <code class="code">registerInArrayValidator</code>.
        </p>
        <p>
            Comme tous les éléments étendant la classe de base Multi element, les méthodes
            suivantes peuvent être utilisé pour manipuler les options radio affichées :
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="methodname">addMultiOption($option, $value)</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">addMultiOptions(array $options)</code></p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code>
                    (écrase les options existantes)
                </p>
            </li>
<li class="listitem"><p><code class="methodname">getMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">getMultiOptions()</code></p></li>
<li class="listitem"><p><code class="methodname">removeMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">clearMultiOptions()</code></p></li>
</ul></div>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.reset"></a>Zend_Form_Element_Reset</h3></div></div></div>
        
        <p>
            Les boutons de mise à zéro sont typiquement utilisé pour vider un formulaire,
            et ne font pas partie des données soumises. Cela dit, comme ils remplissent un rôle
            dans l'affichage, ils sont inclus dans les éléments standards.
        </p>
        <p>
            <code class="classname">Zend_Form_Element_Reset</code> étend <a class="link" href="zend.form.standardElements.html#zend.form.standardElements.submit" title="Zend_Form_Element_Submit">Zend_Form_Element_Submit</a>.
            Ainsi, le label est utilisé pour l'affichage du bouton et sera traduit, si un
            adapteur de traduction est présent. Il utilise seulement les décorateurs
            'ViewHelper' et 'DtDdWrapper', puisqu'il ne devrait jamais y avoir de messages
            d'erreur pour ces éléments, le label ne sera pas non plus nécessaire.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.select"></a>Zend_Form_Element_Select</h3></div></div></div>
        
        <p>
            Les listes d'options sont une manière habituelle de limiter des choix spécifiques.
            <code class="classname">Zend_Form_Element_Select</code> vous permet de les générer
            rapidement et facilement.
        </p>
        <p>
            Par défaut, cette élément utilise un validateur <code class="code">InArray</code>
            qui effectue sa validation à partir des clés de tableau des options enregistrées.
            Vous pouvez désactiver ce comportement, soit en appellant
            <code class="methodname">setRegisterInArrayValidator(false)</code>, ou en passant une valeur
            <code class="constant">FALSE</code> à la clé de configuration
            <code class="code">registerInArrayValidator</code>.
        </p>
        <p>
            Comme il étend l'élément de base Multi, les méthodes suivantes peuvent
            être utilisées pour manipuler les options du select :
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="methodname">addMultiOption($option, $value)</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">addMultiOptions(array $options)</code></p>
            </li>
<li class="listitem">
                <p>
                    <code class="methodname">setMultiOptions(array $options)</code>
                    (écrase les options existantes)
                </p>
            </li>
<li class="listitem"><p><code class="methodname">getMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">getMultiOptions()</code></p></li>
<li class="listitem"><p><code class="methodname">removeMultiOption($option)</code></p></li>
<li class="listitem"><p><code class="methodname">clearMultiOptions()</code></p></li>
</ul></div>
        <p>
            <code class="classname">Zend_Form_Element_Select</code> utilise le helper de vue
            'formSelect pour la décoration.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.submit"></a>Zend_Form_Element_Submit</h3></div></div></div>
        
        <p>
            Les boutons Submit sont utilisé pour soumettre un formulaire. Vous pouvez
            utiliser plusieurs boutons submit ; vous pouvez utiliser le bouton utilisé
            pour soumettre le formulaire afin de décider quelle action effectuer avec
            les données soumises.
            <code class="classname">Zend_Form_Element_Submit</code> rend cette décisions simple,
            en ajoutant une méthode <code class="methodname">isChecked()</code> method ; puisqu'un
            seul élément bouton sera soumis par le formulaire, après avoir rempli ou validé
            le formulaire, vous pourrez appeller cette méthode sur chacun des boutons submit
            afin de déterminer lequel a été utilisé.
        </p>
        <p>
            <code class="classname">Zend_Form_Element_Submit</code> utilise le label comme "value"
            du bouton submit, il sera traduit si un adapeur de traduction est présent.
            <code class="methodname">isChecked()</code> vérifie la valeur soumises avec
            le label pour déterminer si le bouton a été utilisé.
        </p>
        <p>
            Les décorateurs <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.viewHelper" title="Zend_Form_Decorator_ViewHelper">ViewHelper</a>
            et <a class="link" href="zend.form.standardDecorators.html#zend.form.standardDecorators.dtDdWrapper" title="Zend_Form_Decorator_DtDdWrapper">DtDdWrapper</a>
            sont utilisé pour rendre cet élément. Aucun décorateur de label n'est utilisé,
            puisque le label du bouton est utilisé lors du rendu de l'élément ; de plus,
            vous n'associerez aucune erreurs avec l'élément submit.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.text"></a>Zend_Form_Element_Text</h3></div></div></div>
        
        <p>
            De loin le type d'élément de formulaire le plus répandu est l'élément text,
            celui ci autorise des saisies de texte limité ; c'est un élément idéal pour
            la plupart des saisies de données. <code class="classname">Zend_Form_Element_Text</code>
            utilise simplement le helper de vue 'formText' pour afficher l'élément.
        </p>
    </div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.standardElements.textarea"></a>Zend_Form_Element_Textarea</h3></div></div></div>
        
        <p>
            Les Textareas sont utilisé lorsque de grandes quantités de texte sont
            attendues, et ne limite pas la quantité de texte soumise (si ce n'est la
            taille limite fixée par votre serveur ou  <acronym class="acronym">PHP</acronym>).
            <code class="classname">Zend_Form_Element_Textarea</code> utilise le helper de vue
            'textArea' pour afficher ces éléments, et place la valeur comme contenu de
            l'élément.
        </p>
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.form.decorators.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.form.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.form.standardDecorators.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Créer un visuel personnalisé en utilisant Zend_Form_Decorator </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Décorateurs standards fournis avec Zend Framework</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
