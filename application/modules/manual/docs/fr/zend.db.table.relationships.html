<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Relations Zend_Db_Table</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.db.html" title="Zend_Db">
<link rel="prev" href="zend.db.table.rowset.html" title="Zend_Db_Table_Rowset">
<link rel="next" href="zend.db.table.definition.html" title="Zend_Db_Table_Definition">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Relations Zend_Db_Table</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.db.table.rowset.html">Précédent</a> </td>
<th width="60%" align="center">Zend_Db</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.db.table.definition.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.table.relationships"></a>Relations Zend_Db_Table</h2></div></div></div>
    

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.introduction"></a>Introduction</h3></div></div></div>
        

        <p>
            Les tables possèdent des relations entre elles, dans une base de données
            relationnelle. Une entité d'une table peut être liée à une autre entité d'une autre
            table, via un procédé appelé contrainte d'intégrité référentielle
        </p>

        <p>
            La classe <code class="classname">Zend_Db_Table_Row</code> possède des méthodes pour
            récupérer des enregistrement dans d'autres tables, liées à celle en cours.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.defining"></a>Définir ses relations</h3></div></div></div>
        

        <p>
            Chaque table doit avoir sa classe étendant
            <code class="classname">Zend_Db_Table_Abstract</code>, comme décrit dans <a class="xref" href="zend.db.table.html#zend.db.table.defining" title="Définir une classe de Table">la section intitulée « Définir une classe de Table »</a>. Voyez aussi <a class="xref" href="zend.db.adapter.html#zend.db.adapter.example-database" title="La base de données d'exemple">la section intitulée « La base de données d'exemple »</a> pour une description de la base de donnée
            qui servira d'exemple pour la suite de ce chapitre.
        </p>

        <p>Voici les classes correspondantes à ces tables :</p>

        <pre class="programlisting">
class Accounts extends Zend_Db_Table_Abstract
{
    protected $_name            = 'accounts';
    protected $_dependentTables = array('Bugs');
}

class Products extends Zend_Db_Table_Abstract
{
    protected $_name            = 'products';
    protected $_dependentTables = array('BugsProducts');
}

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name            = 'bugs';

    protected $_dependentTables = array('BugsProducts');

    protected $_referenceMap    = array(
        'Reporter' =&gt; array(
            'columns'           =&gt; 'reported_by',
            'refTableClass'     =&gt; 'Accounts',
            'refColumns'        =&gt; 'account_name'
        ),
        'Engineer' =&gt; array(
            'columns'           =&gt; 'assigned_to',
            'refTableClass'     =&gt; 'Accounts',
            'refColumns'        =&gt; 'account_name'
        ),
        'Verifier' =&gt; array(
            'columns'           =&gt; array('verified_by'),
            'refTableClass'     =&gt; 'Accounts',
            'refColumns'        =&gt; array('account_name')
        )
    );
}

class BugsProducts extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs_products';

    protected $_referenceMap    = array(
        'Bug' =&gt; array(
            'columns'           =&gt; array('bug_id'),
            'refTableClass'     =&gt; 'Bugs',
            'refColumns'        =&gt; array('bug_id')
        ),
        'Product' =&gt; array(
            'columns'           =&gt; array('product_id'),
            'refTableClass'     =&gt; 'Products',
            'refColumns'        =&gt; array('product_id')
        )
    );

}
</pre>

        <p>
            Si vous utilisez <code class="classname">Zend_Db_Table</code> pour émuler les cascades
            <code class="constant">UPDATE</code> et <code class="constant">DELETE</code>, alors déclarez
            <code class="varname">$_dependentTables</code> en tant que tableau dans la classe des tables parentes.
            Listez ainsi le nom de chaque table dépendante. Utilisez bien le nom des classes, et non
            les noms physiques des tables.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Si votre SGBD implémente le mécanisme des cascades, alors vous n'avez pas
                besoin de déclarer <code class="varname">$_dependentTables</code>. Voyez <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.cascading" title="Opérations d'écritures en cascade">la section intitulée « Opérations d'écritures en cascade »</a> pour plus d'informations.
            </p>
        </td></tr>
</table></div>

        <p>
            Déclarez un tableau <code class="varname">$_referenceMap</code> dans les classes de chaque table
            dépendante (qui "reçoit une clé"). C'est un tableau associatif, dit de "rôles". Un rôle
            définit quelle table est parente dans la relation, et quelle est sa colonne de
            parenté.
        </p>

        <p>
            Le rôle est utilisé comme index du tableau <code class="varname">$_referenceMap</code>. Il est
            utilisé pour définir la relation, et pourra faire partie du nom de certaines méthodes,
            comme nous le verrons plus tard. Choisissez ainsi un nom de rôle de manière
            intelligente.
        </p>

        <p>
            Dans l'exemple du dessus, les rôles dans la classe Bugs sont :
            <code class="code">"Reporter"</code>, <code class="code">"Engineer"</code>, <code class="code">"Verifier"</code> et
            <code class="code">"Product"</code>.
        </p>

        <p>
            La valeur de chaque rôle dans le tableau <code class="varname">$_referenceMap</code> est aussi un
            tableau associatif. Les éléments de chaque rôle sont décrits ci-après.
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>columns</em></span> =&gt; une chaîne de caractères ou un tableau
                    de chaînes désignant le(s) nom(s) des clés étrangères dans la table dépendante
                    (la table actuelle donc).
                </p>

                <p>
                    Il est courant qu'il s'agisse d'une seule colonne, mais on peut rencontrer
                    le cas de clés composées de multiples colonnes.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>refTableClass</em></span> =&gt; désigne la classe de la table
                    parente, liée à cette colonne. Utilisez le nom de la classe et non le nom de la
                    table physique.
                </p>

                <p>
                    Il est courant qu'une table dépendante n'ait qu'une seule référence d'une
                    même table parente. Cependant certaines tables peuvent avoir plusieurs
                    références vers une même table parente. Dans notre base de données d'exemple,
                    c'est le cas avec la table <code class="code">bugs</code>. Elle possède soit une et une seule
                    colonne référençant la table parente <code class="code">products</code>, mais elle possède
                    trois références (donc trois colonnes) vers la table parente
                    <code class="code">accounts</code>. Chaque référence doit être matérialisée par un rôle
                    unique dans le tableau <code class="varname">$_referenceMap</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>refColumns</em></span> =&gt; c'est une chaîne de caractères ou un
                    tableau de chaînes nommant la(es) colonne(s) (clé primaire) de la table
                    parente.
                </p>

                <p>
                    Si vous devez utiliser de multiples colonnes parentes pour une seule clé,
                    alors veillez à bien les entrer dans <code class="code">'columns'</code> dans le même ordre
                    que dans <code class="code">'refColumns'</code>.
                </p>

                <p>
                    Il est optionnel de spécifier la <code class="code">refColumns</code>. La clé primaire
                    est utilisée par défaut comme colonne parente dans une relation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>onDelete</em></span> =&gt; le nom de l'action à exécuter si un
                    enregistrement est supprimé de la table parente. Voyez <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.cascading" title="Opérations d'écritures en cascade">la section intitulée « Opérations d'écritures en cascade »</a> pour plus
                    d'informations.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>onUpdate</em></span> =&gt; le nom de l'action à exécuter si un
                    enregistrement est mis à jour dans la table parente. Voyez<a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.cascading" title="Opérations d'écritures en cascade">la section intitulée « Opérations d'écritures en cascade »</a> pour plus
                    d'informations.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.fetching.dependent"></a>Récupérer des enregistrements dépendants (enfants)</h3></div></div></div>
        

        <p>
            Si vous possédez un enregistrement actif (<code class="code">Row</code>), il est possible de
            récupérer ses enfants dépendants, si les dépendances ont été déclarées suivant la
            procédure ci-dessus. Utilisez la méthode :
        </p>

        <pre class="programlisting">
$row-&gt;findDependentRowset($table, [$rule]);
</pre>

        <p>
            Cette méthode retourne un objet instance de
            <code class="classname">Zend_Db_Table_Rowset_Abstract</code>, qui contient tous les
            enregistrements (<code class="code">Row</code>) de la table dépendante <code class="varname">$table</code> faisant
            référence à l'enregistrement actif actuel <code class="varname">$row</code>.
        </p>

        <p>
            Le paramètre <code class="varname">$table</code> désigne la table dépendante à utiliser. Ceci peut
            être une chaîne de caractères aussi bien qu'un objet de la classe de cette table.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example"></a><p class="title"><b>Exemple 327. Récupérer des enregistrements dépendants</b></p>
<div class="example-contents">
            

            <p>
                Cet exemple montre comment obtenir un enregistrement actif (objet
                <code class="code">Row</code>) de la table <code class="code">Accounts</code>, et comment en récupérer les
                enfants dépendants de la table <code class="code">Bugs</code>. (les bugs reportés par ce
                compte)
            </p>

            <pre class="programlisting">
$accountsTable      = new Accounts();
$accountsRowset     = $accountsTable-&gt;find(1234);
$user1234           = $accountsRowset-&gt;current();

$bugsReportedByUser = $user1234-&gt;findDependentRowset('Bugs');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Le second paramètre <code class="varname">$rule</code> est optionnel. Il s'agit du nom du rôle à
            utiliser depuis le tableau <code class="varname">$_referenceMap</code> de la classe de la table
            dépendante. Si vous ne le spécifiez pas, le premier rôle sera utilisé. Il n'y a dans la
            majorité des cas qu'un seul rôle.
        </p>

        <p>
            Dans l'exemple ci dessus, nous ne fournissons pas de nom de rôle, le premier est
            donc pris en considération, et il s'agit de <code class="code">"Reporter"</code>.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example-by"></a><p class="title"><b>Exemple 328. Récupérer des enregistrements dépendants avec un rôle spécifique</b></p>
<div class="example-contents">
            

            <p>
                Dans cet exemple nous montrons comment obtenir un enregistrement
                (<code class="code">Row</code>) depuis la table <code class="code">Accounts</code>, et comment trouver les
                <code class="code">Bugs</code> assignés à ce compte (<code class="code">Account</code>). Nous devrons alors
                nommer le rôle <code class="code">"Engineer"</code>.
            </p>

            <pre class="programlisting">
$accountsTable      = new Accounts();
$accountsRowset     = $accountsTable-&gt;find(1234);
$user1234           = $accountsRowset-&gt;current();

$bugsAssignedToUser = $user1234-&gt;findDependentRowset('Bugs',
                                                     'Engineer');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Vous pouvez rajouter des critères à vos relations, comme l'ordre ou la limite,
            ceci en utilisant l'objet <code class="code">select</code> de l'enregistrement parent.
        </p>

        <p>
            </p>
<div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example-by-select"></a><p class="title"><b>Exemple 329. 
                        Récupérer des enregistrements dépendants en utilisant un objet
                        Zend_Db_Table_Select
                    </b></p>
<div class="example-contents">
                    

                <p>
                    Dans cet exemple nous montrons comment obtenir un enregistrement
                    (<code class="code">Row</code>) depuis la table <code class="code">Accounts</code>, et comment trouver les
                    <code class="code">Bugs</code> assignés à ce compte (<code class="code">Account</code>), mais limités
                    seulement à trois enregistrements, et ordonnés par nom. Nous devrons nommer le
                    rôle <code class="code">"Engineer"</code>.
                </p>

                <pre class="programlisting">
$accountsTable      = new Accounts();
$accountsRowset     = $accountsTable-&gt;find(1234);
$user1234           = $accountsRowset-&gt;current();
$select             = $accountsTable-&gt;select()-&gt;order('name ASC')
                                              -&gt;limit(3);

$bugsAssignedToUser = $user1234-&gt;findDependentRowset('Bugs',
                                                     'Engineer',
                                                     $select);
</pre>
            </div>
</div>
<p><br class="example-break">Vous pouvez récupérer les enregistrements dépendants d'une autre manière.
        En utilisant les "méthodes magiques". En effet,
        <code class="classname">Zend_Db_Table_Row_Abstract</code> va utiliser la méthode
        <code class="methodname">findDependentRowset('&lt;TableClass&gt;', '&lt;Rule&gt;')</code> si vous appelez
            sur l'enregistrement une méthode correspondante à un de ces motifs :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="code">$row-&gt;find&lt;TableClass&gt;()</code></p>
            </li>
<li class="listitem">
                <p><code class="code">$row-&gt;find&lt;TableClass&gt;By&lt;Rule&gt;()</code></p>
            </li>
</ul></div>

        <p>
            Dans les motifs ci-dessus, <code class="code">&lt;TableClass&gt;</code> et
            <code class="code">&lt;Rule&gt;</code> désignent respectivement le nom de la table dépendante et le
            rôle à utiliser.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Certains frameworks tels que Rails pour Ruby, utilise un mécanisme dit
                d'inflexion, qui permet de transformer les noms des identifiants (nom de table, de
                rôle...) d'une certaine manière bien spécifique dans les méthodes appelées. Cela
                n'est pas le cas de Zend Framework : vous devez, dans vos méthodes magiques,
                utiliser l'orthographe exacte des noms des rôles et classes, tels que vous les
                définissez.
            </p>
        </td></tr>
</table></div>

        <div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example-magic"></a><p class="title"><b>Exemple 330. 
                Récupérer des enregistrements dépendants en utilisant les méthodes magiques
            </b></p>
<div class="example-contents">
            

            <p>
                Cet exemple a le même effet que le précédent. Il utilise simplement les
                méthodes magiques pour récupérer les enregistrements dépendants.
            </p>

            <pre class="programlisting">
$accountsTable    = new Accounts();
$accountsRowset   = $accountsTable-&gt;find(1234);
$user1234         = $accountsRowset-&gt;current();

// Utilise le rôle par défaut (le premier de la liste)
$bugsReportedBy   = $user1234-&gt;findBugs();

// Utilise un rôle spécifique
$bugsAssignedTo   = $user1234-&gt;findBugsByEngineer();
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.fetching.parent"></a>Récupérer l'enregistrement parent</h3></div></div></div>
        

        <p>
            Si vous possédez un enregistrement (<code class="code">Row</code>) dont la table possède une
            table parente, il est possible alors de récupérer l'enregistrement parent. Utilisez pour
            cela la méthode :
        </p>

        <pre class="programlisting">
$row-&gt;findParentRow($table, [$rule]);
</pre>

        <p>
            La logique veut qu'il ne puisse y avoir qu'un et un seul parent par
            enregistrement. Ainsi, cette méthode retourne un objet <code class="code">Row</code> et non un objet
            <code class="code">Rowset</code>
        </p>

        <p>
            Le premier paramètre <code class="varname">$table</code> désigne la table parente. Ceci peut être
            une chaîne de caractères, ou un objet instance de la classe de la table parente.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.parent.example"></a><p class="title"><b>Exemple 331. Récupérer l'enregistrement parent</b></p>
<div class="example-contents">
            

            <p>
                Cet exemple illustre la récupération d'un enregistrement <code class="code">Bugs</code> (disons
                par exemple ceux avec le statut "NEW"), et l'obtention de l'enregistrement
                parent correspondant à <code class="code">Accounts</code> (la personne ayant reporté le
                bug)
            </p>

            <pre class="programlisting">
$bugsTable   = new Bugs();
$bugsRowset  = $bugsTable-&gt;fetchAll(array('bug_status = ?' =&gt; 'NEW'));
$bug1        = $bugsRowset-&gt;current();

$reporter    = $bug1-&gt;findParentRow('Accounts');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Le second paramètre <code class="varname">$rule</code> est optionnel. Il s'agit du nom du rôle à
            utiliser depuis le tableau <code class="varname">$_referenceMap</code> de la classe de la table
            dépendante. Si vous ne le spécifiez pas, le premier rôle sera utilisé. Il n'y a dans la
            majorité des cas qu'un seul rôle.
        </p>

        <p>
            Dans l'exemple ci dessus, nous ne fournissons pas de nom de rôle, le premier est
            donc pris en considération, et il s'agit de <code class="code">"Reporter"</code>.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.parent.example-by"></a><p class="title"><b>Exemple 332. Récupérer un enregistrement parent avec un rôle spécifique</b></p>
<div class="example-contents">
            

            <p>
                Cet exemple va démontrer comment, à partir d'un enregistrement de
                <code class="code">Bugs</code>, récupérer la personne en étant assignée. Il va falloir utiliser
                le rôle <code class="code">"Engineer"</code>.
            </p>

            <pre class="programlisting">
$bugsTable   = new Bugs();
$bugsRowset  = $bugsTable-&gt;fetchAll(array('bug_status = ?', 'NEW'));
$bug1        = $bugsRowset-&gt;current();

$engineer    = $bug1-&gt;findParentRow('Accounts', 'Engineer');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Vous pouvez récupérer l'enregistrement parent d'une autre manière. En utilisant
            les "méthodes magiques". En effet, Zend_Db_Table_Row_Abstract va utiliser la
            méthode<code class="methodname">findParentRow('&lt;TableClass&gt;', '&lt;Rule&gt;')</code> si vous appelez
            sur l'enregistrement une méthode correspondante à un de ces motifs :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;findParent&lt;TableClass&gt;([Zend_Db_Table_Select
                    $select])</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;findParent&lt;TableClass&gt;By&lt;Rule&gt;([Zend_Db_Table_Select
                    $select])</code>
                </p>
            </li>
</ul></div>

        <p>
            Dans les motifs ci-dessus, <code class="code">&lt;TableClass&gt;</code> et
            <code class="code">&lt;Rule&gt;</code> représentent respectivement le nom de la classe de la table
            parente, et le rôle à utiliser éventuellement.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Les noms de la table et du rôle doivent être orthographiés de la même manière
                qu'ils ne le sont lors de leur définition dans la table.
            </p>
        </td></tr>
</table></div>

        <div class="example">
<a name="zend.db.table.relationships.fetching.parent.example-magic"></a><p class="title"><b>Exemple 333. Récupérer un enregistrement parent en utilisant les méthodes magiques</b></p>
<div class="example-contents">
            

            <p>
                Cet exemple a le même effet que le précédent. Il utilise simplement les
                méthodes magiques pour récupérer l'enregistrement parent.
            </p>

            <pre class="programlisting">
$bugsTable   = new Bugs();
$bugsRowset  = $bugsTable-&gt;fetchAll(array('bug_status = ?', 'NEW'));
$bug1        = $bugsRowset-&gt;current();

// Utilise le rôle par défaut ( le premier déclaré)
$reporter    = $bug1-&gt;findParentAccounts();

// Utilise un rôle spécifique
$engineer    = $bug1-&gt;findParentAccountsByEngineer();
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.fetching.many-to-many"></a>
            Récupérer des enregistrements dans une relation N-N (plusieurs-à-plusieurs ou
            "many-to-many")
        </h3></div></div></div>
        

        <p>
            Si vous possédez un enregistrement sur une table (appelons la "table d'origine")
            ayant une relation plusieurs à plusieurs vers une autre table (appelons la "table de
            destination"), vous pouvez alors accéder aux enregistrements de la table de destination,
            via une table dite "d'intersection". Utilisez la méthode :
        </p>

        <pre class="programlisting">
$row-&gt;findManyToManyRowset($table,
                           $intersectionTable,
                           [$rule1,
                           [$rule2,
                           [Zend_Db_Table_Select $select]]]);
</pre>

        <p>
            Cette méthode retourne un objet instance de
            <code class="classname">Zend_Db_Table_Rowset_Abstract</code> qui contient les enregistrements de
            la table <code class="varname">$table</code> qui correspondent à la relation plusieurs à plusieurs.
            L'enregistrement courant de la table courante, <code class="varname">$row</code>, est utilisé comme
            point de départ pour effectuer une jointure vers la table de destination, via la table
            d'intersection.
        </p>

        <p>
            Le premier paramètre <code class="varname">$table</code> peut être soit une chaîne soit un objet
            instance de la classe de la table de destination dans la relation plusieurs à
            plusieurs.
        </p>

        <p>
            Le second paramètre <code class="varname">$intersectionTable</code> peut être soit une chaîne soit
            un objet instance de la classe de la table d'intersection dans la relation plusieurs à
            plusieurs.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.many-to-many.example"></a><p class="title"><b>Exemple 334. Récupérer des enregistrements dans une relation plusieurs-à-plusieurs</b></p>
<div class="example-contents">
            

            <p>
                Cet exemple montre comment posséder un enregistrement de la table d'origine
                <code class="code">Bugs</code>, et comment en récupérer les enregistrements de
                <code class="code">Products</code>, qui représentent les produits qui font référence à ce
                bug.
            </p>

            <pre class="programlisting">
$bugsTable        = new Bugs();
$bugsRowset       = $bugsTable-&gt;find(1234);
$bug1234          = $bugsRowset-&gt;current();

$productsRowset   = $bug1234-&gt;findManyToManyRowset('Products',
                                                   'BugsProducts');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Les troisième et quatrième paramètres, <code class="varname">$rule1</code> et <code class="varname">$rule2</code>,
            sont optionnels. Ce sont des chaînes de caractères qui désignent les rôles à utiliser
            dans le tableau <code class="varname">$_referenceMap</code> de la table d'intersection.
        </p>

        <p>
            <code class="varname">$rule1</code> nomme le rôle dans la relation entre la table d'origine et la
            table d'intersection. Dans notre exemple, il s'agit donc de la relation de
            <code class="code">Bugs</code> à <code class="code">BugsProducts</code>.
        </p>

        <p>
            <code class="varname">$rule2</code>nomme le rôle dans la relation entre la table d'origine et la
            table d'intersection. Dans notre exemple, il s'agit donc de la relation de
            <code class="code">BugsProducts</code> à <code class="code">Products</code>.
        </p>

        <p>
            Si vous ne spécifiez pas de rôles, alors le premier rôle trouvé pour la table,
            dans le tableau <code class="varname">$_referenceMap</code>, sera utilisé. Dans la grande majorité des
            cas, il n'y a qu'un rôle.
        </p>

        <p>
            Dans l'exemple ci-dessus, les rôles ne sont pas spécifiés. Ainsi
            <code class="varname">$rule1</code> prend la valeur <code class="code">"Reporter"</code> et <code class="varname">$rule2</code> prend
            la valeur <code class="code">"Product"</code>.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.fetching.many-to-many.example-by"></a><p class="title"><b>Exemple 335. Récupérer des enregistrements dans une relation plusieurs-à-plusieurs avec un
            rôle spécifique</b></p>
<div class="example-contents">
            

            <p>
                Cet exemple montre comment à partir d'un enregistrement de <code class="code">Bugs</code>,
                récupérer les enregistrements de <code class="code">Products</code>, représentant les produits
                comportant ce bug.
            </p>

            <pre class="programlisting">
$bugsTable        = new Bugs();
$bugsRowset       = $bugsTable-&gt;find(1234);
$bug1234          = $bugsRowset-&gt;current();

$productsRowset   = $bug1234-&gt;findManyToManyRowset('Products',
                                                   'BugsProducts',
                                                   'Bug');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Vous pouvez récupérer l'enregistrement de destination d'une autre manière. En
            utilisant les "méthodes magiques". En effet,
            <code class="classname">Zend_Db_Table_Row_Abstract</code> va utiliser la méthode
            <code class="code">findManyToManyRowset('&lt;TableClass&gt;', '&lt;IntersectionTableClass&gt;',
            '&lt;Rule1&gt;', '&lt;Rule2&gt;')</code> si vous appelez sur l'enregistrement une
            méthode correspondante à un de ces motifs :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;([Zend_Db_Table_Select
                    $select])</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;By&lt;Rule1&gt;([Zend_Db_Table_Select
                    $select])</code>
                </p>
            </li>
<li class="listitem">
                <p>
                    <code class="code">$row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;By&lt;Rule1&gt;And&lt;Rule2&gt;([Zend_Db_Table_Select
                    $select])</code>
                </p>
            </li>
</ul></div>

        <p>
            Dans les motifs ci dessus, <code class="code">&lt;TableClass&gt;</code> et
            <code class="code">&lt;IntersectionTableClass&gt;</code> sont des chaînes de caractères
            correspondantes aux noms des classes des tables de destination et d'intersection
            (respectivement). <code class="code">&lt;Rule1&gt;</code> et <code class="code">&lt;Rule2&gt;</code> sont
            respectivement des chaînes désignant les rôles dans la table d'intersection pour la
            table de référence, et de destination.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Les noms de la table et des rôles doivent être orthographiés de manière
                exacte, tel qu'ils le sont lors de leurs définitions respectives.
            </p>
        </td></tr>
</table></div>

        <div class="example">
<a name="zend.db.table.relationships.fetching.many-to-many.example-magic"></a><p class="title"><b>Exemple 336. Récupérer des enregistrements dans une relation plusieurs-à-plusieurs avec
            les méthodes magiques</b></p>
<div class="example-contents">
            

            <p>
                Cet exemple illustre la récupération d'enregistrements dans une table de
                destination, bugs, depuis un produit, en passant par une table d'intersection, le
                tout, via des méthodes magiques.
            </p>

            <pre class="programlisting">
$bugsTable   = new Bugs();
$bugsRowset  = $bugsTable-&gt;find(1234);
$bug1234     = $bugsRowset-&gt;current();

// Utilisation des rôles par défaut
$products    = $bug1234-&gt;findProductsViaBugsProducts();

// Utilisation d'un rôle spécifique
$products    = $bug1234-&gt;findProductsViaBugsProductsByBug();
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.cascading"></a>Opérations d'écritures en cascade</h3></div></div></div>
        

        <div class="note"><table border="0" summary="Note: Déclarer l'intégrité référentielle">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Déclarer l'intégrité référentielle</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Déclarer les opérations de cascades dûes à l'intégrité référentielle dans
                <code class="classname">Zend_Db_Table</code> directement, ne doit se faire
                <span class="emphasis"><em>seulement</em></span> si votre SGBD ne supporte pas nativement ce genre
                d'opérations.
            </p>

            <p>
                C'est le cas par exemple de MySQL ou MariaDB utilisant le stockage de tables MyISAM, ou
                encore SQLite. Ces solutions là ne supportent pas l'intégrité référentielle. Il peut
                alors être intéressant d'utiliser <code class="classname">Zend_Db_Table</code> pour émuler
                un tel comportement
            </p>

            <p>
                Si votre SGBD en revanche supporte les clauses <code class="code">ON DELETE</code> et
                <code class="code">ON UPDATE</code>, alors vous devriez les déclarer directement dans le SGBD
                plutôt que de vous fier à l'émulation proposée par
                <code class="classname">Zend_Db_Table</code>. Déclarer son intégrité référentielle dans son
                SGBD directement est tout à fait recommandé pour les performances, l'intégrité
                (l'atomicité des opérations), et la logique de base de données.
            </p>

            <p>
                Il est très important de ne pas déclarer ses règles d'intégrité référentielle
                à la fois dans son SGBD et dans les classes
                <code class="classname">Zend_Db_Table</code>.
            </p>
        </td></tr>
</table></div>

        <p>
            Vous pouvez déclarer des opérations de cascade sur un <code class="constant">UPDATE</code> ou un
            <code class="constant">DELETE</code>, à appliquer sur les enregistrements dépendants à la table en
            cours.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.cascading.example-delete"></a><p class="title"><b>Exemple 337. Exemple de DELETE cascade</b></p>
<div class="example-contents">
            

            <p>
                Cet exemple montre l'effacement d'un enregistrement de <code class="code">Products</code>,
                qui va propager l'effacement des enregistrements dépendants dans la table
                <code class="code">Bugs</code>.
            </p>

            <pre class="programlisting">
$productsTable  = new Products();
$productsRowset = $productsTable-&gt;find(1234);
$product1234    = $productsRowset-&gt;current();

$product1234-&gt;delete();
// Cascades automatiques vers le table Bugs
// et suppression des enregistrements dépendants.
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            De la même manière, si vous utilisez un <code class="constant">UPDATE</code> pour changer la valeur
            de la clé primaire d'une table parente, vous pourriez nécessiter que les clés étrangères
            des tables dépendantes soient mises à jour.
        </p>

        <p>
            En général s'il s'agit d'une séquence, il n'est pas nécessaire de mettre à jour
            les enregistrements dépendants. En revanche concernant les clé dites
            <span class="emphasis"><em>naturelles </em></span>, il peut s'avérer nécessaire de propager un changement
            de valeur.
        </p>

        <p>
            Afin de déclarer une relation de cascades dans
            <code class="classname">Zend_Db_Table</code>, éditer les rôles dans <code class="varname">$_referenceMap</code>.
            Ajoutez les clés <code class="code">'onDelete'</code> et <code class="code">'onUpdate'</code> et donnez leur la
            valeur 'cascade' (ou la constante <code class="constant">self::CASCADE</code>). Avant qu'un
            enregistrement ne soit modifié(sa clé primaire) / supprimé, tous les enregistrements
            dans les tables dépendantes seront modifiés / supprimés.
        </p>

        <div class="example">
<a name="zend.db.table.relationships.cascading.example-declaration"></a><p class="title"><b>Exemple 338. Exemple de déclaration des opérations de cascade</b></p>
<div class="example-contents">
            

            <p>
                Dans l'exemple ci-après, les enregistrements de <code class="code">Bugs</code> sont
                automatiquement supprimés si l'enregistrement dans la table <code class="code">Products</code>
                auquel ils font référence est supprimé. L'élément <code class="code">"onDelete"</code> de la
                <code class="varname">$_referenceMap</code> est mis à <code class="constant">self::CASCADE</code>.
            </p>

            <p>
                Pas de mise à jour en cascade en revanche pour cette table, si la clé primaire
                de la table parente est changée. En effet, l'élément <code class="code">"onUpdate"</code> est mis
                à <code class="constant">self::RESTRICT</code>. Vous auriez aussi pu tout simplement ne pas spécifier
                <code class="code">"onUpdate"</code> .
            </p>

            <pre class="programlisting">
class BugsProducts extends Zend_Db_Table_Abstract
{
    ...
    protected $_referenceMap    = array(
        'Product' =&gt; array(
            'columns'           =&gt; array('product_id'),
            'refTableClass'     =&gt; 'Products',
            'refColumns'        =&gt; array('product_id'),
            'onDelete'          =&gt; self::CASCADE,
            'onUpdate'          =&gt; self::RESTRICT
        ),
        ...
    );
}
</pre>
        </div>
</div>
<br class="example-break">

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.relationships.cascading.notes"></a>Notes concernant les opérations de cascade</h4></div></div></div>
            

            <p>
                <span class="emphasis"><em>Les opérations de cascades déclenchées par Zend_Db_Table ne sont pas
                atomiques.</em></span>
            </p>

            <p>
                Ceci signifie que si votre SGBD possède un moyen de gérer les cascades, comme
                l'intégrité référentielle (et les clés étrangères), alors vous ne devriez pas
                utiliser les cascades INSERT via <code class="classname">Zend_Db_Table</code>, car elles
                vont entrer en conflit avec le système d'intégrité référentielle du SGBD qui lui,
                est atomique.
            </p>

            <p>
                Le problème est plus mitigé concernant <code class="constant">DELETE</code>. Vous pouvez
                détruire de manière non atomique un enregistrement dépendant, avant de détruire son
                parent.
            </p>

            <p>
                Cependant, les deux opérations <code class="constant">UPDATE</code> et <code class="constant">DELETE</code>
                utilisées de manière non atomique(que), c'est à dire avec le mécanisme de
                <code class="classname">Zend_Db_Table</code>, peuvent laisser la base de données dans un
                état non désiré, ou état intermédiaire. Supposez que vous supprimiez tous les
                enregistrements dépendants, pour finir par leur parent unique. A un moment donnée,
                la base de donnée sera dans un état tel que le parent sera sans enfants, mais
                toujours bel et bien présent. Si un autre client se connecte exactement à ce moment
                là, il va pouvoir requêter éventuellement le parent, en croyant que celui-ci n'a
                plus d'enfant, ce qui normalement n'est pas le cas. Il est alors totalement
                impossible pour ce client là de se rendre compte qu'il a effectuer une lecture au
                beau milieu d'une plus vaste opération d'effacement.
            </p>

            <p>
                Les problèmes de changements non-atomique peuvent être anéantis en utilisant
                les transactions isolantes, c'est d'ailleurs un de leur rôle clé. Cependant certains
                SGBDs ne supportent pas encore les transactions, et autorisent leurs clients à lire
                des changements incomplets pas validés en totalité.
            </p>

            <p>
                <span class="emphasis"><em>Les opérations de cascades de Zend_Db_Table ne sont utilisées que
                par Zend_Db_Table.</em></span>
            </p>

            <p>
                Les cascades pour <code class="constant">DELETE</code> et <code class="constant">UPDATE</code> définies dans vos
                classes <code class="classname">Zend_Db_Table</code> ne sont utilisées que lors du recours
                aux méthodes <code class="methodname">save()</code> ou <code class="methodname">delete()</code> sur les enregistrements
                <code class="code">Row</code>. Si vous utilisez une autre interface pour vos <code class="constant">UPDATE</code>
                ou <code class="constant">DELETE</code>, comme par exemple un outil de requêtes, ou une autre
                application, les opérations de cascades ne sont bien sûr pas appliquées. C'est même
                le cas si vous utilisez les méthodes <code class="methodname">update()</code> et <code class="methodname">delete()</code>
                dans la classe <code class="classname">Zend_Db_Adapter</code>.
            </p>

            <p><span class="emphasis"><em>Pas d'<code class="constant">INSERT</code> en cascade</em></span></p>

            <p>
                Le support pour les cascades d'<code class="constant">INSERT</code> n'est pas assuré. Vous
                devez explicitement insérer les enregistrements dépendants à un enregistrement
                parent.
            </p>
        </div>
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.db.table.rowset.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.db.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.db.table.definition.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Zend_Db_Table_Rowset </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Zend_Db_Table_Definition</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
