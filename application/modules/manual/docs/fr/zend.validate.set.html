<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Classes de validation standard</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.validate.html" title="Zend_Validate">
<link rel="prev" href="zend.validate.introduction.html" title="Introduction">
<link rel="next" href="zend.validate.validator_chains.html" title="Chaînes de validation">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Classes de validation standard</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.validate.introduction.html">Précédent</a> </td>
<th width="60%" align="center">Zend_Validate</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.validate.validator_chains.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.validate.set"></a>Classes de validation standard</h2></div></div></div>
    

    <p>
        Zend Framework est fourni avec un jeu de classes de validation standard, qui sont
        directement utilisables par votre application.
    </p>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.alnum"></a>Alnum</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Alnum</code> permet de valider des données contenant des
        caractères alphabétiques et des chiffres. Il n'y a pas de limite de taille.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alnum.options"></a>Options supportées par Zend_Validate_Alnum</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_Alnum</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowWhiteSpace</span></em></span> : Si le
                    caractère d'espace doit être accepté ou non. Par défaut
                    <code class="constant">FALSE</code>.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alnum.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voici un exemple :
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Alnum();
if ($validator-&gt;isValid('Abcd12')) {
    // value ne contient que des caractères autorisés
} else {
    // false
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alnum.whitespace"></a>Utiliser les espaces</h4></div></div></div>
        

        <p>
            Par défaut les caractères espaces ne sont pas acceptés car il ne font pas partie de
            l'alphabet. Cependant il existe un moyen de les accepter en entrée, ceci permet de
            valider des phrases complètes.
        </p>

        <p>
            Pour autoriser les espaces blancs vous devez passer l'option
            <span class="property">allowWhiteSpace</span>. Ceci peut se faire à la création de l'objet ou
            ensuite au moyen des méthodes <code class="methodname">setAllowWhiteSpace()</code> et
            <code class="methodname">getAllowWhiteSpace()</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Alnum(array('allowWhiteSpace' =&gt; true));
if ($validator-&gt;isValid('Abcd and 12')) {
    // value ne contient que des caractères autorisés
} else {
    // false
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alnum.languages"></a>Utiliser des langues différentes</h4></div></div></div>
        

        <p>
            En utilisant <code class="classname">Zend_Validate_Alnum</code>, la langue que l'utilisateur
            précise dans son navigateur sera utilisée pour autoriser ou non certains caractères.
            Ainsi si l'utilisateur règle son navigateur sur <span class="emphasis"><em>de</em></span> pour de
            l'allemand, alors les caractères comme <span class="emphasis"><em>ä</em></span>, <span class="emphasis"><em>ö</em></span>
            et <span class="emphasis"><em>ü</em></span> seront eux aussi autorisés.
        </p>

        <p>
            Les caractères autorisés dépendent donc complètement de la langue utilisée.
        </p>

        <p>
            Il existe actuellement 3 langues qui ne sont pas supportées pour ce validateur. Il
            s'agit du <span class="emphasis"><em>coréen</em></span>, du <span class="emphasis"><em>japonais</em></span> et du
            <span class="emphasis"><em>chinois</em></span> car ces langues utilisent un alphabet dans lequel un seul
            caractère est fabriqué à base de multiples caractères.
        </p>

        <p>
            Dans le cas où vous utilisez ces langues, seule l'alphabet anglais sera utilisé pour la
            validation.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.alpha"></a>Alpha</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Alpha</code> permet de valider qu'une donnée ne contient que des caractères
        alphabétiques. Il n'y a pas de limite de taille. Ce validateur fonctionne comme le validateur
         <code class="classname">Zend_Validate_Alnum</code> à l'exception qu'il n'accepte pas les chiffres.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alpha.options"></a>Options suportées par Zend_Validate_Alpha</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Validate_Alpha</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowWhiteSpace</span></em></span>: Si les caractères d'espace
                    sont autorisés ou pas. Par défaut <code class="constant">FALSE</code>
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alpha.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voici un exemple de base:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Alpha();
if ($validator-&gt;isValid('Abcd')) {
    // value ne contient que des caractères autorisés
} else {
    // false
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alpha.whitespace"></a>Utiliser les espaces</h4></div></div></div>
        

        <p>
            Par défaut les caractères espaces ne sont pas acceptés car il ne font pas partie de l'alphabet.
            Cependant il existe un moyen de les accepter en entrée, ceci permet de valider des phrases
            complètes.
        </p>

        <p>
            Pour autoriser les espaces blancs vous devez passer l'option <span class="property">allowWhiteSpace</span>.
            Ceci peut se faire à la création de l'objet ou après au moyen des méthodes
            <code class="methodname">setAllowWhiteSpace()</code> et <code class="methodname">getAllowWhiteSpace()</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Alpha(array('allowWhiteSpace' =&gt; true));
if ($validator-&gt;isValid('Abcd and efg')) {
    // value ne contient que des caractères autorisés
} else {
    // false
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.alpha.languages"></a>Utiliser des langues différentes</h4></div></div></div>
        

        <p>
            En utilisant <code class="classname">Zend_Validate_Alpha</code>, la langue que l'utilisateur précise
            dans son navigateur sera utilisée pour autoriser ou non certains caractères. Ainsi si l'utilisateur
            règle son navigateur sur <span class="emphasis"><em>de</em></span> pour de l'allemand, alors les caractères comme
            <span class="emphasis"><em>ä</em></span>, <span class="emphasis"><em>ö</em></span> et <span class="emphasis"><em>ü</em></span> seront eux aussi
            autorisés.
        </p>

        <p>
            Les caractères autorisés dépendent donc complètement de la langue utilisée.
        </p>

        <p>
            Il existe actuellement 3 langues qui ne sont pas supportées pour ce validateur. Il s'agit
            de <span class="emphasis"><em>coréen</em></span>, <span class="emphasis"><em>japonais</em></span> et
            <span class="emphasis"><em>chinois</em></span> car ces langues utilisent un alphabet dans lequel un seul
            caractère est fabriqué à base de multiples caractères.
        </p>

        <p>
            Dans le cas où vous utilisez ces langues, seule l'alphabet anglais sera utilisé pour la
            validation.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.barcode"></a>Barcode</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Barcode</code> permet de vérifier si une donnée représente
        un code barres.
    </p>

    <p>
        <code class="classname">Zend_Validate_Barcode</code> supporte de multiples standards de codes à barres
        et peut être étendu pour les codes barres propriétaires. Les formats suivants sont supportés:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE25</em></span>: Aussi appelé "two of five" ou "Code25 Industrial".
            </p>

            <p>
                Ce code n'a pas de limite de taille. Il supporte les chiffres et le dernier chiffre
                peut être une somme de contrôle optionnelle calculée sur un modulo 10. Ce standard est
                très vieux et plus trop utilisé. Les cas d'utilisations classiques sont l'industrie
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE25INTERLEAVED</em></span>: Aussi appelé "Code 2 of 5 Interleaved".
            </p>

            <p>
                C'est une variante de CODE25. Il n'a pas de limite de taille mais il doit contenir un
                nombre de caractères pair. Il supporte uniquement les chiffres et le dernier chiffre
                peut être une somme de contrôle optionnelle calculée sur un modulo 10. Il est utilisé
                au travers le monde et typiquement dans l'industrie / la distribution.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE39</em></span>: CODE39 est un des codes les plus vieux.
            </p>

            <p>
                Ce code a une taille variable. Il supporte les chiffres, les lettres majuscules, et 7 caractères
                spéciaux comme l'espace, le point ou le signe dollar. Il peut posséder optionnellement une somme
                de contrôle calculée sur un modulo 43. Il est utilisé dans le monde, dans l'industrie.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE39EXT</em></span>: CODE39EXT est une extension de CODE39.
            </p>

            <p>
                Ce code à barres a les mêmes propriétés que CODE39. Aussi, il autorise l'utilisation de tous les
                caractères ASCII (128). Ce standard est très utilisé dans l'industrie, dans le monde.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE93</em></span>: CODE93 est le successeur de CODE39.
            </p>

            <p>
                Ce code a une taille variable. Il supporte les chiffres, les lettres de l'alphabet et 7 caractères
                spéciaux. Il possède optionnellement une somme de contrôle à 2 caractères calculée sur un modulo 47.
                Ce standard produit un code plus dense que CODE39 et est plus sécurisé.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>CODE93EXT</em></span>: CODE93EXT est une extension de CODE93.
            </p>

            <p>
                Ce type de code à barres a les mêmes propriétés que CODE93. Aussi, il permet l'utilisation des 128
                caractères du jeu ASCII. Ce standard est utilisé dans le monde et principalement dans l'industrie.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN2</em></span>: EAN est un raccourci de "European Article Number".
            </p>

            <p>
                Ces codes ont deux caractères. Seuls les chiffres sont supportés et ils n'ont pas de
                somme de contrôle. Ce standard est utilisé principalement en plus de EAN13 (ISBN) sur
                les livres imprimés.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN5</em></span>: EAN est un raccourci pour "European Article Number".
            </p>

            <p>
                Ce code barres doit comporter 5 caractères. Il ne supporte que les chiffres et ne possède pas de
                somme de contrôle. Ce standard est principalement utilisé en plus de EAN13 (ISBN) pour
                l'impression de livres.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN8</em></span>: EAN est un raccourci pour "European Article Number".
            </p>

            <p>
                Ce code barres se compose de 7 ou 8 caractères. Il supporte les chiffres uniquement. Lorsqu'il est
                à 8 caractères, il inclut une somme de contrôle. Ce standard est utilisé dans le monde mais pour
                des besoins limités. On le trouve pour les petits articles où un code barres plus long n'aurait
                pas pu être imprimé.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN12</em></span>: EAN est un raccourci pour "European Article Number".
            </p>

            <p>
                Ce code doit faire 12 caractères de long. Il ne supporte que les chiffres et le dernier chiffre est
                une somme de contrôle calculée sur un modulo 10. C'est un code utilisé aux Etats-Unis et courant
                sur le marché. Il a été dépassé par EAN13.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN13</em></span>: EAN est un raccourci pour "European Article Number".
            </p>

            <p>
                Ce code doit faire 13 caractères de long, il ne supporte que les chiffres et le dernier chiffre est
                une somme de contrôle calculée sur un modulo 10. Ce standard est utilisé dans le monde et est très
                commun sur le marché.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN14</em></span>: EAN est un raccourci pour "European Article Number".
            </p>

            <p>
                Ce code fait 14 caractères de longueur et ne supporte que les chiffres. Le dernier chiffre
                représente la somme de contrôle calculée sur un modulo 10. Ce code barres est utilisé dans
                le monde pour la distribution. C'est le successeur de EAN13.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>EAN18</em></span>: EAN est un raccourci pour "European Article Number".
            </p>

            <p>
                Ce code fait 18 caractères de longueur et ne supporte que les chiffres. Le dernier chiffre
                représente la somme de contrôle calculée sur un modulo 10. Ce code barres est utilisé pour
                identifier les conteneur d'envoi dans le transport.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>GTIN12</em></span>: GTIN est le raccourci de "Global Trade Item Number".
            </p>

            <p>
                Ce code utilise le même standard que EAN12 et est son successeur. Il est utilisé paticulièrement
                aux Etats-Unis.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>GTIN13</em></span>: GTIN est le raccourci de "Global Trade Item Number".
            </p>

            <p>
                Ce code utilise le même standard que EAN13 et est son successeur. Il est utilisé dans le monde
                entier par l'industrie.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>GTIN14</em></span>: GTIN est le raccourci de "Global Trade Item Number".
            </p>

            <p>
                Ce code utilise le même standard que EAN14 et est son successeur. Il est utilisé dans le monde
                entier par l'industrie.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>IDENTCODE</em></span>: Identcode est utilisé par Deutsche Post et DHL. C'est
                un cas particulier de Code25.
            </p>

            <p>
                Ce code fait 12 caractères de longueur et ne supporte que les chiffres. Le dernier chiffre
                représente la comme de contrôle calculée modulo 10. Ce code barres est utilisé principalement
                par les entreprises DP et DHL.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>INTELLIGENTMAIL</em></span>: Intelligent Mail est utilisé par les services postaux.
            </p>

            <p>
                Ce code fait 20, 25, 29 ou 31 caractères de longueur. Il ne support que les chiffres et ne
                contient pas de somme de contrôle. Il est le successeur de <acronym class="acronym">PLANET</acronym> et
                <acronym class="acronym">POSTNET</acronym>. Il est utilisé principalement dans les services postaux aux
                Etats-Unis.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>ISSN</em></span>: <acronym class="acronym">ISSN</acronym> est l'abréviation de
                International Standard Serial Number.
            </p>

            <p>
                Ce code a une longueur de 8 ou 13 caractères. Il ne supporte que les chiffres et le dernier
                chiffre représente la somme de contrôle calculée sur un modulo 11. Il est utilisé dans
                le print à travers le monde.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>ITF14</em></span>: ITF14 est l'implémentation GS1 de Interleaved Two
                of Five bar code.
            </p>

            <p>
                Ce code est une implémentation particulière de Interleaved 2 of 5. Il doit mesurer
                14 caractères de long et est basé sur GTIN14. Il ne contient que des chiffres et le dernier
                chiffre est une somme de contrôle calculée sur un modulo 10. Il est utilisé dans le monde
                dans la distribution.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>LEITCODE</em></span>: Leitcode est utilisé par Deutsche Post et DHL. C'est un cas
                particulier de Code25.
            </p>

            <p>
                Ce code mesure 14 caractères de longueur et ne supporte que les chiffres. Le dernier chiffre
                est une somme de contrôle calculée sur un modulo 10. Il est principalement utilisé par
                les entreprises DP et DHL.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>PLANET</em></span>: Planet est l'abréviation de Postal Alpha Numeric
                Encoding Technique.
            </p>

            <p>
                Ce code fait 12 ou 14 caractères de long. Il ne supporte que les chiffres et le dernier
                chiffre est une somme de contrôle. Ce code barres est utilisé principalement dans les
                services postaux des Etats-Unis.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>POSTNET</em></span>: Postnet est utilisé par le service des Postes des
                Etats-Unis.
            </p>

            <p>
                Ce code fait 6, 7, 10 ou 12 caractères. Il ne supporte que les chiffres et le dernier
                chiffre est une somme de contrôle. Ce code barres est utilisé dans les services postaux
                aux Etats-Unis principalement.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>ROYALMAIL</em></span>: Royalmail est utilisé par Royal Mail.
            </p>

            <p>
                Ce code n'a pas de taille précise. Il supporte les chiffres, les lettres majuscules et le
                dernier caractère est une somme de contrôle. Ce standard est utilisé par Royal Mail pour le
                service Cleanmail. Il est aussi appelé <acronym class="acronym">RM4SCC</acronym>.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>SSCC</em></span>: SSCC est un raccourci pour "Serial Shipping Container
                Code".
            </p>

            <p>
                Ce code est une variante de EAN, il doit faire 18 caractères de long et ne supporte que
                les chiffres. Le dernier chiffre doit être la somme de contrôle qui est calculée sur un
                modulo 10. Ce code est utilisé principalement dans le transport.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>UPCA</em></span>: UPC est le raccourci de "Univeral Product Code".
            </p>

            <p>
                Ce code a précédé EAN13. Il doit faire 12 caractères et ne supporte que les chiffres.
                Le dernier chiffre est une somme de contrôle calculée sur un modulo 10. Ce code barres
                est utilisé aux Etats-Unis.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>UPCE</em></span>: UPCE est une variante simplifié et plus courte de UPCA.
            </p>

            <p>
                Il peut faire 6, 7 ou 8 caractères et ne supporte que les chiffres. Lorsqu'il fait 8
                caractères, il inclut une somme de contrôle calculée sur un modulo 10. Ce code barres
                est utilisé sur de petits produits sur lesquels UPCA ne pourrait pas tenir.
            </p>
        </li>
</ul></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.options"></a>Options supportées par Zend_Validate_Barcode</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Validate_Barcode</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">adapter</span></em></span>: Affecte l'adaptateur de code
                    barres à utiliser. La liste des adaptateurs est donnée ci-dessus. Si vous voulez préciser
                    un adaptateur personnalisé, le nom complet de la classe est requis.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">checksum</span></em></span>: <code class="constant">TRUE</code>
                    si oui ou non utiliser une somme de contrôle. Notez que certains adaptateurs ne supportent
                    pas un telle option.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">options</span></em></span>: Affecte des options personnalisées pour
                    un adaptateur personnalisé.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.basic"></a>Utilisation classique</h4></div></div></div>
        

        <p>
            Pour valider si une chaine est un code barres, vous devez juste connaitre son type. Voyez l'exemple
            suivant pour un EAN13:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Barcode('EAN13');
if ($valid-&gt;isValid($input)) {
    // input semble être valide
} else {
    // input est invalide
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.checksum"></a>Somme de contrôle optionnelle</h4></div></div></div>
        

        <p>
            Certains codes barres proposent une somme de contrôle. Ils peuvent être valides sans cette
            somme mais si vous préciser celle-la alors elle devra être validée. Par défaut la somme
            de contrôle n'est pas activée. En utilisant l'option <span class="property">checksum</span> vous pouvez
            indiquer si oui ou non la somme de contrôle doit être vérifiée.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Barcode(array(
    'adapter'  =&gt; 'EAN13',
    'checksum' =&gt; false,
));
if ($valid-&gt;isValid($input)) {
    // input semble être valide
} else {
    // input est invalide
}
</pre>

        <div class="note"><table border="0" summary="Note: Sécurité moindre en désactivant la validation de la somme de contrôle">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Sécurité moindre en désactivant la validation de la somme de contrôle</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                 En désactivant la validation de la somme de contrôle vous réduirez la sécurité du
                 code à barres. Aussi veuillez noter que si vous désactiver ce contrôle pour des
                 codes l'utilisant vous risqueriez de considérer comme valides des codes barres
                 qui ne le sont pas en réalité.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.barcode.custom"></a>Ecrire des validateurs personnalisés</h4></div></div></div>
        

        <p>
            Vous pouvez créer vos propres validateurs pour <code class="classname">Zend_Validate_Barcode</code>;
            ce qui est nécessaire si vous traitez des codes barres propriétaires. Vous aurez alors besoin
            des informations suivantes.
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Length</em></span>: La taille du code barres. Peut être une des valeur suivantes:
                </p>

                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>Integer</em></span>: Une valeur plus grande que zéro qui définit exactement
                            le nombre de caractères du code barres.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>-1</em></span>: Aucune limite de taille pour ce code barres.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>"even"</em></span>: La taille du code barres doit être un nombre
                            de caractères pair.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>"odd"</em></span>: La taille du code barres doit être un nombre
                            de caractères impair.
                        </p>
                    </li>
<li class="listitem">
                        <p>
                            <span class="emphasis"><em>array</em></span>: Un tableau de valeurs entières. La taille du code
                            barres doit être exactement égale à une des valeurs dans le tableau.
                        </p>
                    </li>
</ul></div>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Characters</em></span>: Une chaine qui contient tous les caractères autorisés
                    pour ce code barres. La valeur entière spéciale 128 est autorisée ici, elle signifie
                    "les 128 premiers caractères du jeu ASCII".
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Checksum</em></span>: Une chaine utilisée comme callback pour valideer la
                    somme de contrôle.
                </p>
            </li>
</ul></div>

        <p>
            Votre validateur de code à barres personnalisé doit étendre
            <code class="classname">Zend_Validate_Barcode_AdapterAbstract</code> ou implémenter
            <span class="interface">Zend_Validate_Barcode_AdapterInterface</span>.
        </p>

        <p>
            Comme exemple, créons un validateur qui utilise un nombre pair de caractères pouvant être des
            chiffres et les lettres 'ABCDE'. Une somme de contrôle sera aussi calculée.
        </p>

        <pre class="programlisting">
class My_Barcode_MyBar extends Zend_Validate_Barcode_AdapterAbstract
{
    protected $_length     = 'even';
    protected $_characters = '0123456789ABCDE';
    protected $_checksum   = '_mod66';

    protected function _mod66($barcode)
    {
        // effectuer de la validation et retourner un booléen
    }
}

$valid = new Zend_Validate_Barcode('My_Barcode_MyBar');
if ($valid-&gt;isValid($input)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.between"></a>Between</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Between</code> permet de valider qu'une valeur
        soit bien comprise entre deux bornes.
    </p>

    <div class="note"><table border="0" summary="Note: Zend_Validate_Between ne supporte que les nombres">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Zend_Validate_Between ne supporte que les nombres</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            Zend_Validate_Between ne supporte pas les chaines ou les dates.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.between.options"></a>Options gérées par Zend_Validate_Between</h4></div></div></div>
        

        <p>
            Les options suivantes sont reconnues par <code class="classname">Zend_Validate_Between</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">inclusive</span></em></span>: Défini si les bornes sont
                    inclusives dans la validation (min et max). Par défaut, <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">min</span></em></span>: Affecte la borne inférieure.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">max</span></em></span>: Affecte la borne supérieure.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.between.basic"></a>Comportement par défaut de Zend_Validate_Between</h4></div></div></div>
        

        <p>
            Par défaut ce validateur vérifie sur la valeur est entre <span class="property">min</span> et
            <span class="property">max</span> inclusivement pour les deux bornes.
        </p>

        <pre class="programlisting">
$valid  = new Zend_Validate_Between(array('min' =&gt; 0, 'max' =&gt; 10));
$value  = 10;
$result = $valid-&gt;isValid($value);
// retourne true
</pre>

        <p>
            Dans l'exemple ci-dessus, <code class="constant">TRUE</code> est retourné car par défaut les bornes
            supérieures et inférieures sont inclusives. Toute valeur depuis '0' à '10' sont donc
            autorisées et reconnues. '-1' et '11' auraient retourné <code class="constant">FALSE</code>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.between.inclusively"></a>Validation exclusive sur les bornes</h4></div></div></div>
        

        <p>
            Il peut être nécessaire d'exclure les bornes dans la validation. Voyez l'exemple qui suit:
        </p>

        <pre class="programlisting">
$valid  = new Zend_Validate_Between(
    array(
        'min' =&gt; 0,
        'max' =&gt; 10,
        'inclusive' =&gt; false
    )
);
$value  = 10;
$result = $valid-&gt;isValid($value);
// retourne false
</pre>

        <p>
            L'exemple ci-dessus fait en sorte que '0' et '10' retournent <code class="constant">FALSE</code>.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.callback"></a>Callback (fonction de rappel)</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Callback</code> permet de fournir une fonction de rappel
        utilisée pour valider la valeur.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.options"></a>Options supportées par Zend_Validate_Callback</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_Callback</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">callback</span></em></span> : spécifie la fonction
                    de rappel qui sera utilisée pour la validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">options</span></em></span> : spécifie les options
                    additionnelles qui seront fournies à la fonction de rappel.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.basic"></a>Utilisation classique</h4></div></div></div>
        

        <p>
            Le plus simple est de posséder une fonction classique, qui sera utilisée
            pour valider la donnée. Soit la fonction ci-après :
        </p>

        <pre class="programlisting">
function myMethod($value)
{
    // ici de la validation à effectuer
    return true;
}
</pre>

        <p>
            Pour l'utiliser avec<code class="classname">Zend_Validate_Callback</code> vous devez simplement
            effectuer votre appel comme ceci:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback('myMethod');
if ($valid-&gt;isValid($input)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.closure"></a>Utilisation avec les fonctions anonymes (closures)</h4></div></div></div>
        

        <p>
            PHP 5.3 introduit les <a class="ulink" href="http://php.net/functions.anonymous" target="_top">fonctions
            anonymes</a> ou fonctions de <span class="emphasis"><em>fermeture</em></span>. PHP traite les
            fonctions anonymes comme des fonctions de rappel valides, et il est donc
            possible d'utiliser celles-ci avec <code class="classname">Zend_Validate_Callback</code>.
            Exemple:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(function($value){
    // Validation ici
    return true;
});

if ($valid-&gt;isValid($input)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.class"></a>Utilisation avec les méthodes de rappel</h4></div></div></div>
        

        <p>
            Bien sûr, il est aussi possible d'utiliser des méthodes de rappel:
        </p>

        <pre class="programlisting">
class MyClass
{
    public function myMethod($value)
    {
        // Validation ici
        return true;
    }
}
</pre>

        <p>
            La définition de la fonction de rappel se fait alors dans un tableau contenant un
            objet de la classe et la méthode à appeler:
        </p>

        <pre class="programlisting">
$object = new MyClass;
$valid = new Zend_Validate_Callback(array($object, 'myMethod'));
if ($valid-&gt;isValid($input)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>

        <p>
            Il est aussi possible d'utiliser une méthode statique comme fonction de rappel:
        </p>

        <pre class="programlisting">
class MyClass
{
    public static function test($value)
    {
        // Validation ici
        return true;
    }
}

$valid = new Zend_Validate_Callback(array('MyClass', 'test'));
if ($valid-&gt;isValid($input)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>

        <p>
            Enfin, PHP 5.3 définit la méthode magique <code class="methodname">__invoke()</code>.
            Si vous l'utilisez, alors un simple objet suffira comme fonction de rappel:
        </p>

        <pre class="programlisting">
class MyClass
{
    public function __invoke($value)
    {
        // Validation ici
        return true;
    }
}

$object = new MyClass();
$valid = new Zend_Validate_Callback($object);
if ($valid-&gt;isValid($input)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.callback.options2"></a>Ajouter des options</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Callback</code> permet d'utiliser des options, celles-ci
            seront alors passées comme argument supplémentaires à la fonction de callback.
        </p>

        <p>
            Soit la définition suivante:
        </p>

        <pre class="programlisting">
class MyClass
{
    function myMethod($value, $option)
    {
        // De la validation ici
        return true;
    }
}
</pre>

        <p>
            Il extsite deux manières d'indiquer des options au validateur : via le constructeur ou sa
            méthode <code class="methodname">setOptions()</code>.
        </p>

        <p>
            Via le constructeur, passez un tableau contenant les clés "callback" et "options":
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(array(
    'callback' =&gt; array('MyClass', 'myMethod'),
    'options'  =&gt; $option,
));

if ($valid-&gt;isValid($input)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>

        <p>
            Sinon, vous pouvez passer les options après:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(array('MyClass', 'myMethod'));
$valid-&gt;setOptions($option);

if ($valid-&gt;isValid($input)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>

        <p>
            Si des valeurs supplémentaires sont passées à <code class="methodname">isValid()</code> elles
            seront utilisées comme arguments supplémentaires lors de l'appel à la fonction de rappel,
            mais avant les options <code class="varname">$options</code>.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Callback(array('MyClass', 'myMethod'));
$valid-&gt;setOptions($option);

if ($valid-&gt;isValid($input, $additional)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>

        <p>
            Lors de l'appel à la fonction de rappel, la valeur à valider sera toujours passée comme premier argument
            à la fonction de rappel suivie de toutes les autres valeurs passées à
            <code class="methodname">isValid()</code>; les autres options suivront. Le nombre et le type d'options qui
            peuvent être utilisées est illimité.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.creditcard"></a>CreditCard</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_CreditCard</code> permet de valider si une valeur est susceptible
        de représenter un numéro de carte de crédit.
    </p>

    <p>
        Une carte de crédit contient plein de données, incluant un hologramme, un numéro de compte,
        un logo, une date d'expiration, un code de sécurité et le nom du détenteur. L'algorithme
        qui vérifie la combinaison de ces données n'est connu que des entreprises délivrant les cartes
        et devrait être vérifié lors d'un paiement. Cependant, il est utile de savoir si le numéro de
        la carte est valable <span class="emphasis"><em>avant</em></span> d'effectuer de telles vérifications complexes.
        <code class="classname">Zend_Validate_CreditCard</code> vérifie simplement que le numéro est bien formé.
    </p>

    <p>
        Dans les cas où vous possederiez un service capable d'effectuer des vérifications complètes,
        <code class="classname">Zend_Validate_CreditCard</code> vous permet de passer une fonction de rappel
        à utiliser si le numéro a été vérifié comme valide. Le retour de la fonction de rappel
        servira alors de retour général du validateur.
    </p>

    <p>
        Les institutions suivantes sont acceptées:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <p>
                <span class="emphasis"><em>American Express</em></span>
            </p>

            <p>
                <span class="emphasis"><em>China UnionPay</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Diners Club Card Blanche</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Diners Club International</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Diners Club US &amp; Canada</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Discover Card</em></span>
            </p>

            <p>
                <span class="emphasis"><em>JCB</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Laser</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Maestro</em></span>
            </p>

            <p>
                <span class="emphasis"><em>MasterCard</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Solo</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Visa</em></span>
            </p>

            <p>
                <span class="emphasis"><em>Visa Electron</em></span>
            </p>
        </li></ul></div>

    <div class="note"><table border="0" summary="Note: Institutions non valides">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Institutions non valides</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            <span class="emphasis"><em>Bankcard</em></span> et <span class="emphasis"><em>Diners Club
                enRoute</em></span> n'existent plus, elles sont donc considérées non valides.
        </p>

        <p>
            <span class="emphasis"><em>Switch</em></span> est rattaché à <span class="emphasis"><em>Visa</em></span> et est donc
            considérée comme non valide.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.options"></a>Options supportées par  Zend_Validate_CreditCard</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_CreditCard</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">service</span></em></span> : une fonction de rappel
                    vers un service en ligne qui sera utilisé en plus pour la validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span> : le type de carte crédit
                    qui sera validée. Voir ci-dessous la liste des institutions pour de plus
                    amples détails.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.basic"></a>Utilisation classique</h4></div></div></div>
        

        <p>
            Il y a plusieurs institutions qui peuvent être validées par
            <code class="classname">Zend_Validate_CreditCard</code>. Par défaut, toutes les institutions
            connues sont acceptées:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard();
if ($valid-&gt;isValid($input)) {
    // input semble valide
} else {
    // input est invalide
}
</pre>

        <p>
            L'exemple ci-dessus valide le numéro pour toutes les institutions connues.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.institute"></a>Accepter seulement certains types de cartes</h4></div></div></div>
        

        <p>
            Il peut arriver que vous ne vouliez valider que certains types de cartes plutôt que
            toutes les institutions connues. <code class="classname">Zend_Validate_CreditCard</code> permet
            ceci.
        </p>

        <p>
            Pour utiliser une limite, spécifiez les institutions accéptées à l'initialisation ou après,
            grâce à <code class="methodname">setType()</code>. Plusieurs arguments sont utilisables.
        </p>

        <p>
            Vous pouvez préciser une seule institution:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard(
    Zend_Validate_CreditCard::AMERICAN_EXPRESS
);
</pre>

        <p>
            Plusieurs institutions se précisent au moyen d'un tableau:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard(array(
    Zend_Validate_CreditCard::AMERICAN_EXPRESS,
    Zend_Validate_CreditCard::VISA
));
</pre>

        <p>
            Et comme pour tout validateur, vous pouvez passer un tableau global ou un objet
            <code class="classname">Zend_Config</code>. Dans ce cas, les institutions se précisent au moyen
            de la clé <span class="property">type</span>:
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard(array(
    'type' =&gt; array(Zend_Validate_CreditCard::AMERICAN_EXPRESS)
));
</pre>

        <div class="table">
<a name="zend.validate.set.creditcard.institute.table"></a><p class="title"><b>Tableau 171. Constante représentant les institutions</b></p>
<div class="table-contents">
            
            <table class="table" summary="Constante représentant les institutions" border="1">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Institution</th>
<th>Constante</th>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>American Express</em></span></td>
<td><code class="constant">AMERICAN_EXPRESS</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>China UnionPay</em></span></td>
<td><code class="constant">UNIONPAY</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>Diners Club Card Blanche</em></span></td>
<td><code class="constant">DINERS_CLUB</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>Diners Club International</em></span></td>
<td><code class="constant">DINERS_CLUB</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>Diners Club US &amp; Canada</em></span></td>
<td><code class="constant">DINERS_CLUB_US</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>Discover Card</em></span></td>
<td><code class="constant">DISCOVER</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>JCB</em></span></td>
<td><code class="constant">JCB</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>Laser</em></span></td>
<td><code class="constant">LASER</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>Maestro</em></span></td>
<td><code class="constant">MAESTRO</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>MasterCard</em></span></td>
<td><code class="constant">MASTERCARD</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>Solo</em></span></td>
<td><code class="constant">SOLO</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>Visa</em></span></td>
<td><code class="constant">VISA</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><span class="emphasis"><em>Visa Electron</em></span></td>
<td><code class="constant">VISA</code></td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
<td class="auto-generated"> </td>
</tr>
</tbody>
</table>
        </div>
</div>
<br class="table-break">

        <p>
            Vous pouvez aussi configurer les institutions valides après la construction,
            au moyen des méthodes
            <code class="methodname">setType()</code>, <code class="methodname">addType()</code> et
            <code class="methodname">getType()</code>.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_CreditCard();
$valid-&gt;setType(array(
    Zend_Validate_CreditCard::AMERICAN_EXPRESS,
    Zend_Validate_CreditCard::VISA
));
</pre>

        <div class="note"><table border="0" summary="Note: Institution par défaut">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Institution par défaut</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Si vous ne précisez pas d'institution à la construction, alors <code class="constant">ALL</code>
                sera utilisée, et donc toutes les institutions seront utilisées.
            </p>

            <p>
                Dans ce cas, utiliser <code class="methodname">addType()</code> ne sert à rien.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.creditcard.servicecheck"></a>Validation par fonction de rappel</h4></div></div></div>
        

        <p>
            Comme déja dit, <code class="classname">Zend_Validate_CreditCard</code> ne valide que le numéro
            de la carte. Heureusement, certaines institutions proposent des
            <acronym class="acronym">API</acronym>s pour valider des numéros de carte de crédit qui ne sont
            pas publiques. Ces services sont très souvent payants, ainsi cette vérification est par
            défaut désactivée.
        </p>

        <p>
            Lorsque vous avez accès à de telles <acronym class="acronym">API</acronym>s, vous pouvez les utiliser
            comme fonctions additionnelles à <code class="classname">Zend_Validate_CreditCard</code> et ainsi
            augmenter la sécurité de la validation.
        </p>

        <p>
            Pour ce faire, vous devez simplement préciser une fonction de rappel qui sera appelée
            après que la validation "classique" ait réussi. Ceci évite un appel à l'
            <acronym class="acronym">API</acronym> avec un numéro de toute façon non valide et augmentera ainsi
            les performances de la validation et donc de l'application.
        </p>

        <p>
            <code class="methodname">setService()</code> et
            <code class="methodname">getService()</code> sont utilisée pour la fonction de rappel.
            La clé de configuration à utiliser, si vous le souhaitez, est '<span class="property">service</span>'
            (à la construction). Des détails peuvent être trouvés sur la documentation du validateur<a class="link" href="zend.validate.set.html#zend.validate.set.callback" title="Callback (fonction de rappel)">Callback</a>.
        </p>

        <pre class="programlisting">
// Votre classe de service
class CcService
{
    public function checkOnline($cardnumber, $types)
    {
        // Processus de validation ici
    }
}

// La validation
$service = new CcService();
$valid   = new Zend_Validate_CreditCard(Zend_Validate_CreditCard::VISA);
$valid-&gt;setService(array($service, 'checkOnline'));
</pre>

        <p>
            Ici le service sera appelé avec le numéro de carte comme premier paramètre,
            et les types accéptés comme second.
        </p>
    </div>
</div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.ccnum"></a>Ccnum</h3></div></div></div>
        

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Le validateur <code class="classname">Ccnum</code> a été déprécié en faveur du validateur
                <code class="classname">CreditCard</code>. Pour des raisons de sécurité, vous devriez
                utiliser CreditCard au lieu de Ccnum.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.date"></a>Date</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Date</code> permet de valider qu'une donnée est bien une date.
        Le validateur gère la localisation.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.date.options"></a>Options supportées par Zend_Validate_Date</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Validate_Date</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">format</span></em></span>: affecte le format utilisé
                    pour écrire la date.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: affecte la locale utilisée lors
                    de la validation.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.date.basic"></a>Validation de dates par défaut</h4></div></div></div>
        

        <p>
            La manière la plus simple de valider une date est d'utiliser le format par défaut du
            système. Ce format est utilisé lorsqu'aucune locale et aucun format particulier n'est
            précisé. Voyez l'exemple ci-après:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Date();

$validator-&gt;isValid('2000-10-10');   // retourne true
$validator-&gt;isValid('10.10.2000'); // retourne false
</pre>

        <p>
            Le format par défaut de <code class="classname">Zend_Validate_Date</code> est 'yyyy-MM-dd'.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.date.localized"></a>Validation de dates localisées</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Date</code> peut aussi valider les dates dans un format localisé
            donné. En utilisant l'option <span class="property">locale</span> vous pouvez définir la locale utilisée
            pour valider le format de la date.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Date(array('locale' =&gt; 'de'));

$validator-&gt;isValid('10.Feb.2010'); // retourne true
$validator-&gt;isValid('10.May.2010'); // retourne false
</pre>

        <p>
            L'option <span class="property">locale</span> affecte le format par défaut de la date. Dans l'exemple ci-dessus
            il s'agit de 'dd.MM.yyyy' qui est le format pour une locale 'de'.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.date.formats"></a>Formats de dates personnalisés</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Date</code> supporte des formats de date personnalisés.
            Utilisez l'option <span class="property">format</span> pour cela.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Date(array('format' =&gt; 'yyyy'));

$validator-&gt;isValid('2010'); // retourne true
$validator-&gt;isValid('May');  // retourne false
</pre>

        <p>
            Vous pouvez combiner <span class="property">format</span> et <span class="property">locale</span>.
            Dans ce cas vous pouvez utiliser des noms de mois ou de jours localisés.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Date(array('format' =&gt; 'yyyy MMMM', 'locale' =&gt; 'de'));

$validator-&gt;isValid('2010 Dezember'); // retourne true
$validator-&gt;isValid('2010 June');     // retourne false
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.Db"></a>Db_RecordExists et Db_NoRecordExists</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Db_RecordExists</code> et
        <code class="classname">Zend_Validate_Db_NoRecordExists</code> permettent de vérifier si un enregistrement
        existe (ou pas) dans une table de base de données.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.db.options"></a>Options supportées par Zend_Validate_Db_*</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_Db_NoRecordExists</code> et
            <code class="classname">Zend_Validate_Db_RecordExists</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">adapter</span></em></span> : l'adaptateur de base
                    de données qui sera utilisé pour la recherche.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">exclude</span></em></span> : jeu d'enregistrements
                    qui seront exclus de la recherche.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">field</span></em></span> : le champs dans la table
                    de la base de données dans lequel sera effectué la recherche.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">schema</span></em></span> : le schéma utilisé
                    pour la recherche.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">table</span></em></span> : la table qui sera
                    utilisée pour la recherche.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.basic-usage"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voici un exemple basique:
        </p>

        <pre class="programlisting">
//Vérifie que l'email existe bien dans la base de données
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'emailaddress'
    )
);

if ($validator-&gt;isValid($emailaddress)) {
    // l'adresse email existe
} else {
    // l'adresse email n'existe pas, affichons les messages d'erreur
    foreach ($validator-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            Le code ci-dessus vérifie la présence d'une adresse email <code class="varname">$emailaddress</code>
            vis à vis d'un champ d'une table de base de données.
        </p>

        <pre class="programlisting">
//Vérifie que le nom d'utilisateur n'est pas présent dans la table
$validator = new Zend_Validate_Db_NoRecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'username'
    )
);
if ($validator-&gt;isValid($username)) {
    // Le nom d'utilisateur semble absent de la table
} else {
    // invalide : l'utilisateur est probablement présent dans la table
    $messages = $validator-&gt;getMessages();
    foreach ($messages as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            Le code ci-dessus vérifie l'absence d'un nom d'utilisateur <code class="varname">$username</code>
            vis à vis d'un champ d'une table de base de données.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.excluding-records"></a>Exclure des enregistrement</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_Db_RecordExists</code> et
            <code class="classname">Zend_Validate_Db_NoRecordExists</code> proposent aussi un moyen de tester
            la base de données en excluant certaines parties de table, en passant une clause where
            ou un tableau de paires "champs" "valeur".
        </p>

        <p>
            Lorsqu'un tableau est passé, l'opérateur <span class="emphasis"><em>!=</em></span> est utilisé et vous
            pouvez ainsi tester le reste de la table.
        </p>

        <pre class="programlisting">
// Vérifie qu'aucun autre utilisateur que celui dont l'id est spécifié,
// ne possède ce nom
$user_id   = $user-&gt;getId();
$validator = new Zend_Validate_Db_NoRecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'username',
        'exclude' =&gt; array(
            'field' =&gt; 'id',
            'value' =&gt; $user_id
        )
    )
);

if ($validator-&gt;isValid($username)) {
    // OK
} else {
    // KO
    $messages = $validator-&gt;getMessages();
    foreach ($messages as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            L'exemple ci dessus va vérifier dans la table qu'aucun autre enregistrement que celui
            pour lequel <span class="command"><strong>id = $user_id</strong></span> ne contient la valeur
            <code class="varname">$username</code>.
        </p>

        <p>
            La clause d'exclusion peut aussi être renseignée avec une chaine afin de pouvoir utiliser
            un opérateur autre que <span class="emphasis"><em>!=</em></span>.
        </p>

        <pre class="programlisting">
$email     = 'user@example.com';
$clause    = $db-&gt;quoteInto('email = ?', $email);
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table'   =&gt; 'users',
        'field'   =&gt; 'username',
        'exclude' =&gt; $clause
    )
);

if ($validator-&gt;isValid($username)) {
    // OK
} else {
    // KO
    $messages = $validator-&gt;getMessages();
    foreach ($messages as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            L'exemple ci-dessus vérifie la table 'users' pour s'assurer
            qu'un seul enregistrement avec un nom <code class="varname">$username</code> et un
            email <code class="varname">$email</code> est valide.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.database-adapters"></a>Adaptateurs de base de données</h4></div></div></div>
        

        <p>
            Un adaptateur spécifique peut être passé au validateur. Dans le cas contraire,
            il utilisera l'adaptateur déclaré comme étant celui par défaut:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table' =&gt; 'users',
        'field' =&gt; 'id',
        'adapter' =&gt; $dbAdapter
    )
);
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.db.database-schemas"></a>Nom des bases de données</h4></div></div></div>
        

        <p>
            Vous pouvez spécifier un nom de base de données (schéma) pour l'adaptateur
            PostgreSQL et DB/2 simplement grâce à un tableau possédant les clés
            <span class="property">table</span> et <span class="property">schema</span>. Voici un exemple :
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Db_RecordExists(
    array(
        'table'  =&gt; 'users',
        'schema' =&gt; 'my',
        'field'  =&gt; 'id'
    )
);
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.digits"></a>Digits</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Digits</code> valide si une donnée contient des chiffres.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.digits.options"></a>Options supportées par Zend_Validate_Digits</h4></div></div></div>
        

        <p>
            Aucun option n'est gérée par <code class="classname">Zend_Validate_Digits</code>
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.digits.basic"></a>Valider des chiffres</h4></div></div></div>
        

        <p>
            Pour valider si une donnée ne contient que des chiffres et pas d'autre caractère, appelez
            simplement le validateur comme montré dans l'exemple suivant:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Digits();

$validator-&gt;isValid("1234567890"); // retourne true
$validator-&gt;isValid(1234);         // retourne true
$validator-&gt;isValid('1a234');      // retourne false
</pre>

        <div class="note"><table border="0" summary="Note: Valider des nombres">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Valider des nombres</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Si vous voulez valider des nombres ou des valeurs numériques, faites attention car ce validateur
                ne valide que les chiffres. Ceci signifie que les signes comme les séparateurs des milliers ou
                les virgules ne seront pas pris en compte et le validateur échouera. Voyez pour ces cas
                <code class="classname">Zend_Validate_Int</code> ou <code class="classname">Zend_Validate_Float</code>.
            </p>
        </td></tr>
</table></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.email_address"></a>EmailAddress</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_EmailAddress</code> permet de valider une adresse mail.
        Ce validateur éclate d'abord l'adresse mail entre partie locale et domaine et essaie de
        valider ces deux parties conformément aux spécifications des adresses mail et des noms de
        domaine.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>Vous trouverez ci-dessous un exemple d'utilisation basique </p>

        <pre class="programlisting">
$validateur = new Zend_Validate_EmailAddress();
if ($validateur-&gt;isValid($email)) {
    // l'email est valide
} else {
    // l'email est invalide ; afficher pourquoi
    foreach ($validateur-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

        <p>
            Ceci validera l'adresse mail <code class="varname">$email</code> et, en cas d'échec,
            fournira des messages d'erreur informatifs via
            <code class="code">$validator-&gt;getMessages()</code>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.options"></a>Options for validating Email Addresses</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> supports several options which can
            either be set at initiation, by giving an array with the related options, or
            afterwards, by using <code class="methodname">setOptions()</code>. The following options are
            supported:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>allow</em></span>: Defines which type of domain names are accepted.
                    This option is used in conjunction with the hostname option to set the
                    hostname validator. For more informations about possible values of this
                    option, look at <a class="link" href="zend.validate.set.html#zend.validate.set.hostname" title="Hostname">Hostname</a>
                    and possible <code class="constant">ALLOW</code>* constants. This option defaults to
                    <code class="constant">ALLOW_DNS</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>deep</em></span>: Defines if the servers MX records should be verified
                    by a deep check. When this option is set to <code class="constant">TRUE</code> then
                    additionally to MX records also the A, A6 and <code class="constant">AAAA</code> records
                    are used to verify if the server accepts emails. This option defaults to
                    <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>domain</em></span>: Defines if the domain part should be checked.
                    When this option is set to <code class="constant">FALSE</code>, then only the local part
                    of the email address will be checked. In this case the hostname validator will
                    not be called. This option defaults to <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>hostname</em></span>: Sets the hostname validator with which the
                    domain part of the email address will be validated.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>mx</em></span>: Defines if the MX records from the server should be
                    detected. If this option is defined to <code class="constant">TRUE</code> then the MX
                    records are used to verify if the server
                    accepts emails. This option defaults to <code class="constant">FALSE</code>.
                </p>
            </li>
</ul></div>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
$validator-&gt;setOptions(array('domain' =&gt; false));
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.complexlocal"></a>Parties locales complexes</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> validera toute adresse mail
            conforme à la RFC2822. Comme par exemple <code class="code">bob@domaine.com</code>,
            <code class="code">bob+jones@domaine.fr</code>, <code class="code">"bob@jones"@domaine.com</code> et <code class="code">"bob
            jones"@domaine.com</code>. Quelques formats de mail obsolètes ne seront pas validés (comme
            toute adresse mail contenant un retour chariot ou un caractère "\").
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.purelocal"></a>Validation uniquement de la partie locale</h4></div></div></div>
        

        <p>
            Si vous avez besoin de <code class="classname">Zend_Validate_EmailAddress</code> uniquement pour
            vérifier la partie locale d'une adresse mail, et que vous souhaitez désactiver la
            validation du nom d'hôte, vous pouvez spécifier le paramètre <span class="property">domain</span>
            à la valeur <code class="constant">false</code>. Cela force <code class="classname">Zend_Validate_EmailAddress
            </code> à ne pas valider le nom d'hôte de l'adresse mail.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
$validator-&gt;setOptions(array('domain' =&gt; FALSE));
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.hostnametype"></a>Validation de différents types de noms de domaine</h4></div></div></div>
        

        <p>
            La partie domaine d'une adresse mail est validée via <a class="link" href="zend.validate.set.html#zend.validate.set.hostname" title="Hostname"><code class="classname">Zend_Validate_Hostname</code></a>.
            Par défaut, seules les domaines qualifiés sous la forme <code class="code">domaine.com</code> sont
            acceptés, même si, il vous est possible d'accepter les adresses IP et les domaines locaux
            également.
        </p>

        <p>
            Afin de réaliser cette opération, il vous faut instancier
            <code class="classname">Zend_Validate_EmailAddress</code> en lui passant un paramètre indiquant le
            type de nom de domaine à accepter. Les détails sont disponibles dans
            <code class="classname">Zend_Validate_EmailAddress</code> mais vous trouverez ci-dessous un exemple
            illustrant comment accepter les noms de domaines qualifiés et les hôtes locaux :
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress(
                    Zend_Validate_Hostname::ALLOW_DNS |
                    Zend_Validate_Hostname::ALLOW_LOCAL);
if ($validator-&gt;isValid($email)) {
    // l'email est valide
} else {
    // l'email est invalide ; afficher pourquoi
    foreach ($validateur-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.checkacceptance"></a>Vérification que le nom de domaine accepte réellement le courriel</h4></div></div></div>
        

        <p>
            Le fait qu'une adresse électronique est dans un format correct, ne signifie pas
            nécessairement que l'adresse électronique existe en réalité. Pour aider résoudre ce
            problème, vous pouvez utiliser la validation MX pour vérifier si une entrée MX (le courriel)
            existe dans le l'enregistrement du DNS pour le nom de domaine du courriel. Cela vous dit que
            le nom de domaine accepte le courriel, mais ne vous dit pas que l'adresse électronique elle-même
            est valable.
        </p>

        <p>
            La vérification MX n'est pas active par défaut et est seulement supporté par des
            plates-formes UNIX pour l'instant. Pour activer la vérification MX vous pouvez passer un
            deuxième paramètre au constructeur <code class="classname">Zend_Validate_EmailAddress</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress(
    array(
        'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
        'mx'    =&gt; true
    )
);
</pre>

        <div class="note"><table border="0" summary="Note: MX Check under Windows">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">MX Check under Windows</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Within Windows environments MX checking is only available when
                <acronym class="acronym">PHP</acronym> 5.3 or above is used. Below <acronym class="acronym">PHP</acronym> 5.3 MX
                checking will not be used even if it's activated within the options.
            </p>
        </td></tr>
</table></div>

        <p>
            Alternativement vous pouvez passer soit <code class="constant">TRUE</code> soit
            <code class="constant">FALSE</code> à <code class="code">$validator-&gt;setValidateMx()</code> pour activer ou désactiver
            la validation MX.
        </p>

        <p>
            En activant ce paramètre, les fonctions de réseau seront utilisés pour vérifier la
            présence d'un enregistrement MX sur le nom de domaine de l'adresse électronique que vous
            voulez valider. Faîtes cependant attention, cela ralentira probablement votre
            scénario.
        </p>

        <p>
            Sometimes validation for MX records returns <code class="constant">FALSE</code>, even if emails
            are accepted. The reason behind this behaviour is, that servers can accept emails even
            if they do not provide a MX record. In this case they can provide A, A6 or
            <code class="constant">AAAA</code> records. To allow
            <code class="classname">Zend_Validate_EmailAddress</code> to check also for these other records,
            you need to set deep MX validation. This can be done at initiation by setting the
            <span class="property">deep</span> option or by using <code class="methodname">setOptions()</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress(
    array(
        'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
        'mx'    =&gt; true,
        'deep'  =&gt; true
    )
);
</pre>

        <div class="warning"><table border="0" summary="Warning: Performance warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Avertissement]" src="images/warning.png"></td>
<th align="left">Performance warning</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                You should be aware that enabling MX check will slow down you script because of the
                used network functions. Enabling deep check will slow down your script even more as
                it searches the given server for 3 additional types.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: Disallowed IP addresses">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Disallowed IP addresses</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                You should note that MX validation is only accepted for external servers. When deep
                MX validation is enabled, then local IP addresses like <span class="command"><strong>192.168.*</strong></span>
                or <span class="command"><strong>169.254.*</strong></span> are not accepted.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.validateidn"></a>Valider les noms de domaines internationaux</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> peut aussi vérifier les caractères
            internationaux qui existent dans quelques domaines. Ceci est connu comme le support de Nom
            de Domaine International (IDN). Celui-ci est activé par défaut, quoique vous puissiez le
            mettre hors service en changeant le paramètre via l'objet interne
            <code class="classname">Zend_Validate_Hostname</code> qui existe dans
            <code class="classname">Zend_Validate_EmailAddress</code>.
        </p>

        <pre class="programlisting">
$validator-&gt;hostnameValidator-&gt;setValidateIdn(false);
</pre>

        <p>
            De plus amples informations concernant l'utilisation de
            <code class="methodname">setValidateIdn()</code> sont présentes dans la <a class="link" href="zend.validate.set.html#zend.validate.set.hostname" title="Hostname">documentation de
            <code class="classname">Zend_Validate_Hostname</code></a>.
        </p>

        <p>
            Notez cependant que les IDNs sont seulement validés si vous autorisez la validation
            des nom de domaines.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.validatetld"></a>Validation des "Top Level Domains"</h4></div></div></div>
        

        <p>
            Par défaut un nom de domaine sera vérifié grâce à une liste de TLDs connus. Ceci est
            activé par défaut, quoique vous puissiez le mettre hors service en changeant le paramètre
            via l'objet <code class="classname">Zend_Validate_Hostname</code> interne qui existe dans
            <code class="classname">Zend_Validate_EmailAddress</code>.
        </p>

        <pre class="programlisting">
$validator-&gt;hostnameValidator-&gt;setValidateTld(false);
</pre>

        <p>
            De plus amples informations concernant l'utilisation de
            <code class="methodname">setValidateTld()</code> sont présentes dans la <a class="link" href="zend.validate.set.html#zend.validate.set.hostname" title="Hostname">documentation de
            <code class="classname">Zend_Validate_Hostname</code></a>.
        </p>

        <p>
            Notez cependant que les TLDs sont seulement validés si vous autorisez la validation
            des nom de domaines.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.email_address.setmessage"></a>Setting messages</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Validate_EmailAddress</code> makes also use of
            <code class="classname">Zend_Validate_Hostname</code> to check the hostname part of a given
            email address. As with Zend Framework 1.10 you can simply set messages for
            <code class="classname">Zend_Validate_Hostname</code> from within
            <code class="classname">Zend_Validate_EmailAddress</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_EmailAddress();
$validator-&gt;setMessages(
    array(
        Zend_Validate_Hostname::UNKNOWN_TLD =&gt; 'I don't know the TLD you gave'
    )
);
</pre>

        <p>
            Before Zend Framework 1.10 you had to attach the messages to your own
            <code class="classname">Zend_Validate_Hostname</code>, and then set this validator within
            <code class="classname">Zend_Validate_EmailAddress</code> to get your own messages returned.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.float"></a>Float</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Float</code> permet de valider si une donnée contient une valeur
        flottante. Les entrées localisées sont supportées.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.float.options"></a>Options supportées par Zend_Validate_Float</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Validate_Float</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: Affecte la locale utilisée lors
                    de la validation.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.float.basic"></a>Validation float simple</h4></div></div></div>
        

        <p>
            Au plus simple, vous utiliserez les paramètres systèmes, c'est à dire la locale correspondant
            à l'environnement:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Float();

$validator-&gt;isValid(1234.5);   // retourne true
$validator-&gt;isValid('10a01'); // retourne false
$validator-&gt;isValid('1,234.5'); // retourne true
</pre>

        <p>
            Dans l'exemple ci-dessus, nous supposons un environnement à locale "en".
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.float.localized"></a>Validation float localisée</h4></div></div></div>
        

        <p>
            Il peut être parfois nécessire de prendre en compte la locale pour valider une valeur flottante.
            Les flottants sont souvent écrits de manière différente en fonction de la locale/région. Par exemple
            en anglais on écrirait "1.5", mais en allemand "1,5" et dans d'autres langues le regroupement de chiffres
            pourrait être utilisé.
        </p>

        <p>
            <code class="classname">Zend_Validate_Float</code> peut valider de telles notations. Il est alors limité à la locale
            utilisée. Voyez les exemples ci-après:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Float(array('locale' =&gt; 'de'));

$validator-&gt;isValid(1234.5); // retourne true
$validator-&gt;isValid("1 234,5"); // retourne false
$validator-&gt;isValid("1.234"); // retourne true
</pre>

        <p>
            Comme vous le voyez, en utilisant une locale, l'entrée est validée en fonction de celle-ci. Avec une locale
            différente vous auriez obtenu des résultats éventuellement différents.
        </p>

        <p>
            La locale peut être affectée/récupérée après la création de l'objet de validation au moyen des méthodes
            <code class="methodname">setLocale()</code> et <code class="methodname">getLocale()</code>.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.greaterthan"></a>GreaterThan</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_GreaterThan</code> permet de valider qu'une valeur est plus grande
        qu'une autre (la borne).
    </p>

    <div class="note"><table border="0" summary="Note: Zend_Validate_GreaterThan ne supporte que les nombres">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Zend_Validate_GreaterThan ne supporte que les nombres</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            Zend_Validate_GreaterThan ne fonctionnera pas avec les chaines ou les dates.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.greaterthan.options"></a>Options supportées par Zend_Validate_GreaterThan</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Validate_GreaterThan</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">min</span></em></span>: Affecte la borne inférieure.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.greaterthan.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voyez l'exemple ci-après.
        </p>

        <pre class="programlisting">
$valid  = new Zend_Validate_GreaterThan(array('min' =&gt; 10));
$value  = 10;
$return = $valid-&gt;isValid($value);
// retourne true
</pre>

        <p>
            L'exemple ci-dessus retourne <code class="constant">TRUE</code> pour toutes les valeurs égales ou
            supérieures à 10.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.hex"></a>Hex</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Hex</code> permet de valider qu'un nombre ne contienne bien que
        des caractères hexadécimaux. Ce sont les caractères de <span class="emphasis"><em>0 à 9</em></span> et de
        <span class="emphasis"><em>A à F</em></span> insensibles à la casse. Il n'existe pas de limite de longueur de
        la chaine à valider.
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_Hex();
if ($validator-&gt;isValid('123ABC')) {
    // value ne contient que des caractères hex
} else {
    // false
}
</pre>

    <div class="note"><table border="0" summary="Note: Caractères invalides">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Caractères invalides</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            Tous les autres caractères retourneront false, même l'espace et le point. Les zéros
            unicode ou les chiffres d'autres encodages que latin seront considérés comme invalides.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.hex.options"></a>Options supportées par Zend_Validate_Hex</h4></div></div></div>
        

        <p>
            Il n'y a pas d'options additionnelles supportées par <code class="classname">Zend_Validate_Hex</code>:
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.hostname"></a>Hostname</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Hostname</code> vous permet de valider un nom de domaine
        sur la base d'un ensemble de spécifications connues. Il est ainsi possible de valider trois
        types différents de noms de domaine : un nom de domaine qualifié (ex : domaine.com), une
        adresse IP (ex : 1.2.3.4) ou un nom de domaine local (ex : localhost). Par défaut, seul les
        noms de domaine qualifiés sont acceptés.
    </p>

    <p><span class="emphasis"><em>Utilisation basique</em></span></p>

    <p>
        Exemple simple : </p>
<pre class="programlisting">
$validateur = new Zend_Validate_Hostname();
if ($validateur-&gt;isValid($domaine)) {
    // le nom de domaine est valide
} else {
    // le nom de domaine est invalide ; afficher pourquoi
    foreach ($validateur-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>
<p> Ceci validera le domaine <code class="varname">$domaine</code> et, en cas d'échec, fournira
        des messages d'erreur informatifs via <code class="code">$validator-&gt;getMessages()</code>.
    </p>

    <p><span class="emphasis"><em>Validation de différents types de noms de domaine</em></span></p>

    <p>
        Il peut se trouver que vous souhaitez valider des adresses IP, des noms de domaine
        locaux ou toute combinaison de tous les types disponibles. Cette opération peut être
        effectuée en passant un paramètre à <code class="classname">Zend_Validate_Hostname</code> au moment
        de l'instanciation. Le paramètre doit être un entier qui détermine quels types de noms de
        domaine sont admis. Il est recommandé d'utiliser les constantes de la classe
        <code class="classname">Zend_Validate_Hostname</code>.
    </p>

    <p>
        Les constantes de <code class="classname">Zend_Validate_Hostname</code> sont :
        <code class="constant">ALLOW_DNS</code> qui autorise uniquement les noms de domaine qualifiés,
        <code class="constant">ALLOW_IP</code> qui autorise les adresses IP, <code class="constant">ALLOW_LOCAL</code> qui autorise
        les domaines locaux et <code class="constant">ALLOW_ALL</code> qui autorise les trois types précédents. Pour
        vérifier uniquement les adresses IP, vous pouvez utiliser l'exemple suivant :
        </p>
<pre class="programlisting">
$validateur = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_IP);
if ($validateur-&gt;isValid($hostname)) {
    // le nom de domaine est valide
} else {
    // le nom de domaine est invalide ; afficher pourquoi
    foreach ($validateur-&gt;getMessages() as $message) {
        echo "$message\n";
    }
}
</pre>

    <p>
        Vous pouvez utiliser <code class="constant">ALLOW_ALL</code> pour accepter tous les types de domaines.
        De même, vous pouvez créer des configurations combinant ces différents types. Par exemple,
        pour accepter les domaines qualifiés et les domaines locaux, instanciez votre objet
        <code class="classname">Zend_Validate_Hostname</code> de la manière suivante : </p>
<pre class="programlisting">
$validateur = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_DNS |
                                         Zend_Validate_Hostname::ALLOW_IP);
</pre>

        <p><span class="emphasis"><em>Validation de Nom de Domaine International (IDN)</em></span></p>

    <p>
        Certains noms de domaines nationaux (Country Code Top Level Domains ou ccTLD), comme
        .de (Allemagne), supporte les caractères internationaux dans leurs noms de domaine. Ceci est
        connu sous le nom de Nom de Domaine International (IDN). Ces domaines peuvent être vérifiés
        par <code class="classname">Zend_Validate_Hostname</code> grâce aux caractères étendus qui sont
        utilisés dans le processus de validation.
    </p>

    <p>
        Jusqu'à maintenant plus de 50 ccTLDs supportent les domaines IDN.
    </p>

    <p>
        Pour vérifier un domaine IDN c'est aussi simple que d'utiliser le validateur standard
        de nom de domaine puisque la validation IDN est activé par défaut. Si vous voulez mettre
        hors service la validation IDN, cela peut être fait par le passage d'un paramètre au
        constructeur <code class="classname">Zend_Validate_Hostname</code> ou via la méthode
        <code class="code">$validator-&gt;setValidateIdn()</code>.
    </p>

    <p>
        Vous pouvez aussi désactiver la validation IDN en passant un second paramètre au
        constructeur du <code class="classname">Zend_Validate_Hostname</code> comme ceci : </p>
<pre class="programlisting">
$validator =
    new Zend_Validate_Hostname(
        array(
            'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
            'idn'   =&gt; false
        )
    );
</pre>
<p> Alternativement vous pouvez passer soit <code class="constant">TRUE</code> soit
        <code class="constant">FALSE</code> à <code class="code">$validator-&gt;setValidateIdn()</code> pour activer ou désactiver
        la validation IDN. Si vous essayez de vérifier un nom de domaine IDN qui n'est pas
        actuellement soutenu il est probable qu'il retournera une erreur s'il y a des caractères
        internationaux. Quand un fichier de ccTLD spécifiant les caractères supplémentaires n'existe
        pas dans "Zend/Validate/Hostname",une validation de nom de domaine normale est
        réalisée.
    </p>

    <p>
        Notez cependant que les IDNs sont seulement validés si vous autorisez la validation
        des noms de domaine.
    </p>

    <p><span class="emphasis"><em>Validation des "Top Level Domains"</em></span></p>

    <p>
        Par défaut un nom de domaine sera vérifié grâce à une liste de TLDs connus. Si cette
        fonctionnalité n'est pas nécessaire, elle peut être désactivée de la même façon que la
        désactivation du support des IDNs. Vous pouvez désactiver la validation TLD en passant un
        troisième paramètre au constructeur de <code class="classname">Zend_Validate_Hostname</code>. Dans
        l'exemple ci-dessous, la validation IDN est supportée via le second paramètre.
        </p>
<pre class="programlisting">
$validator =
    new Zend_Validate_Hostname(
        array(
            'allow' =&gt; Zend_Validate_Hostname::ALLOW_DNS,
            'idn'   =&gt; true,
            'tld'   =&gt; false
        )
    );
</pre>
<p> Alternativement vous pouvez passer soit <code class="constant">TRUE</code> soit
        <code class="constant">FALSE</code> à <code class="code">$validator-&gt;setValidateTld()</code> pour activer ou désactiver
        la validation TLD.
    </p>

    <p>
        Notez cependant que les TLDs sont seulement validés si vous autorisez la validation
        des noms de domaine.
    </p>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.iban"></a>Iban</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Iban</code> valide si un nombre donnée est un numéro
        <acronym class="acronym">IBAN</acronym> number. <acronym class="acronym">IBAN</acronym> est l'abréviation de
        "International Bank Account Number".
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.iban.options"></a>Options supportées par Zend_Validate_Iban</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Validate_Iban</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: Affecte la locale à utiliser pour
                    la validation du format du numéro <acronym class="acronym">IBAN</acronym>.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.iban.basic"></a>Validation IBAN</h4></div></div></div>
        

        <p>
            Les numéros <acronym class="acronym">IBAN</acronym> sont toujours relatifs à un pays. Ceci signifie que différents
            pays utilisent des formats différents de numéros <acronym class="acronym">IBAN</acronym>. C'est la raison pour
            laquelle les numéros <acronym class="acronym">IBAN</acronym> ont toujours besoin d'une locale. Sachant cela, nous
            savons déja utiliser <code class="classname">Zend_Validate_Iban</code>.
        </p>

        <div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.validate.set.iban.basic.application"></a>Locale globale à l'application</h5></div></div></div>
            

            <p>
                Nous pourrions utiliser la locale globale à l'application. Ainsi si on ne passe aucune
                option à l'initialisation de <code class="classname">Zend_Validate_Iban</code>, celui-ci va chercher
                la locale globale. Voyez le code qui suit:
            </p>

            <pre class="programlisting">
// dans le bootstrap
Zend_Registry::set('Zend_Locale', new Zend_Locale('de_AT'));

// dans le module
$validator = new Zend_Validate_Iban();

if ($validator-&gt;isValid('AT611904300234573201')) {
    // IBAN est valide
} else {
    // IBAN n'est pas valide
}
</pre>

            <div class="note"><table border="0" summary="Note: Locale globale à l'application">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Locale globale à l'application</th>
</tr>
<tr><td align="left" valign="top">
                

                <p>
                    Bien sûr cela ne fonctionne que lorsqu'une locale globale a été spécifiée et enregistrée
                    dans le registre. Sinon, <code class="classname">Zend_Locale</code> va essayer d'utiliser la locale
                    que le client envoie, si aucune n'a été envoyée, la locale de l'environnement sera
                    utilisée. Méfiez-vous cela peut mener à des comportements non voulus lors de la validation.
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.validate.set.iban.basic.false"></a>Validation IBAN simplifiée</h5></div></div></div>
            

            <p>
                Il peut arriver parfois que vous ayiez juste besoin de vérifier le format du numéro
                et s'il <span class="emphasis"><em>est</em></span> un numéro <acronym class="acronym">IBAN</acronym>. Vous ne voudriez pas utiliser
                un pays particulier pour valider. Ceci peut être réalisé en passant <code class="constant">FALSE</code> en
                tant que locale.
            </p>

            <pre class="programlisting">
$validator = new Zend_Validate_Iban(array('locale' =&gt; false));
// Note: Vous pouvez aussi passer FALSE comme paramètre unique (sans tableau)

if ($validator-&gt;isValid('AT611904300234573201')) {
    // IBAN est valide
} else {
    // IBAN n'est pas valide
}
</pre>

            <p>
                Ainsi <span class="emphasis"><em>tout</em></span> numéro <acronym class="acronym">IBAN</acronym> sera valide. Notez que
                ceci ne devrait pas être utilisé si vous ne supportez qu'un seul pays.
            </p>
        </div>

        <div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.validate.set.iban.basic.aware"></a>Validation IBAN en fonction d'un pays</h5></div></div></div>
            

            <p>
                Pour valider par rapport à un pays/région, passez simplement la locale désirée.
                L'option <span class="property">locale</span> peut alors être utilisée ou la méthode
                <code class="methodname">setLocale()</code>.
            </p>

            <pre class="programlisting">
$validator = new Zend_Validate_Iban(array('locale' =&gt; 'de_AT'));

if ($validator-&gt;isValid('AT611904300234573201')) {
    // IBAN est valide
} else {
    // IBAN n'est pas valide
}
</pre>

            <div class="note"><table border="0" summary="Note: Utilisez des locales pleinement qualifiées">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Utilisez des locales pleinement qualifiées</th>
</tr>
<tr><td align="left" valign="top">
                

                <p>
                    Vous devez passer une locale pleinement qualifiée sinon le nom de la région ne
                    pourra être trouvé et utilisé.
                </p>
            </td></tr>
</table></div>
        </div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.identical"></a>Identical</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Identical</code> vous permet de valider si une valeur donnée
        est identique à une valeur préalablement fournie.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.options"></a>Options supportées par Zend_Validate_Identical</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_Identical</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">token</span></em></span> : spécifie la valeur
                    qui servira à la validation de l'entrée.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Pour valider si deux valeurs sont identiques, vous devez d'abord fournir la valeur
            d'origine. L'exemple montre la validation de deux chaînes :
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical('origin');
if ($valid-&gt;isValid($value) {
    return true;
}
</pre>

        <p>
            La validation retournera <code class="constant">TRUE</code> seulement si les deux valeurs
            sont rigoureusement identiques. Dans notre exemple, quand <code class="varname">$value</code>
            vaudra "origin".
        </p>

        <p>
            Vous pouvez aussi fournir la valeur souhaitée plus tard en utilisant la méthode
            <code class="methodname">setToken()</code> et <code class="methodname">getToken()</code> pour
            récupérer la valeur actuellement paramétrée.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.types"></a>Objets identiques</h4></div></div></div>
        

        <p>
            Bien sûr <code class="classname">Zend_Validate_Identical</code> ne se limite pas à la
            validation de chaînes, mais aussi tout type de variable comme un booléen, un
            entier, un flottant, un tableau et même les objets. Comme énoncé ci-dessus, les
            valeurs fournies et à valider doivent être identiques.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(123);
if ($valid-&gt;isValid($input)) {
    // l'entrée est valide
} else {
    // l'entrée est incorrecte
}
</pre>

        <div class="note"><table border="0" summary="Note: Comparaison de type">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Comparaison de type</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Il est important de noter que le type de la variable sert aussi lors de la
                validation. Ceci veut dire que la chaîne <span class="emphasis"><em>"3"</em></span> n'est pas
                identique à l'entier <span class="emphasis"><em>3</em></span>.
            </p>

            <p>
                Ceci est aussi valable pour les éléments de formulaires. Ce sont des objets ou
                des tableaux. Donc vous ne pouvez pas simplement comparer un champs texte qui
                contient un mot de passe avec une valeur textuelle provenant d'une autre source.
                L'élément de formualire lui-même est fourni en tant que tableau qui peut aussi
                contenir des informations additionnelles.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.identical.configuration"></a>Configuration</h4></div></div></div>
        

        <p>
            omme tous les autres validateurs <code class="classname">Zend_Validate_Identical</code>
            supporte aussi des paramètres de configuration en tant que paramètre d'entrée.
            Ceci veut dire que vous pouvez configurer ce validateur avec une objet
            <code class="classname">Zend_Config</code>.
        </p>

        <p>
            Mais ceci entraîne un changement dont vous devez tenir compte. Quand vous utilisez
            un tableau en tant qu'entrée du constructeur, vous devez envelopper la valeur
            d'origine avec la clé <span class="property">token</span>, dans ce cas elle contiendra une
            valeur unique.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(array('token' =&gt; 123));
if ($valid-&gt;isValid($input)) {
    // l'entrée est valide
} else {
    // l'entrée est incorrecte
}
</pre>

        <p>
            L'exemple ci-dessus valide l'entier 123 car vous avez fourni la valeur en l'associant
            à la clé <span class="property">token</span>.
        </p>

        <p>
            Mais, si vous devez valider un tableau qui contient un seul élément et que cet élément
            est nommé <span class="property">token</span> alors vous devez l'envelopper comme dans l'example
            ci-dessous :
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_Identical(array('token' =&gt; array('token' =&gt; 123)));
if ($valid-&gt;isValid($input)) {
    // l'entrée est valide
} else {
    // l'entrée est incorrecte
}
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.in_array"></a>InArray</h3></div></div></div>

    

    <p>
        <code class="classname">Zend_Validate_InArray</code> vous permet de valider qu'une entrée est bien présente
        dans un tableau. Ceci fonctionne aussi avec des tableaux multidimensionnels.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.in_array.options"></a>Options supportées par Zend_Validate_InArray</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_InArray</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">haystack</span></em></span> : spécifie le tableau
                    pour la validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">recursive</span></em></span> : définit si la
                    validation doit être recursive. Cette option vaut <code class="constant">FALSE</code>
                    par défaut.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">strict</span></em></span> : définit si la validation
                    doit être strict (même type). Cette option vaut <code class="constant">FALSE</code> par
                    défaut.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.in_array.basic"></a>Validation tableau simple</h4></div></div></div>
        

        <p>
            Passez simplement un tableau dans lequel rechercher une valeur:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray(array('key' =&gt; 'value',
                                             'otherkey' =&gt; 'othervalue'));
if ($validator-&gt;isValid('value')) {
    // value trouvée
} else {
    // value non trouvée
}
</pre>

        <p>
            C'est le comportement exact de la fonction PHP <code class="methodname">in_array()</code>.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Par défaut la validation est non stricte et ne valide pas les multiples dimensions.
            </p>
        </td></tr>
</table></div>

        <p>
            Bien sûr vous pouvez fournir le tableau à valider plus tard en utilisant la méthode
            <code class="methodname">setHaystack()</code>. La méthode
            <code class="methodname">getHaystack()</code> retourne le tableau actuellement fourni.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray();
$validator-&gt;setHaystack(array('key' =&gt; 'value', 'otherkey' =&gt; 'othervalue'));

if ($validator-&gt;isValid('value')) {
    // valeur trouvée
} else {
    // valeur non trouvée
}
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.in_array.strict"></a>Validation tableau stricte</h4></div></div></div>
        

        <p>
            Il est possible d'effectuer une validation stricte des données dans le tableau. Par défaut, il n'y aura aucune
            différence entre l'entier <span class="emphasis"><em>0</em></span> et la chaine <span class="emphasis"><em>"0"</em></span>. La validation stricte
            fera cette différence.
        </p>

        <p>
            Pour spécifier une validation stricte à l'instanciation de l'objet, agissez comme suit :
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray(
    array(
        'haystack' =&gt; array('key' =&gt; 'value', 'otherkey' =&gt; 'othervalue'),
        'strict'   =&gt; true
    )
);

if ($validator-&gt;isValid('value')) {
    // valeur trouvée
} else {
    // valeur non trouvée
}
</pre>

        <p>
            La clé <span class="emphasis"><em>haystack</em></span> contient le tableau dans lequel valider. En mettant la clé
            <span class="emphasis"><em>strict</em></span> à <code class="constant">TRUE</code>, la validation sera stricte (valeur et type).
        </p>

        <p>
            Bien sûr vous pouvez la méthode <code class="methodname">setStrict()</code> pour changer ce
            réglage et la méthode <code class="methodname">getStrict()</code> vous retournera le réglage
            en cours.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Notez que par défaut, <span class="emphasis"><em>strict</em></span> a la valeur
                <code class="constant">FALSE</code>.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.in_array.recursive"></a>Validation de tableaux récursifs</h4></div></div></div>
        

        <p>
            En plus de la validation type <acronym class="acronym">PHP</acronym> <code class="methodname">in_array()</code>, ce validateur peut
            aussi être utilisé pour valider des tableaux à plusieurs dimensions.
        </p>

        <p>
            Pour cela, utilisez l'option <span class="emphasis"><em>recursive</em></span>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray(
    array(
        'haystack' =&gt; array(
            'firstDimension' =&gt; array('key' =&gt; 'value',
                                      'otherkey' =&gt; 'othervalue'),
            'secondDimension' =&gt; array('some' =&gt; 'real',
                                       'different' =&gt; 'key')),
        'recursive' =&gt; true
    )
);

if ($validator-&gt;isValid('value')) {
    // value trouvée
} else {
    // value non trouvée
}
</pre>

        <p>
            Votre tableau sera parcouru récursivement à la recherche de votre valeur. De plus
            vous pouvez utiliser la méthode <code class="methodname">setRecursive()</code> pour
            paramétrer cette option plus tard et la méthode
            <code class="methodname">getRecursive()</code> pour la retrouver.
         </p>

        <pre class="programlisting">
$validator = new Zend_Validate_InArray(
    array(
        'firstDimension' =&gt; array('key' =&gt; 'value',
                                  'otherkey' =&gt; 'othervalue'),
        'secondDimension' =&gt; array('some' =&gt; 'real',
                                   'different' =&gt; 'key')
    )
);
$validator-&gt;setRecursive(true);

if ($validator-&gt;isValid('value')) {
    // valeur trouvée
} else {
    // valeur non trouvée
}
</pre>

         <div class="note"><table border="0" summary="Note: Réglage par défaut pour la récursivité">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Réglage par défaut pour la récursivité</th>
</tr>
<tr><td align="left" valign="top">
            

             <p>
                Par défaut, la récursivité n'est pas activée.
             </p>
         </td></tr>
</table></div>

        <div class="note"><table border="0" summary='Note: Options pour la "haystack"'>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Options pour la "haystack"</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Lorsque vous utilisez les clés <span class="property">haystack</span>,
                <span class="property">strict</span> ou <span class="property">recursive</span> à l'intérieur
                de votre pile, vous devez alors envelopper la clé <span class="property">haystack</span>.
            </p>
        </td></tr>
</table></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.int"></a>Int</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Int</code> valide une valeur envers un entier. Les entiers localisés sont
        aussi gérés.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.int.options"></a>Options supportées par Zend_Validate_Int</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Validate_Int</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span>: Affecte la locale à utiliser lors de la
                    validation.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.int.basic"></a>Validation simple d'entiers</h4></div></div></div>
        

        <p>
            La manière la plus simple de valider un entier est d'utiliser les paramètres systèmes. Lorsqu'aucune
            option n'est passée, la locale de l'environnement sera utilisée:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Int();

$validator-&gt;isValid(1234);   // retourne true
$validator-&gt;isValid(1234.5); // retourne false
$validator-&gt;isValid('1,234'); // retourne true
</pre>

        <p>
            Dans l'exemple ci-dessus l'environnement est supposé réglé sur la locale "en". Comme vous le voyez,
            le regroupement de chiffres est supporté (troisième exemple).
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.int.localized"></a>Validation d'entiers localisés</h4></div></div></div>
        

        <p>
            Il est parfois nécessaire de valider des entiers localisés. Les entiers sont souvent écrits de
            manière différente en fonction des pays/régions. Par exemple en anglais vous pouvez écrire "1234"
            ou "1,234", ce sont tous les deux des entiers mais le regroupement des chiffres est optionnel.
            En allemand, vous écririez "1.234" et en français "1 234".
        </p>

        <p>
            <code class="classname">Zend_Validate_Int</code> peut valider de telles notations. Il est limité à la locale
            utilisée et valide le séparateur utilisé en fonction de la locale. Voyez le code ci-après:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Int(array('locale' =&gt; 'de'));

$validator-&gt;isValid(1234); // retourne true
$validator-&gt;isValid("1,234"); // retourne false
$validator-&gt;isValid("1.234"); // retourne true
</pre>

        <p>
            Comme vous le voyez, avec une locale, l'entrée est validée en fonction de la locale. En utilisant
            l'anglais, vous récupérez <code class="constant">FALSE</code> lorsque la locale force une notation différente.
        </p>

        <p>
            La locale peut être affectée/récupérée après la création du validateur au moyen des méthodes
            <code class="methodname">setLocale()</code> et <code class="methodname">getLocale()</code>.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.ip"></a>Ip</h3></div></div></div>

    

    <p>
        <code class="classname">Zend_Validate_Ip</code> permet de déterminer si une adresse IP donnée
        est valide. Le composant supporte IPv4 et IPv6.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.ip.options"></a>Options supportées par Zend_Validate_Ip</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_Ip</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowipv4</span></em></span> : définit si la
                    validation autorise les adresses IPv4. Cette option vaut
                    <code class="constant">TRUE</code> par défaut.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowipv6</span></em></span> : définit si la
                    validation autorise les adresses IPv6. Cette option vaut
                    <code class="constant">TRUE</code> par défaut.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.ip.basic"></a>Utilisation classique</h4></div></div></div>
        

        <p>
            Voici un exemple banal:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Ip();
if ($validator-&gt;isValid($ip)) {
    // ip semble valide
} else {
    // ip n'est pas valide
}
</pre>

        <div class="note"><table border="0" summary="Note: adresses IP invalides">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">adresses IP invalides</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                <code class="classname">Zend_Validate_Ip</code> ne valide que des adresses IP.
                '<code class="filename">mydomain.com</code>' ou
                '<code class="filename">192.168.50.1/index.html</code>' ne sont donc pas des adresses IP
                valides. Ce sont des noms de domaines ou des <acronym class="acronym">URL</acronym>s mais pas des
                adresses IP.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note: Validation IPv6">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Validation IPv6</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                <code class="classname">Zend_Validate_Ip</code> valides les adresses IPv6 au moyen
                d'expressions régulières. La raison est que les fonctions fournies par PHP ne
                suivent pas la <acronym class="acronym">RFC</acronym>. Beaucoup d'autres classes disponibles
                font de même.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.ip.singletype"></a>Valider IPv4 ou IPV6 seules</h4></div></div></div>
        

        <p>
            Il peut arriver de ne vouloir valider qu'un seul des deux formats. Par exemple si le
            réseau ne supporte pas IPv6, il serait idiot de demander une telle validation.
        </p>

        <p>
            Pour limiter <code class="classname">Zend_Validate_Ip</code> sur un seul des deux protocoles,
            utilisez les options <span class="property">allowipv4</span> ou <span class="property">allowipv6</span>
            et mettez les à <code class="constant">FALSE</code>. Il est possible d'effectuer celà au moyen
            du constructeur ou avec la méthode <code class="methodname">setOptions()</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Ip(array('allowipv6' =&gt; false);
if ($validator-&gt;isValid($ip)) {
    // ip semble être une IPv4 valide
} else {
    // ip n'est pas une adresse IPv4
}
</pre>

        <div class="note"><table border="0" summary="Note: Comportement par défaut">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Comportement par défaut</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Le comportement par défaut de <code class="classname">Zend_Validate_Ip</code> est de valider
                les deux standards.
            </p>
        </td></tr>
</table></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.isbn"></a>Isbn</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_Isbn</code> permet de valider des valeurs
        <acronym class="acronym">ISBN-10</acronym> ou <acronym class="acronym">ISBN-13</acronym>.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.options"></a>Options supportées par Zend_Validate_Isbn</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_Isbn</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">separator</span></em></span> : définit le séparateur
                    autorisé pour la valeur <acronym class="acronym">ISBN</acronym>. Par défaut, il s'agit d'une
                    chaîne vide.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span> : définit le type des
                    valeurs <acronym class="acronym">ISBN</acronym> autorisées. Par défaut, il s'agit de
                    <code class="constant">Zend_Validate_Isbn::AUTO</code>. Pour plus de détails reportez
                    vous à
                    <a class="link" href="zend.validate.set.html#zend.validate.set.isbn.type-explicit" title="Configurer un type de validation ISBN explicite">cette section</a>.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.basic"></a>Utilisation classique</h4></div></div></div>
        

        <p>
            Voici un exemple banal :
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Isbn();
if ($validator-&gt;isValid($isbn)) {
    // isbn valide
} else {
    // isbn non valide
}
</pre>

        <p>
            Ceci valide tout <acronym class="acronym">ISBN-10</acronym> et <acronym class="acronym">ISBN-13</acronym> sans
            séparateur.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.type-explicit"></a>Configurer un type de validation ISBN explicite</h4></div></div></div>
        

        <p>
            Voici comment effectuer une restriction de type de l'<acronym class="acronym">ISBN</acronym> :
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Isbn();
$validator-&gt;setType(Zend_Validate_Isbn::ISBN13);
// OU
$validator = new Zend_Validate_Isbn(array(
    'type' =&gt; Zend_Validate_Isbn::ISBN13,
));

if ($validator-&gt;isValid($isbn)) {
    // ISBN-13 valide
} else {
    // ISBN-13 invalide
}
</pre>

        <p>
            Seules les valeurs de <acronym class="acronym">ISBN-13</acronym> sont validées ci-dessus.
        </p>

        <p>
            Les types valides sont :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="constant">Zend_Validate_Isbn::AUTO</code> (défaut)</p>
            </li>
<li class="listitem">
                <p><code class="constant">Zend_Validate_Isbn::ISBN10</code></p>
            </li>
<li class="listitem">
                <p><code class="constant">Zend_Validate_Isbn::ISBN13</code></p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.isbn.separator"></a>Spécifier une restriction de séparateur</h4></div></div></div>
        

        <p>
            Voici un exemple de restriction de séparateur :
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Isbn();
$validator-&gt;setSeparator('-');
// OU
$validator = new Zend_Validate_Isbn(array(
    'separator' =&gt; '-',
));

if ($validator-&gt;isValid($isbn)) {
    // ISBN valide avec séparateur
} else {
    // ISBN invalide avec séparateur
}
</pre>

        <div class="note"><table border="0" summary="Note: Valeurs sans séparateur">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Valeurs sans séparateur</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                La valeur <code class="constant">FALSE</code> est retournée si <code class="varname">$isbn</code>
                ne contient pas de séparateur <span class="emphasis"><em>ou</em></span> si le séparateur n'est
                pas valide.
            </p>
        </td></tr>
</table></div>

        <p>
            Séparateurs valides :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>"" (vide) (défaut)</p>
            </li>
<li class="listitem">
                <p>"-" (tiret)</p>
            </li>
<li class="listitem">
                <p>" " (espace)</p>
            </li>
</ul></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.lessthan"></a>LessThan</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_LessThan</code> permet de valider qu'une donnée est bien inférieure à une
        borne. C'est l'opposé de <code class="classname">Zend_Validate_GreaterThan</code>.
    </p>

    <div class="note"><table border="0" summary="Note: Zend_Validate_LessThan ne supporte que les chiffres">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Zend_Validate_LessThan ne supporte que les chiffres</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            <code class="classname">Zend_Validate_LessThan</code> ne fonctionnera pas avec les chaines et les dates.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.lessthan.options"></a>Options gérées par Zend_Validate_LessThan</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Validate_LessThan</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">max</span></em></span>: Affecte la borne supérieure.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.lessthan.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voyez l'exemple ci-après.
        </p>

        <pre class="programlisting">
$valid  = new Zend_Validate_LessThan(array('max' =&gt; 10));
$value  = 10;
$return = $valid-&gt;isValid($value);
// retourne true
</pre>

        <p>
            L'exemple ci-dessus retourne <code class="constant">TRUE</code> pour toutes les valeurs égales
            ou inférieures à 10.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.notempty"></a>NotEmpty</h3></div></div></div>
    

    <p>
        Ce validateur permet de déterminer si une valeur est non vide. C'est utile lorsque vous travaillez
        avec des formulaires ou des entrées utilisateur, là où vous pouvez l'utiliser pour savoir si des
        éléments requis ont été saisis.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.notempty.options"></a>Options supportées par Zend_Validate_NotEmpty</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_NotEmpty</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span> : paramètre le type de
                    validation qui sera réalisée. Pour plus de détails, reportez vous à
                    <a class="link" href="zend.validate.set.html#zend.validate.set.notempty.types" title="Changer le comportement de Zend_Validate_NotEmpty">cette section</a>.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.notempty.default"></a>Comportement par défaut de Zend_Validate_NotEmpty</h4></div></div></div>
        

        <p>
            Par défaut, ce validateur fonctionne différement de la fonction
            <acronym class="acronym">PHP</acronym> <code class="methodname">empty()</code>. En particulier, ce validateur va
            évaluer l'entier <span class="emphasis"><em>0</em></span> et la chaine '<span class="emphasis"><em>0</em></span>' comme vides.
        </p>

        <pre class="programlisting">
$valid = new Zend_Validate_NotEmpty();
$value  = '';
$result = $valid-&gt;isValid($value);
// retourne false
</pre>

        <div class="note"><table border="0" summary="Note: Le comportement par défaut diffère de PHP">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Le comportement par défaut diffère de PHP</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Sans configuration ajoutée, <code class="classname">Zend_Validate_NotEmpty</code> diffère
                de <acronym class="acronym">PHP</acronym>.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.notempty.types"></a>Changer le comportement de Zend_Validate_NotEmpty</h4></div></div></div>
        

        <p>
            Certains projets ont des opinions différentes sur ce qui peut être considéré comme 'vide'.
            Une chaine seulement composée d'espaces blancs pourrait être considérée comme vide, ou
            <span class="emphasis"><em>0</em></span> pourrait être considéré comme non-vide (surtout dans les séquences
            logiques booléennes). Pour correspondre aux différents besoins,
            <code class="classname">Zend_Validate_NotEmpty</code> vous permet de configurer les types que vous
            considérez comme vides.
        </p>

        <p>
            Les types suivants sont gérés :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>boolean</em></span> : retourne <code class="constant">FALSE</code> lorsque
                    la valeur booléenne est <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>integer</em></span> : retourne <code class="constant">FALSE</code> lorsque l'entier
                    <span class="emphasis"><em>0</em></span> est passé. Par défaut cette validation n'est pas activée et
                    retourne <code class="constant">TRUE</code> pour toute valeur d'entier.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>float</em></span> : retourne <code class="constant">FALSE</code> lorsque le flottant
                    <span class="emphasis"><em>0.0</em></span> est passé. Par défaut cette validation n'est pas activée et
                    retourne <code class="constant">TRUE</code> pour toute valeur de flottant.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>string</em></span> : retourne <code class="constant">FALSE</code> lorsque la chaine vide
                    <span class="emphasis"><em>''</em></span> est passée.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>zero</em></span> : retourne <code class="constant">FALSE</code> lorsque le seul caractère
                    zéro (<span class="emphasis"><em>'0'</em></span>) est passé.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>empty_array</em></span> : retourne <code class="constant">FALSE</code> lorsqu'un tableau vide
                    <span class="emphasis"><em>array()</em></span> est passé.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>null</em></span> : retourne <code class="constant">FALSE</code> lorsqu'une valeur
                    <code class="constant">NULL</code> est passée.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>php</em></span> : retourne <code class="constant">FALSE</code> lorsque la fonction
                    <acronym class="acronym">PHP</acronym> <code class="methodname">empty()</code> retournerait
                    <code class="constant">TRUE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>space</em></span> : retourne <code class="constant">FALSE</code> lorsqu'une chaine
                    ne contenant que des caractères espace est passée.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>object</em></span> : retourne <code class="constant">TRUE</code>.
                    <code class="constant">FALSE</code> sera retournée quand <span class="property">object</span>
                    n'est pas autorisé mais qu'ue objet est fourni.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>object_string</em></span> : retourne <code class="constant">FALSE</code>
                    quand un objet est fourni et que sa méthode
                    <code class="methodname">__toString()</code> retourne une chaîne vide.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>object_count</em></span> : retourne <code class="constant">FALSE</code>
                    quand un objet est fourni, qu'il implémente <code class="classname">Countable</code>
                    et que son compte vaut 0.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>all</em></span> : retourne <code class="constant">FALSE</code> pour tous les
                    types gérés cités ci-dessus.
                </p>
            </li>
</ul></div>

        <p>
            Toute autre valeur passée retourne <code class="constant">TRUE</code> par défaut.
        </p>

        <p>
            Il existe différentes manières de selectionner les types ci-dessus. Vous pouvez en spécifier
            un ou plusieurs, sous forme de tableau ou de constantes ou encore de chaines.
            Voyez les exemples ci-après :
        </p>

        <pre class="programlisting">
// Retourne false pour 0
$validator = new Zend_Validate_NotEmpty(Zend_Validate_NotEmpty::INTEGER);

// Retourne false pour 0 ou '0'
$validator = new Zend_Validate_NotEmpty(
    Zend_Validate_NotEmpty::INTEGER + Zend_NotEmpty::ZERO
);

// Retourne false pour 0 ou '0'
$validator = new Zend_Validate_NotEmpty(array(
    Zend_Validate_NotEmpty::INTEGER,
    Zend_Validate_NotEmpty::ZERO
));

// Retourne false pour 0 ou '0'
$validator = new Zend_Validate_NotEmpty(array(
    'integer',
    'zero',
));
</pre>

        <p>
            Il est aussi possible de passer un objet <code class="classname">Zend_Config</code> afin de
            préciser les types à utiliser. Après instantiation, <code class="methodname">setType()</code>
            peut être utilisée.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.post_code"></a>PostCode</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Validate_PostCode</code> vous permet de déterminer si une valeur
        donnée est un code postal valide. Les codes postaux siont spécifiques aux villes et dans
        quelques cas spéciaux sont nommés des codes <acronym class="acronym">ZIP</acronym>.
    </p>

    <p>
        <code class="classname">Zend_Validate_PostCode</code> reconnait plus de 160 différents formats de
        codes postaux. Pour sélectionner le format correct, il existe deux manières. Vous pouvez
        soit utiliser une locale complète, soit paramétrer votre propre format manuellement.
    </p>

    <p>
        Utiliser la locale est la méthode la plus commode puisque Zend Framework connait les
        formats des codes postaux assoicés à chaque locale  cependant, vous devez utiliser
        une locale complète (c'est-à-dire contenant aussi le spécificateur de région) dans ce cas.
        Par exemple, la locale "fr" est une bien une locale mais ne peut pas être utilisée avec
        <code class="classname">Zend_Validate_PostCode</code> puisqu'elle ne contient pas la
        région ; "fr_FR" sera, cependant, une locale valide puisqu'elle spécifie une région
        ("FR", pour France).
    </p>
    <pre class="programlisting">
$validator = new Zend_Validate_PostCode('fr_FR');
</pre>

    <p>
        Quand vous ne paramétrez pas de locale vous-même, alors
        <code class="classname">Zend_Validate_PostCode</code> utilisera la locale de l'application, ou, s'il
        n'y en a pas, la locale retournée par <code class="classname">Zend_Locale</code>.
    </p>

    <pre class="programlisting">
// locale de l'application définie dans le bootstrap
$locale = new Zend_Locale('fr_FR');
Zend_Registry::set('Zend_Locale', $locale);
$validator = new Zend_Validate_PostCode();
</pre>

    <p>
        Vous pouvez changer la locale plus tard en appelant <code class="methodname">setLocale()</code>.
        Et bien sûr vous pouvez récupérer la locale courante avec
        <code class="methodname">getLocale()</code>.
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_PostCode('fr_FR');
$validator-&gt;setLocale('en_GB');
</pre>

    <p>
        Les formats de codes postaux sont simplement des chaînes d'expressions régulières. Quand le
        format de code postal international, qui est utilisé en paramétrant la locale, ne correspond
        pas à vos besoins, alors vous pouvez alors paramétrer manuellement un format en appelant
        <code class="methodname">setFormat()</code>.
    </p>

    <pre class="programlisting">
$validator = new Zend_Validate_PostCode('fr_FR');
$validator-&gt;setFormat('FR-\d{5}');
</pre>

    <div class="note"><table border="0" summary="Note: Conventions pour les formats personnalisés">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Conventions pour les formats personnalisés</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            Lors de l'utilisation de formats personnalisés, vous devez omettre les balises de début
            (<span class="command"><strong>'/^'</strong></span>) et de fin (<span class="command"><strong>'$/'</strong></span>). Elles sont ajoutés
            automatiquement.
        </p>

        <p>
            Vous devez faire attention au fait que les valeurs de code postal sont toujours
            validées de manière stricte. Ce qui veut dire qu'ils doivent être écrits seuls sans
            caractère additionnel qui ne serait pas couvert par le format.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.post_code.constructor"></a>Options du constructeur</h4></div></div></div>
        

        <p>
            Le plus basiquement possible, vous fournissez soit un objet
            <code class="classname">Zend_Locale</code>, soit une chaîne représentant une locale complète
            au constructeur de <code class="classname">Zend_Validate_PostCode</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_PostCode('fr_FR');
$validator = new Zend_Validate_PostCode($locale);
</pre>

        <p>
            De plus, vous pouve zfournir un tableau ou un objet <code class="classname">Zend_Config</code>
            au constructeur. Quand vous faîtes ceci, vous devez inclure soit la clé "locale" ou
            "format" ;celles-ci seront utilisées pour paramétrer les valeurs appropriées dans
            l'objet validateur.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_PostCode(array(
    'locale' =&gt; 'fr_FR',
    'format' =&gt; 'FR-\d+'
));
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.post_code.options"></a>Options supportées par Zend_Validate_PostCode</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_PostCode</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">format</span></em></span> : spécifie le format
                    de code postal qui sera utilisé pour la validation.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span> : spécifie la locale
                    à partir de laquelle le code postal sera récupéré.
                </p>
            </li>
</ul></div>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.regex"></a>Regex</h3></div></div></div>
    

    <p>
        Ce validateur valide si une chaine correspond à un motif d'expression régulière.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.regex.options"></a>Options supportées par Zend_Validate_Regex</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Validate_Regex</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">pattern</span></em></span> : le motif d'expression
                    régulière.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.regex.basic"></a>Validation avec Zend_Validate_Regex</h4></div></div></div>
        

        <p>
            La validation au travers d'expressions régulières est pratique, très utilisée et simple
            dans la mesure où elle vous évite la plupart du temps d'écrire votre propre validateur.
            Voyons quelques exemples :
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Regex(array('pattern' =&gt; '/^Test/');

$validator-&gt;isValid("Test"); // retourne true
$validator-&gt;isValid("Testing"); // retourne true
$validator-&gt;isValid("Pest"); // retourne false
</pre>

        <p>
            Comme vous le voyez, le motif doit être passé avec la même forme que pour
            <code class="methodname">preg_match()</code>. Pour plus de détails sur les expressions
            régulières, voyez <a class="ulink" href="http://php.net/manual/en/reference.pcre.pattern.syntax.php" target="_top">le manuel de PHP
                sur la syntaxe des motifs d'expressions PCRE</a>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.regex.handling"></a>Gestion des motifs</h4></div></div></div>
        

        <p>
            Vous pouvez affecter / récupérer le motif après avoir crée le validateur en
            utilisant les méthodes <code class="methodname">setPattern()</code> et
            <code class="methodname">getPattern()</code>.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_Regex(array('pattern' =&gt; '/^Test/');
$validator-&gt;setPattern('ing$/');

$validator-&gt;isValid("Test"); // retourne false
$validator-&gt;isValid("Testing"); // retourne true
$validator-&gt;isValid("Pest"); // retourne false
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.sitemap"></a>Validateurs de Sitemap</h3></div></div></div>
    

    <p>
        Les validateurs suivant sont conformes au protocole <a class="ulink" href="http://www.sitemaps.org/protocol.php" target="_top"><acronym class="acronym">XML</acronym> Sitemap</a>.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.changefreq"></a>Sitemap_Changefreq</h4></div></div></div>
        

        <p>
            Valide si oui ou non une chaîne utilisable en tant qu'élément "changefreq" dans un
            document <acronym class="acronym">XML</acronym> Sitemap. Les valeurs valides sont : "always",
            "hourly", "daily", "weekly", "monthly", "yearly", or "never".
        </p>

        <p>
            Retourne <code class="constant">TRUE</code> si et seulement si la valeur est une chaîne
            et qu'elle vaut une dès fréquences ci-dessus.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.lastmod"></a>Sitemap_Lastmod</h4></div></div></div>
        

        <p>
            Valide si oui ou non une chaîne utilisable en tant qu'élément "lastmod" dans un
            document <acronym class="acronym">XML</acronym> Sitemap. L'élément "lasmod" doit contenir une date
            sous la forme <acronym class="acronym">W3C</acronym>, optionnellement en omettant les informations
            concernant l'heure.
        </p>

        <p>
            Retourne <code class="constant">TRUE</code> si et seulement si la valeur est une chaîne
            et qu'elle est valide suivant le protocole.
        </p>

        <div class="example">
<a name="zend.validate.sitemap.lastmod.example"></a><p class="title"><b>Exemple 947. Validateur de "lastmod" Sitemap</b></p>
<div class="example-contents">
            
            <pre class="programlisting">
$validator = new Zend_Validate_Sitemap_Lastmod();
$validator-&gt;isValid('1999-11-11T22:23:52-02:00'); // true
$validator-&gt;isValid('2008-05-12T00:42:52+02:00'); // true
$validator-&gt;isValid('1999-11-11'); // true
$validator-&gt;isValid('2008-05-12'); // true
$validator-&gt;isValid('1999-11-11t22:23:52-02:00'); // false
$validator-&gt;isValid('2008-05-12T00:42:60+02:00'); // false
$validator-&gt;isValid('1999-13-11'); // false
$validator-&gt;isValid('2008-05-32'); // false
$validator-&gt;isValid('yesterday'); // false
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.loc"></a>Sitemap_Loc</h4></div></div></div>
        

        <p>
            Valide si oui ou non une chaîne utilisable en tant qu'élément "loc" dans un
            document <acronym class="acronym">XML</acronym> Sitemap. Ceci utilise en interne la méthode
            <code class="methodname">Zend_Form::check()</code>. Vous pouvez en lire davantage avec la
            <a class="link" href="zend.uri.chapter.html#zend.uri.validation" title="Validation d'URI">validation d'URI</a>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.sitemap.priority"></a>Sitemap_Priority</h4></div></div></div>
        

        <p>
            Valide si oui ou non une valeur est utilisable en tant qu'élément "priority" dans un
            document <acronym class="acronym">XML</acronym> Sitemap. La valeur doit être un nombre compris entre
            0.0 et 1.0. Ce validateur accepte à la fois des valeurs numériques ou textuelles.
        </p>

        <div class="example">
<a name="zend.validate.sitemap.priority.example"></a><p class="title"><b>Exemple 948. Validateur de "priority" Sitemap</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$validator = new Zend_Validate_Sitemap_Priority();
$validator-&gt;isValid('0.1'); // true
$validator-&gt;isValid('0.789'); // true
$validator-&gt;isValid(0.8); // true
$validator-&gt;isValid(1.0); // true
$validator-&gt;isValid('1.1'); // false
$validator-&gt;isValid('-0.4'); // false
$validator-&gt;isValid(1.00001); // false
$validator-&gt;isValid(0xFF); // false
$validator-&gt;isValid('foo'); // false
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.sitemap.options"></a>Options supportées par Zend_Validate_Sitemap_*</h4></div></div></div>
        

        <p>
            Il n'y a pas d'options supportées par ce validateur.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.validate.set.stringlength"></a>StringLength</h3></div></div></div>
    

    <p>
        Ce validateur vérifie la longueur d'une chaine de caractères.
    </p>

    <div class="note"><table border="0" summary="Note: Zend_Validate_StringLength ne supporte que les chaines">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Zend_Validate_StringLength ne supporte que les chaines</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            Zend_Validate_StringLength ne fonctionnera pas avec les entiers, flottants, les dates ou
            encore les objets.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.options"></a>Options gérées par Zend_Validate_StringLength</h4></div></div></div>
        

        <p>
            Les options suivantes sont reconnues par
            <code class="classname">Zend_Validate_StringLength</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">encoding</span></em></span>: Définit l'encodage
                    <code class="constant">ICONV</code> à utiliser avec la chaine.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">min</span></em></span>: Définit le nombre de caractères
                    minimum requis.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">max</span></em></span>: Définit le nombre de caractères
                    maximum requis.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.basic"></a>Comportement par défaut de Zend_Validate_StringLength</h4></div></div></div>
        

        <p>
            Par défaut, ce validateur vérifie qu'une valeur de chaine est bien entre <span class="property">min</span> et
            <span class="property">max</span> caractères. Pour <span class="property">min</span>, la valeur par défaut est
            <span class="emphasis"><em>0</em></span> et pour <span class="property">max</span> c'est
            <span class="emphasis"><em><code class="constant">NULL</code></em></span> ce qui signifie illimité.
        </p>

        <p>
            Ainsi par défaut, sans aucune option, ce validateur vérifie que la donnée traitée est bien une chaine.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.maximum"></a>Limiter sur la borne supérieure</h4></div></div></div>
        

        <p>
            La borne supérieure se règle au moyen de l'option <span class="property">max</span>.
            Ce doit être un entier.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength(array('max' =&gt; 6));

$validator-&gt;isValid("Test"); // retourne true
$validator-&gt;isValid("Testing"); // retourne false
</pre>

        <p>
            Il est possible de préciser cette option plus tard, au moyen de la méthode
            <code class="methodname">setMax()</code>. <code class="methodname">getMax()</code> existe aussi.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength();
$validator-&gt;setMax(6);

$validator-&gt;isValid("Test"); // retourne true
$validator-&gt;isValid("Testing"); // retourne false
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.minimum"></a>Limiter sur la borne inférieure</h4></div></div></div>
        

        <p>
            La borne inférieure se règle au moyen de l'option <span class="property">min</span>.
            Ce doit être un entier.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength(array('min' =&gt; 5));

$validator-&gt;isValid("Test"); // retourne false
$validator-&gt;isValid("Testing"); // retourne true
</pre>

        <p>
            Il est possible de préciser cette option plus tard, au moyen de la méthode
            <code class="methodname">setMin()</code>. <code class="methodname">getMin()</code> existe aussi.
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength();
$validator-&gt;setMin(5);

$validator-&gt;isValid("Test"); // retourne false
$validator-&gt;isValid("Testing"); // retourne true
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.both"></a>Limiter via les deux bornes</h4></div></div></div>
        

        <p>
            Quelques fois, il est nécessaire de s'assurer que la chaine comprenne bien un nombre
            de caractères entre deux bornes min et max. Par exemple depuis un champ de formulaire
            représentant un nom, vous voudriez que l'utilisateur ne puisse saisir plus de 30
            caractères mais au moins 3. Voyez l'exemple qui suit:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength(array('min' =&gt; 3, 'max' =&gt; 30));

$validator-&gt;isValid("."); // retourne false
$validator-&gt;isValid("Test"); // retourne true
$validator-&gt;isValid("Testing"); // retourne true
</pre>

        <div class="note"><table border="0" summary="Note: Comportement illogique, borne inférieure supérieure à la borne supérieure">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Comportement illogique, borne inférieure supérieure à la borne supérieure</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Si vous tentez de préciser un min supérieur au max, ou inversement, une exception
                sera levée.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.validate.set.stringlength.encoding"></a>Encodage des valeurs</h4></div></div></div>
        

        <p>
            Les chaines se représentent toujours en considérant un encodage. Même si vous ne le précisez
            pas explicitement, <acronym class="acronym">PHP</acronym> en utilise un. Si votre application utilise un
            encodage différent de celui de <acronym class="acronym">PHP</acronym>, vous devrez alors le préciser.
        </p>

        <p>
            Vous pouvez passer votre propre encodage à l'initialisation grâce à l'option
            <span class="property">encoding</span>, ou en utilisant la méthode <code class="methodname">setEncoding()</code>
            . Nous supposons que votre installation utilise <acronym class="acronym">ISO</acronym> ainsi que votre
            application. Dans ce cas, vous verrez le comportement suivant:
        </p>

        <pre class="programlisting">
$validator = new Zend_Validate_StringLength(
    array('min' =&gt; 6)
);
$validator-&gt;isValid("Ärger"); // retourne false

$validator-&gt;setEncoding("UTF-8");
$validator-&gt;isValid("Ärger"); // retourne true

$validator2 = new Zend_Validate_StringLength(
    array('min' =&gt; 6, 'encoding' =&gt; 'UTF-8')
);
$validator2-&gt;isValid("Ärger"); // retourne true
</pre>

        <p>
            Si votre installation et votre application utilisent des encodages différents, vous deviez
            toujours préciser l'encodage vous-même.
        </p>
    </div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.validate.introduction.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.validate.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.validate.validator_chains.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Introduction </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Chaînes de validation</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
