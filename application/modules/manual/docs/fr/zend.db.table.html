<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Zend_Db_Table</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.db.html" title="Zend_Db">
<link rel="prev" href="zend.db.select.html" title="Zend_Db_Select">
<link rel="next" href="zend.db.table.row.html" title="Zend_Db_Table_Row">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Zend_Db_Table</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.db.select.html">Précédent</a> </td>
<th width="60%" align="center">Zend_Db</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.db.table.row.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.table"></a>Zend_Db_Table</h2></div></div></div>
    

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.introduction"></a>Introduction</h3></div></div></div>
        

        <p>
            La classe <code class="classname">Zend_Db_Table</code> est une interface orientée objet
            vers les tables d'une base de données. Elle fournit des méthodes pour la gestion de la
            plupart des opérations concernant une table. Bien entendu, vous pouvez étendre la classe
            de base pour ajouter une logique personnalisée.
        </p>

        <p>
            La solution que représente <code class="classname">Zend_Db_Table</code> est basée sur le
            motif de conception <a class="ulink" href="http://www.martinfowler.com/eaaCatalog/tableDataGateway.html" target="_top">Table Data
            Gateway</a>. Cette solution inclut aussi une classe implémentant le motif <a class="ulink" href="http://www.martinfowler.com/eaaCatalog/rowDataGateway.html" target="_top">Row Data
            Gateway</a>.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.defining"></a>Définir une classe de Table</h3></div></div></div>
        

        <p>
            Pour chaque table de la base de données envers laquelle vous souhaitez un accès,
            définissez une classe étendant <code class="classname">Zend_Db_Table_Abstract</code>.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.defining.table-schema"></a>Définir le nom de la table, et de la base de données</h4></div></div></div>
            

            <p>
                Déclarez le nom de la table pour laquelle la classe va agir, en utilisant la
                propriété protégée <code class="varname">$_name</code>. C'est une chaîne, elle doit contenir le nom
                de la table tel qu'il apparaît dans la base de données.
            </p>

            <div class="example">
<a name="zend.db.table.defining.table-schema.example1"></a><p class="title"><b>Exemple 263. Déclarer une classe de Table avec un nom de table spécifique</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';
}
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Si vous ne spécifiez pas le nom de la table, le nom de la classe sera alors
                utilisé comme nom de table par défaut.
            </p>

            <div class="example">
<a name="zend.db.table.defining.table-schema.example"></a><p class="title"><b>Exemple 264. Déclarer une classe de Table sans nom de table spécifique</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class bugs extends Zend_Db_Table_Abstract
{
    // le nom de la table est ici supposé être le nom de la classe
}
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Vous pouvez aussi déclarer le nom de la base de données contenant la table,
                toujours au moyen d'une propriété protégée de la classe :
                <code class="varname">$_schema</code>, ou avec le nom de la base précédant le nom de la table dans
                la propriété <code class="varname">$_name</code>. Si vous choisissez de définir le nom de la base de
                données dans la propriété <code class="varname">$_name</code>, alors ce choix sera prioritaire sur
                celui utilisant <code class="varname">$_schema</code>.
            </p>

            <div class="example">
<a name="zend.db.table.defining.table-schema.example3"></a><p class="title"><b>Exemple 265. Déclarer une classe de Table avec un nom de base de données</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// Première alternative :
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_schema = 'bug_db';
    protected $_name   = 'bugs';
}

// Seconde alternative :
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bug_db.bugs';
}

// Si le nom de la base est spécifiée dans $_name ET $_schema,
// alors c'est celui spécifié dans $_name qui prime :

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name   = 'bug_db.bugs';
    protected $_schema = 'ignored';
}
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Les noms de la base de données et de la table peuvent aussi être définis via
                le constructeur de la classe de Table. Ils écrasent alors ceux éventuellement
                définis dans les propriétés de la classe (avec <code class="varname">$_name</code> et
                <code class="varname">$_schema</code>).
            </p>

            <div class="example">
<a name="zend.db.table.defining.table-schema.example.constructor"></a><p class="title"><b>Exemple 266. Déclarer les noms de table et base de donnée à l'instanciation</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class Bugs extends Zend_Db_Table_Abstract
{
}

// Première alternative :

$tableBugs = new Bugs(array('name' =&gt; 'bugs', 'schema' =&gt; 'bug_db'));

// Seconde alternative :

$tableBugs = new Bugs(array('name' =&gt; 'bug_db.bugs'));

// Si le nom de la base est spécifié dans name ET schema, alors c'est
// celui spécifié dans name qui prime :

$tableBugs = new Bugs(array('name' =&gt; 'bug_db.bugs',
                            'schema' =&gt; 'ignored'));
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Si vous n'indiquez pas de base de données, c'est celle utilisée par
                l'adaptateur qui sera utilisée.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.defining.primary-key"></a>Définir la clé primaire d'une table</h4></div></div></div>
            

            <p>
                Toute table doit posséder une clé primaire.
                <code class="classname">Zend_Db_Table</code> ne fonctionne pas avec les tables sans clé
                primaire. Vous pouvez les déclarer la(les) colonne servant de clé primaire grâce à
                la propriété protégée de la classe <code class="varname">$_primary</code>. Celle-ci peut être soit
                une chaîne, dans le cas d'une clé sur une colonne, ou un tableau de chaînes pour une
                clé sur plusieurs colonnes (clé primaire composée).
            </p>

            <div class="example">
<a name="zend.db.table.defining.primary-key.example"></a><p class="title"><b>Exemple 267. Exemple de spécification de la clé primaire</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';
    protected $_primary = 'bug_id';
}
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Si vous ne spécifiez pas explicitement de clé primaire, alors
                <code class="classname">Zend_Db_Table_Abstract</code> va essayer de la trouver lui-même en
                utilisant les informations renvoyées par <code class="methodname">describeTable()</code>.
            </p>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    Toute classe de table doit, par un moyen ou un autre, connaître la clé
                    primaire de la table ciblée. Si la clé primaire ne peut être trouvée ( spécifiée
                    dans la classe, ou découverte par <code class="methodname">describeTable()</code>), alors la table
                    ne va pas pouvoir être utilisée avec
                    <code class="classname">Zend_Db_Table</code>.
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.defining.setup"></a>Redéfinir les méthodes de configuration de la classe de Table</h4></div></div></div>
            

            <p>
                Lorsque vous créez votre instance de classe
                <code class="classname">Zend_Db_Table</code>, le constructeur décompose le processus via
                plusieurs méthodes permettant l'initialisation des métadonnées de la table. Chacune
                de ces étapes est matérialisée par une méthode de la classe, surchargeable.
                N'oubliez cependant pas d'appeler la méthode parente respective à la fin de votre
                traitement.
            </p>

            <div class="example">
<a name="zend.db.table.defining.setup.example"></a><p class="title"><b>Exemple 268. Exemple de redéfinition de la méthode _setupTableName()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class Bugs extends Zend_Db_Table_Abstract
{
    protected function _setupTableName()
    {
        $this-&gt;_name = 'bugs';
        parent::_setupTableName();
    }
}
</pre>
            </div>
</div>
<br class="example-break">

            <p>Les méthodes de configuration que vous pouvez redéfinir sont :</p>

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        <code class="methodname">_setupDatabaseAdapter()</code> vérifie si un adaptateur a été
                        passé à la classe, éventuellement en récupère un depuis le registre. En
                        redéfinissant cette méthode, vous pouvez ajouter une source de recherche
                        pour l'adaptateur.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <code class="methodname">_setupTableName()</code> donne le nom de la table par défaut
                        comme étant le nom de la classe. En redéfinissant cette méthode, vous pouvez
                        spécifier le nom de la table avant son intervention.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <code class="methodname">_setupMetadata()</code> définit le nom de la base de données si
                        le nom de la table est de la forme "base.table"; appelle
                        <code class="methodname">describeTable()</code> pour récupérer les méta-données; remplir le
                        tableau <code class="varname">$_cols</code> avec les noms des colonnes reçus via
                        <code class="methodname">describeTable()</code>. La redéfinition de cette méthode permet de
                        spécifier soi-même les noms des colonnes de la table.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <code class="methodname">_setupPrimaryKey()</code> donne le nom de la clé primaire par
                        défaut en cherchant dans <code class="methodname">describeTable()</code>; vérifie que la clé
                        primaire fait bien partie du tableau <code class="varname">$_cols</code>. En redéfinissant
                        cette méthode, vous pouvez spécifier une clé primaire manuellement.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.initialization"></a>Initialisation de la Table</h4></div></div></div>
            

            <p>
                Si lors de la construction de l'objet représentant votre Table, vous avez
                besoin d'implémenter une logique spécifique, vous devriez utiliser la méthode
                <code class="methodname">init()</code>, qui est appelée juste après le constructeur, donc une fois la
                table correctement créée.
                </p>

            <div class="example">
<a name="zend.db.table.defining.init.usage.example"></a><p class="title"><b>Exemple 269. Exemple d'utilisation de la méthode init()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_observer;

    public function init()
    {
        $this-&gt;_observer = new MyObserverClass();
    }
}
</pre>
            </div>
</div>
<br class="example-break">
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.constructing"></a>Créer une instance de la classe de Table</h3></div></div></div>
        

        <p>
            Avant d'utiliser votre classe de Table, il faut en créer une instance, via son
            constructeur. Celui-ci accepte un tableau d'options. La plus importante d'entre elles
            est l'adaptateur de base de données, qui représente la connexion au SGBD. Il y a trois
            façon de le spécifier :
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.constructing.adapter"></a>Spécifier l'adaptateur de base de données</h4></div></div></div>
            

            <p>
                La première manière de spécifier l'objet d'adaptateur à la classe de Table,
                est de le passer dans le tableau d'options, à l'index <code class="code">"db"</code>.
            </p>

            <div class="example">
<a name="zend.db.table.constructing.adapter.example"></a><p class="title"><b>Exemple 270. Exemple de construction d'un objet Table avec l'objet adaptateur</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db = Zend_Db::factory('PDO_MYSQL', $options);

$table = new Bugs(array('db' =&gt; $db));
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.constructing.default-adapter"></a>Spécifier un adaptateur par défaut</h4></div></div></div>
            

            <p>
                La deuxième manière de donner un objet adaptateur à la classe de Table est de
                le déclarer comme étant l'objet adaptateur par défaut pour toutes les classes de
                Table. Vous pouvez faire ceci en utilisant la méthode statique
                <code class="methodname">Zend_Db_Table_Abstract::setDefaultAdapter()</code>. Son argument est
                un objet de type <code class="classname">Zend_Db_Adapter_Abstract</code>.
            </p>

            <div class="example">
<a name="zend.db.table.constructing.default-adapter.example"></a><p class="title"><b>Exemple 271. 
                    Exemple de construction d'un objet Table en utilisant l'adaptateur par défaut
                </b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db = Zend_Db::factory('PDO_MYSQL', $options);
Zend_Db_Table_Abstract::setDefaultAdapter($db);

// Plus tard...

$table = new Bugs();
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Il peut être intéressant de créer son objet adaptateur de base de données en
                un lieu approprié, comme le fichier d'amorçage ("bootstrap"), et ensuite de le
                spécifier comme adaptateur par défaut pour toutes les tables, à travers toute
                l'application. Attention toutefois, ce procédé fixe un et un seul adaptateur, pour
                toutes les classes de table (héritant de
                <code class="classname">Zend_Db_Table_Abstract</code>).
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.constructing.registry"></a>Stocker l'objet adaptateur dans le registre</h4></div></div></div>
            

            <p>
                La troisième manière de passer l'objet adaptateur de base de données à votre
                classe de Table, est de passer une chaîne de caractères dans la clé
                <code class="code">"db"</code> du tableau de configuration accepté par le constructeur. Cette
                chaîne représente alors l'index auquel est stocké l'adaptateur, dans le registre
                statique.
            </p>

            <div class="example">
<a name="zend.db.table.constructing.registry.example"></a><p class="title"><b>Exemple 272. Exemple de construction de l'objet Table avec le registre</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db = Zend_Db::factory('PDO_MYSQL', $options);
Zend_Registry::set('my_db', $db);

// Plus tard...

$table = new Bugs(array('db' =&gt; 'my_db'));
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Cette option est très semblable à celle qui consiste à définir un adaptateur
                par défaut à toutes les classes. Le registre est en revanche plus flexible, car vous
                pouvez y stocker plusieurs adaptateurs, correspondants à plusieurs SGBD différents.
                Changer de SGBD pour ses classes de Table est alors aussi simple que de changer de
                valeur de registre.
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.insert"></a>Insérer des enregistrement dans une table</h3></div></div></div>
        

        <p>
            Vous pouvez utiliser votre objet de Table pour insérer des données dans la table
            sur laquelle l'objet se base. Utilisez sa méthode <code class="methodname">insert()</code> qui accepte un
            seul paramètre : c'est un tableau dont les clés sont les noms des colonnes de la
            table, et les valeurs les valeurs souhaitées pour insertions.
        </p>

        <div class="example">
<a name="zend.db.table.insert.example"></a><p class="title"><b>Exemple 273. Exemple d'insertion de données dans la table</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$table = new Bugs();

$data = array(
    'created_on'      =&gt; '2007-03-22',
    'bug_description' =&gt; 'Something wrong',
    'bug_status'      =&gt; 'NEW'
);

$table-&gt;insert($data);
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Par défaut les paramètres sont traités comme des valeurs littérales. Si vous
            souhaitez utiliser une expression <acronym class="acronym">SQL</acronym> à la place, manipulez un objet
            <code class="classname">Zend_Db_Expr</code> plutôt.
        </p>

        <div class="example">
<a name="zend.db.table.insert.example-expr"></a><p class="title"><b>Exemple 274. Exemple d'insertion d'expressions dans une table</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$table = new Bugs();

$data = array(
    'created_on'      =&gt; new Zend_Db_Expr('CURDATE()'),
    'bug_description' =&gt; 'Something wrong',
    'bug_status'      =&gt; 'NEW'
);
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Dans les exemples ci-dessus, il est supposé que la table possède une clé primaire
            auto-incrémentée. C'est le comportement par défaut que gère
            <code class="classname">Zend_Db_Table_Abstract</code>, mais il y a d'autres comportements
            valides, qui sont détaillés ci-dessous.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.insert.key-auto"></a>Utiliser une table avec une clé primaire auto-incrémentée</h4></div></div></div>
            

            <p>
                Une clé primaire auto-incrémentée génère une valeur entière unique si vous
                omettez la colonne de la clé primaire dans une requête <acronym class="acronym">SQL</acronym> de type
                <code class="constant">INSERT</code>.
            </p>

            <p>
                Dans <code class="classname">Zend_Db_Table_Abstract</code>, si vous définissez la
                variable protégée <code class="varname">$_sequence</code> à un booléen <code class="constant">TRUE</code> (défaut),
                alors la classe va supposer que la table qu'elle représente possède une clé primaire
                auto-incrémentée.
            </p>

            <div class="example">
<a name="zend.db.table.insert.key-auto.example"></a><p class="title"><b>Exemple 275. Exemple de déclaration d'une clé primaire auto-incrémentée</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    // Ce comportement est celui par défaut, il est noté ici
    // uniquement pour l'exemple, mais non necéssaire
    protected $_sequence = true;
}
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                MySQL, MSSQL, et SQLite sont des exemples de SGBD supportant les clé primaires
                auto-incrémentées.
            </p>

            <p>
                PostgreSQL a une propriété <code class="constant">SERIAL</code> qui définit une séquence
                automatiquement, basée sur le nom de la table et d'une colonne, et utilise cette
                séquence pour générer des valeurs de clés pour les nouveaux enregistrements. IBM DB2
                a une propriété <code class="constant">IDENTITY</code> qui fonctionne de la même manière. Si vous
                utilisez ces propriétés d'automatisme, considérez votre classe de Table
                (<code class="classname">Zend_Db_Table</code>) comme si elle avait une clé primaire
                auto-incrémentée. Déclarez ainsi <code class="varname">$_sequence</code> à <code class="constant">TRUE</code>.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.insert.key-sequence"></a>Utiliser une Table avec une séquence</h4></div></div></div>
            

            <p>
                Une séquence est un objet de base de données qui génère des valeurs uniques
                pouvant être utilisées comme clés primaires dans une ou plusieurs tables de la base
                de données.
            </p>

            <p>
                Si vous définissez <code class="varname">$_sequence</code> avec une chaîne de caractères,
                <code class="classname">Zend_Db_Table_Abstract</code> va alors supposer que cette chaîne
                représente le nom de l'objet de séquence. Elle sera donc utilisée pour générer une
                valeur lors de requêtes <code class="constant">INSERT</code> le nécessitant.
            </p>

            <div class="example">
<a name="zend.db.table.insert.key-sequence.example"></a><p class="title"><b>Exemple 276. Exemple de déclaration d'une séquence dans une classe de Table</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    protected $_sequence = 'bug_sequence';
}
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Oracle, PostgreSQL, et IBM DB2 sont des SGBDs qui supportent les séquences.
            </p>

            <p>
                PostgreSQL et IBM DB2 ont aussi des mécanismes définissant implicitement la
                séquence et les colonnes associées. Si vous utilisez un de ces procédés, considérez
                votre classe de table comme ayant une clé primaire auto-incrémentée. N'utilisez la
                chaîne de la séquence dans $_sequence que si vous voulez explicitement utiliser
                cette séquence pour générer la valeur suivante de clé.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.insert.key-natural"></a>Utiliser une classe de Table avec une clé naturelle</h4></div></div></div>
            

            <p>
                Certaines tables ont des clé naturelles, c'est à dire que vous devez fournir
                vous même, manuellement, la valeur de la clé concernée. Aucun mécanisme automatique
                (auto-incrémentation ou séquence) ne le fait pour vous.
            </p>

            <p>
                Si vous utilisez <code class="varname">$_sequence</code> avec la valeur booléenne
                <code class="constant">FALSE</code>, alors <code class="classname">Zend_Db_Table_Abstract</code> se
                comportera comme si une clé naturelle est utilisée. Ainsi, lors de l'appel de la
                méthode <code class="methodname">insert()</code>, vous devrez spécifier la valeur de la clé primaire
                vous même, autrement une <code class="classname">Zend_Db_Table_Exception</code> sera
                levée.
            </p>

            <div class="example">
<a name="zend.db.table.insert.key-natural.example"></a><p class="title"><b>Exemple 277. Exemple de déclaration d'une clé naturelle</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class BugStatus extends Zend_Db_Table_Abstract
{
    protected $_name = 'bug_status';

    protected $_sequence = false;
}
</pre>
            </div>
</div>
<br class="example-break">

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    Tous les SGBDs gère ce cas. Les tables d'intersection dans les relations
                    de type "plusieurs à plusieurs" sont de bons exemples de clés naturelles,
                    souvent composées d'autres clés étrangères.
                </p>
            </td></tr>
</table></div>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.update"></a>Mettre à jour des enregistrements dans une table</h3></div></div></div>
        

        <p>
            Vous pouvez mettre à jour des enregistrements de votre table en utilisant la
            méthode <code class="code">update</code> de votre classe de Table. Elle accepte deux paramètres. Le
            premier est un tableau associatifs des colonnes concernées, et de leurs valeurs
            respectives. Le deuxième est une expression <acronym class="acronym">SQL</acronym> qui sera utiliser comme clause
            <code class="constant">WHERE</code> dans la requête <code class="constant">UPDATE</code>.
        </p>

        <div class="example">
<a name="zend.db.table.update.example"></a><p class="title"><b>Exemple 278. Exemple de mise à jour d'enregistrements dans une table</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$table = new Bugs();

$data = array(
    'updated_on'      =&gt; '2007-03-23',
    'bug_status'      =&gt; 'FIXED'
);

$where = $table-&gt;getAdapter()-&gt;quoteInto('bug_id = ?', 1234);

$table-&gt;update($data, $where);
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            La méthode de la classe de Table <code class="methodname">update()</code> est proxiées vers la
            méthode <a class="link" href="zend.db.adapter.html#zend.db.adapter.write.update" title="Mettre à jour des données"><code class="methodname">update()</code></a> de
            l'adaptateur. Le deuxième paramètre peut donc être un tableau d'arguments pour la clause
            WHERE. Chaque élément du tableau sera joint au suivant avec une opération
            <code class="constant">AND</code>.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Les valeurs et les identifiants <acronym class="acronym">SQL</acronym> ne sont pas échappés automatiquement. Si
                vous voulez échapper des valeurs, vous devrez utiliser <code class="methodname">quote()</code>,
                <code class="methodname">quoteInto()</code>, et <code class="methodname">quoteIdentifier()</code> de l'adaptateur.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.delete"></a>Supprimer des enregistrements d'une Table</h3></div></div></div>
        

        <p>
            Pour effacer des enregistrements de votre table en utilisant sa classe de Table,
            utilisez sa méthode <code class="methodname">delete()</code>. Son seul paramètre est une chaîne ou un
            tableau définissant la clause <code class="constant">WHERE</code> à utiliser lors de la requête
            <code class="constant">DELETE</code>.
        </p>

        <div class="example">
<a name="zend.db.table.delete.example"></a><p class="title"><b>Exemple 279. Exemple de suppression d'enregistrements</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$table = new Bugs();

$where = $table-&gt;getAdapter()-&gt;quoteInto('bug_id = ?', 1235);

$table-&gt;delete($where);
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Cette méthode est proxiée vers <a class="link" href="zend.db.adapter.html#zend.db.adapter.write.delete" title="Supprimer des enregistrements"><code class="methodname">delete()</code></a> de l'adaptateur. Si
            le paramètre est un tableau, chacun des éléments du tableau sera joint au suivant avec
            l'opération <code class="constant">AND</code> pour former la clause WHERE.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Les valeurs et les identifiants <acronym class="acronym">SQL</acronym> ne sont pas échappés automatiquement. Si
                vous voulez échapper des valeurs, vous devrez utiliser <code class="methodname">quote()</code>,
                <code class="methodname">quoteInto()</code>, et <code class="methodname">quoteIdentifier()</code> de l'adaptateur.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.find"></a>Récupérer des enregistrements par clé primaire</h3></div></div></div>
        

        <p>
            Vous pouvez interroger votre table afin de récupérer des enregistrements en
            spécifiant une ou plusieurs valeurs de clé primaire. La méthode <code class="methodname">find()</code>
            permet ceci, elle prend comme premier paramètre une valeur ou un tableau de valeurs de
            clé primaire.
        </p>

        <div class="example">
<a name="zend.db.table.find.example"></a><p class="title"><b>Exemple 280. Exemple de récupération d'enregistrements par clé primaire</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$table = new Bugs();

// Récupère un enregistrement, mais
// retourne un Rowset
$rows = $table-&gt;find(1234);

// Récupère plusieurs enregistrement
// retourne un Rowset
$rows = $table-&gt;find(array(1234, 5678));
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Si une seule clé est passée en paramètre, la méthode retournera au plus un
            résultat (car par définition, une clé primaire assure l'unicité d'un enregistrement). Si
            vous passez plusieurs valeurs de clés, alors la méthode pourra retourner plusieurs
            enregistrements. Cette méthode pourra aussi retourner zéro enregistrement. Quoiqu'il en
            soit, l'objet de retour est bien un
            <code class="classname">Zend_Db_Table_Rowset_Abstract</code>.
        </p>

        <p>
            Si votre clé primaire est une clé composée de plusieurs colonnes, passez alors les
            autres valeurs de colonne comme paramètres à la méthode <code class="methodname">find()</code>. Il doit y
            avoir autant de paramètres passés à la méthode, que de colonnes composant la clé.
        </p>

        <p>
            Ainsi, pour trouver plusieurs enregistrements en passant plusieurs valeurs de clés
            primaires composées, passez autant de tableaux composés, que de colonnes représentant
            les clés. Les tableaux doivent donc, comporter le même nombre de valeurs. Celles-ci vont
            ainsi fonctionner par tuples : tous les premiers éléments des tableaux seront
            évalués pour la première recherche, et chacun représentera une colonne composant la clé
            primaire. Puis ainsi de suite, jusqu'à la fin des tableaux.
        </p>

        <div class="example">
<a name="zend.db.table.find.example-compound"></a><p class="title"><b>Exemple 281. Exemple de recherche avec une clé primaire composée</b></p>
<div class="example-contents">
            

            <p>
                L'exemple suivant appelle <code class="methodname">find()</code> pour récupérer deux enregistrements en
                se basant sur une clé à deux colonnes. Le premier enregistrement aura une clé
                primaire (1234, 'ABC'), et le second une valeur de clé primaire (5678, 'DEF').
            </p>

            <pre class="programlisting">
class BugsProducts extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs_products';
    protected $_primary = array('bug_id', 'product_id');
}

$table = new BugsProducts();

// Retourne un enregistrement unique, basé sur une clé
// primaire à deux colonnes
$rows = $table-&gt;find(1234, 'ABC');

// Retourne deux enregistrements, basés sur une clé
// primaire à deux colonnes
$rows = $table-&gt;find(array(1234, 5678), array('ABC', 'DEF'));
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.fetch-all"></a>Requêter pour plusieurs enregistrements</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.fetch-all.select"></a>API de l'objet Select</h4></div></div></div>
            

            <p>
                </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Avertissement]" src="images/warning.png"></td>
<th align="left">Avertissement</th>
</tr>
<tr><td align="left" valign="top">
                    <p>
                        L'API pour les opérations de récupération d'enregistrements a été
                        améliorée afin d'autoriser un objet
                        <code class="classname">Zend_Db_Table_Select</code> à modifier la requête. Les
                        anciens comportements de <code class="methodname">fetchRow()</code> et <code class="methodname">fetchAll()</code>
                        sont désormais dépréciés, mais toujours fonctionnels à ce jour.
                    </p>

                    <p>
                        Les requêtes suivantes sont sémantiquement identiques et fonctionnent.
                        Il est conseillé cependant d'utiliser l'implémentation avec l'objet
                        select.
                    </p>

                    <p>
                        </p>
<pre class="programlisting">
// Récupérer un rowset
$rows = $table-&gt;fetchAll('bug_status = "NEW"', 'bug_id ASC', 10, 0);
$rows = $table-&gt;fetchAll($table-&gt;select()-&gt;where('bug_status = ?', 'NEW')
                                         -&gt;order('bug_id ASC')
                                         -&gt;limit(10, 0));
// ou avec liaison :
$rows = $table-&gt;fetchAll(
    $table-&gt;select()
        -&gt;where('bug_status = :status')
        -&gt;bind(array(':status'=&gt;'NEW')
        -&gt;order('bug_id ASC')
        -&gt;limit(10, 0)
    );

// Récupérer un row
$row = $table-&gt;fetchRow('bug_status = "NEW"', 'bug_id ASC');
$row = $table-&gt;fetchRow($table-&gt;select()-&gt;where('bug_status = ?', 'NEW')
                                        -&gt;order('bug_id ASC'));
// ou avec liaison :
$row = $table-&gt;fetchRow(
    $table-&gt;select()
        -&gt;where('bug_status = :status')
        -&gt;bind(array(':status'=&gt;'NEW')
        -&gt;order('bug_id ASC')
    );
</pre>
                    </td></tr>
</table></div>
<p>
                </p>

            <p>
                L'objet <code class="classname">Zend_Db_Table_Select</code> est une extension de
                <code class="classname">Zend_Db_Select</code> mais qui applique des restrictions
                particulières à la requête. Les restrictions sont :
            </p>

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Vous <span class="emphasis"><em>pouvez</em></span> utiliser l'objet pour ne sélectionner
                        que certaines colonnes de l'enregistrement à retourner. Ceci est pratique
                        dans le cas où vous n'avez pas besoin spécifiquement de toutes les colonnes
                        d'une table.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Vous <span class="emphasis"><em>pouvez</em></span> spécifier des colonnes avec des
                        évaluations envers des expressions <acronym class="acronym">SQL</acronym>. Cependant, l'enregistrement
                        résultant sera alors en mode lecture seule (<span class="property">readOnly</span>)
                        et ne pourra pas être propagé en base de données (<code class="methodname">save()</code>). Un
                        appel à <code class="methodname">save()</code> lèvera une exception.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Vous <span class="emphasis"><em>pouvez</em></span> utiliser des jointures JOIN vers
                        d'autres tables, mais uniquement pour des critères de jointure, et non
                        sélectionner des colonnes jointes.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Vous <span class="emphasis"><em>ne pouvez pas</em></span> spécifier de colonnes JOINtes
                        comme faisant partie du résultat de la requête. L'objet row/rowset serait
                        alors corrompu, et contiendrait des données d'une table étrangère à sa table
                        originale. Une erreur sera renvoyée dans un tel cas.
                    </p>
                </li>
</ul></div>

            <p>
                </p>
<div class="example">
<a name="zend.db.table.qry.rows.set.simple.usage.example"></a><p class="title"><b>Exemple 282. Utilisation simple</b></p>
<div class="example-contents">
                    

                    <pre class="programlisting">
$table = new Bugs();

$select = $table-&gt;select();
$select-&gt;where('bug_status = ?', 'NEW');

$rows = $table-&gt;fetchAll($select);
</pre>
                </div>
</div>
<p><br class="example-break">
            </p>

            <p>
                L'objet <code class="code">Select</code> utilise une interface fluide (fluent interface),
                permettant le chaînage des méthodes.
            </p>

            <p>
                </p>
<div class="example">
<a name="zend.db.table.qry.rows.set.fluent.interface.example"></a><p class="title"><b>Exemple 283. Exemple d'interface fluide</b></p>
<div class="example-contents">
                    

                    <pre class="programlisting">
$table = new Bugs();

$rows = $table-&gt;fetchAll($table-&gt;select()
                               -&gt;where('bug_status = ?', 'NEW'));
</pre>
                </div>
</div>
<p><br class="example-break">
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.fetch-all.usage"></a>Récupérer un jeu d'enregistrements :</h4></div></div></div>
            

            <p>
                Vous pouvez demander une requête qui retourne plusieurs enregistrements. La
                méthode <code class="methodname">fetchAll()</code> de votre classe de Table permet ceci. Elle retourne
                un objet de type <code class="classname">Zend_Db_Table_Rowset_Abstract</code>, même si aucun
                enregistrement ne correspond à la requête.
            </p>

            <div class="example">
<a name="zend.db.table.qry.rows.set.finding.row.example"></a><p class="title"><b>Exemple 284. Exemple de récupération d'enregistrements</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$table = new Bugs();

$select = $table-&gt;select()-&gt;where('bug_status = ?', 'NEW');

$rows = $table-&gt;fetchAll($select);
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Vous pouvez aussi définir les clauses <acronym class="acronym">SQL</acronym> <code class="code">ORDER BY</code> ou encore
                <code class="constant">LIMIT</code> (ou autre équivalent comme OFFSET).
            </p>

            <div class="example">
<a name="zend.db.table.fetch-all.example2"></a><p class="title"><b>Exemple 285. Exemple de récupération d'enregistrements avec des clauses SQL</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$table = new Bugs();

$order  = 'bug_id';

// Retourne les enregistrements du 21ème au 30ème
$count  = 10;
$offset = 20;

$select = $table-&gt;select()-&gt;where('bug_status = ?', 'NEW')
                          -&gt;order($order)
                          -&gt;limit($count, $offset);

$rows = $table-&gt;fetchAll($select);
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Tous les arguments de requêtes sont optionnels. Vous pouvez écrire une requête
                sans clause WHERE ni LIMIT ou encore ORDER.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.advanced.usage"></a>Utilisation avancée</h4></div></div></div>
            

            <p>
                Pour une utilisation plus avancée, vous pourriez vouloir spécifier une à une
                les colonnes que les enregistrements trouvés doivent comporter. Ceci se fait au
                moyen de la clause FROM de l'objet select. Le premier paramètre dans la clause FROM
                est le même que celui d'un objet Zend_Db_Select, cependant l'objet
                Zend_Db_Table_Select admet une instance de Zend_Db_Table_Abstract pour définir le
                nom de la table.
            </p>

            <p>
                </p>
<div class="example">
<a name="zend.db.table.qry.rows.set.retrieving.a.example"></a><p class="title"><b>Exemple 286. Récupérer des colonnes spécifiques sur les enregistrements</b></p>
<div class="example-contents">
                    

                    <pre class="programlisting">
$table = new Bugs();

$select = $table-&gt;select();
$select-&gt;from($table, array('bug_id', 'bug_description'))
       -&gt;where('bug_status = ?', 'NEW');

$rows = $table-&gt;fetchAll($select);
</pre>
                </div>
</div>
<p><br class="example-break">
            </p>

            <p>
                </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top">
                    <p>
                        Le jeu de résultats retourné est tout de même valide. Il ne possède en
                        revanche que certaines colonnes de la table. La méthode <code class="methodname">save()</code>
                        est appelable, mais elle ne mettre à jour que ces colonnes.
                    </p>
                </td></tr>
</table></div>
<p> Il est aussi possible de spécifier des expressions dans une clause
            FROM, et donc récupérer un objet row/rowset en lecture seule. Dans l'exemple
            ci-après, nous retournons un enregistrement de la table "bugs" qui représente un
            agrégat du nombre de nouveaux bugs reportés. Regardez la clause GROUP. L'alias SQL
            "count" sera accessible dans le row/rowset résultant, comme si il faisait parti de
                la table en tant que colonne.
            </p>

            <p>
                </p>
<div class="example">
<a name="zend.db.table.qry.rows.set.retrieving.b.example"></a><p class="title"><b>Exemple 287. Récupérer des enregistrements avec des requêtes incluant des
                    expressions</b></p>
<div class="example-contents">
                    

                    <pre class="programlisting">
$table = new Bugs();

$select = $table-&gt;select();
$select-&gt;from($table,
              array('COUNT(reported_by) as `count`', 'reported_by'))
       -&gt;where('bug_status = ?', 'NEW')
       -&gt;group('reported_by');

$rows = $table-&gt;fetchAll($select);
</pre>
                </div>
</div>
<p><br class="example-break"> Vous pouvez aussi utiliser une table de jointure comme partie de
            votre requête. Dans l'exemple ci-dessous, nous utilisons la table "accounts" comme
            partie de la recherche, pour tous les bugs reportés par "Bob".
            </p>

            <p>
                </p>
<div class="example">
<a name="zend.db.table.qry.rows.set.refine.example"></a><p class="title"><b>Exemple 288. Utiliser une table intermédiaire par jointure avec
                    <code class="methodname">fetchAll()</code></b></p>
<div class="example-contents">
                    

                    <pre class="programlisting">
$table = new Bugs();

// Récupération avec la partie from déjà spécifié, important lors des jointures
$select = $table-&gt;select(Zend_Db_Table::SELECT_WITH_FROM_PART);
$select-&gt;setIntegrityCheck(false)
       -&gt;where('bug_status = ?', 'NEW')
       -&gt;join('accounts', 'accounts.account_name = bugs.reported_by')
       -&gt;where('accounts.account_name = ?', 'Bob');

$rows = $table-&gt;fetchAll($select);
</pre>
                </div>
</div>
<p><br class="example-break">
            </p>

            <p>
                L'objet <code class="classname">Zend_Db_Table_Select</code> est destiné à sélectionner
                des données sur une table précise. Des jointures peuvent être faites, mais il n'est
                pas possible de sélectionner des colonnes ne faisant pas partie de la table
                sous-jacente. Cependant, ceci aurait pu être utile dans certains cas, et l'objet
                <code class="classname">Zend_Db_Table_Select</code> possède une clause spéciale
                déverrouillant cette limitation. Passez la valeur <code class="constant">FALSE</code> à sa méthode
                <code class="code">setIntegrityCheck</code>. Il est alors possible de sélectionner des colonnes
                hors table. Attention toutefois, l'objet row/rowset résultant sera verrouillé.
                Impossible d'y appeler <code class="methodname">save()</code>, <code class="methodname">delete()</code> ou même d'affecter
                une valeur à certains de ses champs. Une exception sera systématiquement
                levée.
            </p>

            <div class="example">
<a name="zend.db.table.qry.rows.set.integrity.example"></a><p class="title"><b>Exemple 289. 
                    Déverrouiller un objet Zend_Db_Table_Select pour récupérer des colonnes JOINtes
                </b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$table = new Bugs();

$select = $table-&gt;select(Zend_Db_Table::SELECT_WITH_FROM_PART)
                -&gt;setIntegrityCheck(false);
$select-&gt;where('bug_status = ?', 'NEW')
       -&gt;join('accounts',
              'accounts.account_name = bugs.reported_by',
              'account_name')
       -&gt;where('accounts.account_name = ?', 'Bob');

$rows = $table-&gt;fetchAll($select);
</pre>
            </div>
</div>
<br class="example-break">
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.fetch-row"></a>Récupérer un seul enregistrement</h3></div></div></div>
        

        <p>
            Vous pouvez demander à ne récupérer qu'un seul résultat, en requêtant de manière
            similaire à la méthode <code class="methodname">fetchAll()</code>.
        </p>

        <div class="example">
<a name="zend.db.table.fetch-row.example1"></a><p class="title"><b>Exemple 290. Exemple de récupération d'un seul enregistrement</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$table = new Bugs();

$select  = $table-&gt;select()-&gt;where('bug_status = ?', 'NEW')
                           -&gt;order('bug_id');

$row = $table-&gt;fetchRow($select);
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Cette méthode retourne un objet de type Zend_Db_Table_Row_Abstract. Si la requête
            ne trouve aucun enregistrement, alors <code class="methodname">fetchRow()</code> retournera
            <code class="constant">NULL</code>.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.info"></a>Récupérer les méta données d'une Table</h3></div></div></div>
        

        <p>
            La classe Zend_Db_Table_Abstract propose des informations concernant ses méta
            données.La méthode <code class="methodname">info()</code> retourne un tableau d'informations sur les
            colonnes, la clé primaire, etc. de la table.
        </p>

        <div class="example">
<a name="zend.db.table.info.example"></a><p class="title"><b>Exemple 291. Exemple de récupération du nom de la table</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$table = new Bugs();

$info = $table-&gt;info();

echo "The table name is " . $info['name'] . "\n";
</pre>
        </div>
</div>
<br class="example-break">

        <p>Les clés du tableau retourné par <code class="methodname">info()</code> sont les suivantes :</p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><span class="emphasis"><em>name</em></span> =&gt; nom de la table.</p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>cols</em></span> =&gt; un tableau contenant les colonnes de la
                    table.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>primary</em></span> =&gt; un tableau contenant la(les) colonnes
                    utilisée(s) pour définir la clé primaire de la table.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>metadata</em></span> =&gt; un tableau associatif, associant les
                    noms des colonnes de la tables, à leurs informations intrinsèques. Les données
                    sont les mêmes que celles retournée par <code class="methodname">describeTable()</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>rowClass</em></span> =&gt; le nom de la classe concrète servant
                    les objets représentants les enregistrements de la table. Par défaut :
                    Zend_Db_Table_Row.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>rowsetClass</em></span> =&gt; le nom de la classe concrète
                    servant de conteneur d'objets représentants les enregistrements de la table. Par
                    défaut : Zend_Db_Table_Rowset.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>referenceMap</em></span> =&gt; un tableau associatif. Il
                    représente les références de cette table vers ses parents éventuelles. Voyez
                    <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.defining" title="Définir ses relations">la section intitulée « Définir ses relations »</a>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>dependentTables</em></span> =&gt; un tableau de noms de classes
                    de tables qui référencent cette table. Voyez <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.defining" title="Définir ses relations">la section intitulée « Définir ses relations »</a>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>schema</em></span> =&gt; Le nom de la base de données comportant
                    cette table.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.metadata.caching"></a>Cacher les méta données de la table</h3></div></div></div>
        

        <p>
            Par défaut, <code class="classname">Zend_Db_Table_Abstract</code> demande à la base de
            données les <a class="link" href="zend.db.table.html#zend.db.table.info" title="Récupérer les méta données d'une Table">méta données de table</a>, à chaque
            instanciation d'objet de table. L'objet de table analyse les métadonnées de la table
            dans le SGDB en utilisant la méthode <code class="methodname">describeTable()</code> de l'adaptateur. Les
            opérations nécessitant cette introspection incluent :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p><code class="methodname">insert()</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">find()</code></p>
            </li>
<li class="listitem">
                <p><code class="methodname">info()</code></p>
            </li>
</ul></div>

        <p>
            Cependant, il peut être dégradant pour les performances du SGBD de lui demander
            ces informations à chaque instanciation de chaque objet de chaque table. Ainsi, un
            système de cache pour les méta données a été mis en place.
        </p>

        <p>
            La mise en cache des méta données des tables peut être contrôlée de deux manières :
            </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>Un appel à la méthode statique
                        Zend_Db_Table_Abstract::setDefaultMetadataCache()</em></span> - Ceci permet
                        d'enregistrer une fois pour toutes l'objet de cache que toutes les tables
                        devront utiliser.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>L'appel au constructeur
                        Zend_Db_Table_Abstract::__construct()</em></span> - Il va permettre de
                        spécifier l'objet de cache pour une table en particulier.
                    </p>
                </li>
</ul></div>
<p>
            Dans tous les cas, vous devrez passer soit <code class="constant">NULL</code> (et
            ainsi désactiver le cache des méta données des tables), soit une instance de <a class="link" href="zend.cache.frontends.html#zend.cache.frontends.core" title="Zend_Cache_Core"><code class="classname">Zend_Cache_Core</code></a>. Il
            est possible d'utiliser à la fois <code class="code">setDefaultMetadataCache</code> et le
            constructeur afin d'avoir un objet de cache par défaut, puis un spécifique pour
            certaines classes.
        </p>

        <div class="example">
<a name="zend.db.table.metadata.caching-default"></a><p class="title"><b>Exemple 292. Utiliser un objet de cache de méta données pour toutes les classes</b></p>
<div class="example-contents">
            

            <p>
                L'exemple qui suit illustre la manière de passer un objet de cache de méta
                données général, pour toutes les classes de table :
            </p>

            <pre class="programlisting">
// D'abord, configurons le cache
$frontendOptions = array(
    'automatic_serialization' =&gt; true
    );

$backendOptions  = array(
    'cache_dir'                =&gt; 'cacheDir'
    );

$cache = Zend_Cache::factory('Core',
                             'File',
                             $frontendOptions,
                             $backendOptions);

// Puis passons le comme objet de cache par défaut
Zend_Db_Table_Abstract::setDefaultMetadataCache($cache);

// Testons avec une classe
class Bugs extends Zend_Db_Table_Abstract
{
    // ...
}

// Chaque instance utilise l'objet par défaut
$bugs = new Bugs();
</pre>
        </div>
</div>
<br class="example-break">

        <div class="example">
<a name="zend.db.table.metadata.caching-instance"></a><p class="title"><b>Exemple 293. Utiliser un objet de cache de métadonnées pour une instance précise</b></p>
<div class="example-contents">
            

            <p>
                L'exemple qui suit illustre la manière de passer un objet de cache de méta
                données spécifique, pour une instance précise :
            </p>

            <pre class="programlisting">
// D'abord, configurons le cache
$frontendOptions = array(
    'automatic_serialization' =&gt; true
    );

$backendOptions  = array(
    'cache_dir'                =&gt; 'cacheDir'
    );

$cache = Zend_Cache::factory('Core',
                             'File',
                             $frontendOptions,
                             $backendOptions);

// Testons avec une classe
class Bugs extends Zend_Db_Table_Abstract
{
    // ...
}

// Lors de son instanciation, il est possible
// de lui passer l'objet de cache
$bugs = new Bugs(array('metadataCache' =&gt; $cache));
</pre>
        </div>
</div>
<br class="example-break">

        <div class="note"><table border="0" summary="Note: Sérialisation automatique avec Cache Frontend">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Sérialisation automatique avec Cache Frontend</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Étant donné que les informations retournées par
                <code class="methodname">describeTable()</code> le sont sous forme de tableau, assurez vous
                que le paramètre <code class="code">automatic_serialization</code> est à <code class="constant">TRUE</code> pour
                l'objet de la classe <code class="classname">Zend_Cache_Core</code>.
            </p>
        </td></tr>
</table></div>

        <p>
            Dans nos exemples, nous utilisons <code class="classname">Zend_Cache_Backend_File</code>,
            mais vous pouvez utiliser le backend que vous souhaitez, voyez <a class="link" href="zend.cache.html" title="Zend_Cache">Zend_Cache</a> pour plus d'informations.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.metadata.caching.hardcoding"></a>Coder en dur les métadonnées de tables</h4></div></div></div>
            

            <p>
                Pour cacher les métadonnées une étape plus avant, vous pouvez aussi choisir de
                coder en dur ces métadonnées. Dans ce cas particulier, cependant, tout changement au
                schéma de la table requerra un changement dans votre code. Ainsi, il est seulement
                recommandé pour ceux qui sont dans la phase d'optimisation pour un usage en
                production.
            </p>

            <p>La structure des métadonnées est comme ceci :</p>

            <pre class="programlisting">
protected $_metadata = array(
    '&lt;column_name&gt;' =&gt; array(
        'SCHEMA_NAME'      =&gt; &lt;string&gt;,
        'TABLE_NAME'       =&gt; &lt;string&gt;,
        'COLUMN_NAME'      =&gt; &lt;string&gt;,
        'COLUMN_POSITION'  =&gt; &lt;int&gt;,
        'DATA_TYPE'        =&gt; &lt;string&gt;,
        'DEFAULT'          =&gt; NULL|&lt;value&gt;,
        'NULLABLE'         =&gt; &lt;bool&gt;,
        'LENGTH'           =&gt; &lt;string - length&gt;,
        'SCALE'            =&gt; NULL|&lt;value&gt;,
        'PRECISION'        =&gt; NULL|&lt;value&gt;,
        'UNSIGNED'         =&gt; NULL|&lt;bool&gt;,
        'PRIMARY'          =&gt; &lt;bool&gt;,
        'PRIMARY_POSITION' =&gt; &lt;int&gt;,
        'IDENTITY'         =&gt; &lt;bool&gt;,
    ),
    // additional columns...
);
</pre>

            <p>
                Une manière simple de récupérer les valeurs appropriées est d'activer le cache
                des métadonnées et d'utiliser celles présentes dans votre cache.
            </p>

            <p>
                Vous pouvez désactiver cette optimisation en mettant à <code class="constant">FALSE</code> le
                paramètre <code class="code">metadataCacheInClass</code> :
            </p>

            <pre class="programlisting">
// Lors de l'instanciation :
$bugs = new Bugs(array('metadataCacheInClass' =&gt; false));

// Ou plus tard :
$bugs-&gt;setMetadataCacheInClass(false);
</pre>

            <p>
                Ce paramètre est activé par défaut, ce qui assure que le tableau
                <code class="varname">$_metadata</code> n'est chargé qu'une seule fois par instance
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.extending"></a>Personnaliser et étendre une classe de Table</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.extending.row-rowset"></a>Utiliser des objets Row ou Rowset personnalisés</h4></div></div></div>
            

            <p>
                Par défaut, les méthodes de la classe de Table retourne des jeux
                d'enregistrements comme étant des instances de la classe
                <code class="classname">Zend_Db_Table_Rowset</code>, ces "Rowsets" contiennent des
                enregistrements de la table, représentés par des objets instances de
                <code class="classname">Zend_Db_Table_Row</code>. Vous pouvez spécifier vos propres classes
                pour row/rowset, mais elles doivent étendre
                <code class="classname">Zend_Db_Table_Rowset_Abstract</code> ou
                <code class="classname">Zend_Db_Table_Row_Abstract</code>, respectivement.
            </p>

            <p>
                Vous pouvez spécifier vos classes row/rowset en utilisant le constructeur de
                la classe de Table, via le tableau d'options, aux clés <code class="code">"rowClass"</code> et
                <code class="code">"rowsetClass"</code>. Indiquez les noms des classes sous forme de chaînes de
                caractères.
            </p>

            <div class="example">
<a name="zend.db.table.extending.row-rowset.example"></a><p class="title"><b>Exemple 294. Exemple de spécification de ses propres classes Row et Rowset</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class My_Row extends Zend_Db_Table_Row_Abstract
{
    ...
}

class My_Rowset extends Zend_Db_Table_Rowset_Abstract
{
    ...
}

$table = new Bugs(
    array(
        'rowClass'    =&gt; 'My_Row',
        'rowsetClass' =&gt; 'My_Rowset'
    )
);

$where = $table-&gt;getAdapter()-&gt;quoteInto('bug_status = ?', 'NEW')

// Retourne un objet de type My_Rowset,
// contenant des objets de type My_Row.
$rows = $table-&gt;fetchAll($where);
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Vous pouvez aussi utiliser les méthodes <code class="methodname">setRowClass()</code> et
                <code class="methodname">setRowsetClass()</code>. Ceci s'applique alors de manière ponctuelle, et non
                plus globale pour toute la classe de Table en tout point.
            </p>

            <div class="example">
<a name="zend.db.table.extending.row-rowset.example2"></a><p class="title"><b>Exemple 295. Exemple de changement ponctuel des classes de Row et Rowset</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$table = new Bugs();

$where = $table-&gt;getAdapter()-&gt;quoteInto('bug_status = ?', 'NEW')

// Retourne un objet de type Zend_Db_Table_Rowset
// contenant des objets de type Zend_Db_Table_Row.
$rowsStandard = $table-&gt;fetchAll($where);

$table-&gt;setRowClass('My_Row');
$table-&gt;setRowsetClass('My_Rowset');

// Retourne un objet de type My_Rowset,
// contenant des objets de type My_Row.
$rowsCustom = $table-&gt;fetchAll($where);

// L'objet $rowsStandard existe toujours et n'a pas changé d'état.
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Pour des informations détaillées concernant les classes Row et Rowset, voyez
                <a class="xref" href="zend.db.table.row.html" title="Zend_Db_Table_Row">la section intitulée « Zend_Db_Table_Row »</a> et <a class="xref" href="zend.db.table.rowset.html" title="Zend_Db_Table_Rowset">la section intitulée « Zend_Db_Table_Rowset »</a>.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.extending.insert-update"></a>Personnaliser les logiques Insert, Update, et Delete</h4></div></div></div>
            

            <p>
                Vous pouvez redéfinir les méthodes <code class="methodname">insert()</code> et
                <code class="methodname">update()</code> afin d'y ajouter votre propre logique. Assurez vous d'appeler
                les méthodes parentes une fois votre code écrit.
            </p>

            <div class="example">
<a name="zend.db.table.extending.insert-update.example"></a><p class="title"><b>Exemple 296. 
                    Exemple d'implémentation d'une logique personnalisée gérant des timestamps
                </b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    public function insert(array $data)
    {
        // Ajout d'un timestamp
        if (empty($data['created_on'])) {
            $data['created_on'] = time();
        }
        return parent::insert($data);
    }

    public function update(array $data, $where)
    {
        // Ajout d'un timestamp
        if (empty($data['updated_on'])) {
            $data['updated_on'] = time();
        }
        return parent::update($data, $where);
    }
}
</pre>
            </div>
</div>
<br class="example-break">

            <p>Il est aussi possible de redéfinir la méthode <code class="methodname">delete()</code>.</p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.extending.finders"></a>Définir des méthodes de recherches personnalisées dans Zend_Db_Table</h4></div></div></div>
            

            <p>
                Bien que <code class="methodname">fetchAll()</code> fonctionne très bien, si vous avez plusieurs
                appels similaires à cette méthode (ou une autre), il peut être intéressant de
                factoriser du code en créant votre propre méthode de récupération d'enregistrements,
                utilisant <code class="methodname">fetchAll()</code> ou une autre méthode.
            </p>

            <div class="example">
<a name="zend.db.table.extending.finders.example"></a><p class="title"><b>Exemple 297. Méthode personnalisée de récupération d'enregistrements "bugs" par
                critère "status"</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    public function findByStatus($status)
    {
        $where = $this-&gt;getAdapter()-&gt;quoteInto('bug_status = ?',
                                                $status);
        return $this-&gt;fetchAll($where, 'bug_id');
    }
}
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.extending.inflection"></a>Utiliser l'inflexion dans Zend_Db_Table</h4></div></div></div>
            

            <p>
                L'<span class="emphasis"><em>inflexion</em></span> est un processus de transformations de
                caractères. Par défaut, si vous ne définissez pas de nom à votre table via la
                propriété protégée <code class="varname">$_name</code>,
                <code class="classname">Zend_Db_Table_Abstract</code> va utiliser le nom de la classe comme
                nom de table, sans effectuer aucune transformation.
            </p>

            <p>
                Certaines personnes peuvent vouloir utiliser un mécanisme d'inflexion pour
                transformer le nom de la classe d'une manière bien spécifique, afin de retrouver le
                nom de la table.
            </p>

            <p>
                Par exemple, une classe nommée "<code class="code">BugsProducts</code>", peut vouloir
                refléter une table s'appelant "<code class="code">bugs_products</code>," sans utiliser la
                propriété de classe <code class="varname">$_name</code>. Dans cette règle d'inflexion, les mots
                composant le nom de la classe sont écrits en "CamelCase", et seraient transformés en
                mots en minuscules, et séparés par des tirets bas.
            </p>

            <p>
                Vous pouvez aussi spécifier le nom de la table indépendamment du nom de la
                classe. Utilisez pour cela la propriété <code class="varname">$_name</code> de la classe de
                Table.
            </p>

            <p>
                Si vous voulez utiliser l'inflexion, vous devrez créer une classe (abstraite)
                étendant <code class="classname">Zend_Db_Table_Abstract</code>, et redéfinissant sa méthode
                protégée <code class="methodname">_setupTableName()</code>. Toutes les classes de Table devront alors
                hériter de cette nouvelle classe abstraite.
            </p>

            <div class="example">
<a name="zend.db.table.extending.inflection.example"></a><p class="title"><b>Exemple 298. Exemple d'une classe abstraite utilisant l'inflexion</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
abstract class MyAbstractTable extends Zend_Db_Table_Abstract
{
    protected function _setupTableName()
    {
        if (!$this-&gt;_name) {
            $this-&gt;_name = myCustomInflector(get_class($this));
        }
        parent::_setupTableName();
    }
}

class BugsProducts extends MyAbstractTable
{
}
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                C'est à vous d'écrire les fonctions qui vont établir le mécanisme
                d'inflexion.
            </p>
        </div>
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.db.select.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.db.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.db.table.row.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Zend_Db_Select </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Zend_Db_Table_Row</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
