<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Zend_Db_Adapter</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.db.html" title="Zend_Db">
<link rel="prev" href="zend.db.html" title="Zend_Db">
<link rel="next" href="zend.db.statement.html" title="Zend_Db_Statement">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Zend_Db_Adapter</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.db.html">Précédent</a> </td>
<th width="60%" align="center">Zend_Db</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.db.statement.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.adapter"></a>Zend_Db_Adapter</h2></div></div></div>
    

    <p>
        <code class="classname">Zend_Db</code> et ses autres sous classes proposent une interface de
        connexion aux bases de données avec Zend Framework. <code class="classname">Zend_Db_Adapter</code>
        est la classe de base que vous utilisez pour vous connecter aux bases de données (SGBDs). Il
        y a différentes classes d'adaptateur par SGBD.
    </p>

    <p>
        Les classes <code class="code">Adapters</code> de <code class="classname">Zend_Db</code> créent un pont
        entre les extensions <acronym class="acronym">PHP</acronym> et une interface commune. Ceci vous aide à écrire des applications
        déployables avec de multiples SGBDs, demandant peu d'efforts.
    </p>

    <p>
        L'interface de la classe d'adaptateur est semblable à celle de l'extension <a class="ulink" href="http://www.php.net/pdo" target="_top">PHP Data Objects</a>. <code class="classname">Zend_Db</code>
        propose des classes d'adaptateurs vers les drivers <acronym class="acronym">PDO</acronym> pour les SGBDs suivants :
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                IBM DB2 et Informix Dynamic Server (IDS), en utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/pdo-ibm" target="_top">pdo_ibm</a>.
            </p>
        </li>
<li class="listitem">
             <p>
                MariaDB, utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/pdo-mysql" target="_top">pdo_mysql</a>.
            </p>
        </li>
<li class="listitem">
            <p>
                MySQL, utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/pdo-mysql" target="_top">pdo_mysql</a>.
            </p>
        </li>
<li class="listitem">
            <p>
                Microsoft <acronym class="acronym">SQL</acronym> Server, utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/pdo-dblib" target="_top">pdo_dblib</a>.
            </p>
        </li>
<li class="listitem">
            <p>
                Oracle, utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/pdo-oci" target="_top">pdo_oci</a>.
            </p>
        </li>
<li class="listitem">
            <p>
                PostgreSQL, grâce à l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/pdo-pgsql" target="_top">pdo_pgsql</a>.
            </p>
        </li>
<li class="listitem">
            <p>
                SQLite, avec l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/pdo-sqlite" target="_top">pdo_sqlite</a>.
            </p>
        </li>
</ul></div>

    <p>
        De plus, <code class="classname">Zend_Db</code> fournit aussi des classes se connectant avec
        les extensions <acronym class="acronym">PHP</acronym> propres aux SGBDs (hors <acronym class="acronym">PDO</acronym> donc), pour les SGBDs suivants :
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                MariaDB, utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/mysqli" target="_top">mysqli</a>.
            </p>
        </li>
<li class="listitem">
            <p>
                MySQL, utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/mysqli" target="_top">mysqli</a>.
            </p>
        </li>
<li class="listitem">
            <p>
                Oracle, utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/oci8" target="_top">oci8</a>.
            </p>
        </li>
<li class="listitem">
            <p>
                IBM DB2, utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/ibm_db2" target="_top">ibm_db2</a>.
            </p>
        </li>
<li class="listitem">
            <p>
                Firebird (Interbase), utilisant l'extension <acronym class="acronym">PHP</acronym> <a class="ulink" href="http://www.php.net/ibase" target="_top">php_interbase</a>
            </p>
        </li>
</ul></div>

    <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
        <p>
            Chaque <code class="classname">Zend_Db_Adapter</code> utilise une extension <acronym class="acronym">PHP</acronym>. Vous
            devez donc les avoir activées pour utiliser les classes en question. Par exemple, si
            vous voulez utiliser une classe <code class="classname">Zend_Db_Adapter</code> basée sur <acronym class="acronym">PDO</acronym>,
            vous devrez alors avoir l'extension <acronym class="acronym">PDO</acronym> d'installée, ainsi que l'extension représentant
            le driver spécifique à votre SGBD.
        </p>
    </td></tr>
</table></div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.connecting"></a>Se connecter à un SGBD en utilisant un adaptateur</h3></div></div></div>
        

        <p>
            Cette section décrit comment créer une instance d'un adaptateur
            <code class="classname">Zend_Db</code> de base de données.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.constructor"></a>Utilisation du constructeur du Zend_Db Adapter</h4></div></div></div>
            

            <p>
                Vous pouvez créer une instance d'un adaptateur en utilisant son constructeur.
                Celui-ci accepte un paramètre représentant un tableau d'options.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.constructor.example"></a><p class="title"><b>Exemple 184. Utiliser le constructeur de l'adaptateur</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db = new Zend_Db_Adapter_Pdo_Mysql(array(
    'host'     =&gt; '127.0.0.1',
    'username' =&gt; 'webuser',
    'password' =&gt; 'xxxxxxxx',
    'dbname'   =&gt; 'test'
));
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.factory"></a>Utiliser la fabrique (Factory) de Zend_Db</h4></div></div></div>
            

            <p>
                Alternativement, il est possible d'utiliser la méthode statique
                <code class="methodname">Zend_Db::factory()</code>. Celle-ci charge dynamiquement la classe
                d'adaptateur correspondant en utilisant <a class="link" href="zend.loader.load.html#zend.loader.load.class" title="Charger des classes">Zend_Loader::loadClass()</a>.
            </p>

            <p>
                Le premier argument est une chaîne désignant l'adaptateur souhaité. Par
                exemple, "<code class="classname">Pdo_Mysql</code>" va correspondre à la classe
                <code class="classname">Zend_Db_Adapter_Pdo_Mysql</code>. Le second paramètre est un tableau
                d'options. C'est le même que celui que vous auriez passé au constructeur de la
                classe directement.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.factory.example"></a><p class="title"><b>Exemple 185. Utilisation de la méthode statique de fabrique de Zend_Db</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// Nous n'avons pas besoin de la ligne suivante car Zend_Db_Adapter_Pdo_Mysql
// sera automatiquement chargé par la fabrique Zend_Db.

// require_once 'Zend/Db/Adapter/Pdo/Mysql.php';

// Charge automatiquement la classe Zend_Db_Adapter_Pdo_Mysql
// et en créer une instance.
$db = Zend_Db::factory('Pdo_Mysql', array(
    'host'     =&gt; '127.0.0.1',
    'username' =&gt; 'webuser',
    'password' =&gt; 'xxxxxxxx',
    'dbname'   =&gt; 'test'
));
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Si vous créez votre propre classe d'adaptateur qui étend
                <code class="classname">Zend_Db_Adapter_Abstract</code> et que celle-ci ne respecte pas la
                syntaxe du préfixe package "<code class="classname">Zend_Db_Adapter</code>", utilisez alors
                la clé "<code class="code">adapterNamespace</code>" dans le tableau de configuration passé à la
                méthode <code class="methodname">factory()</code> afin de charger votre adaptateur.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.factory.example2"></a><p class="title"><b>Exemple 186. Utilisation de la fabrique avec une classe personnalisée</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// Charge automatiquement la classe MyProject_Db_Adapter_Pdo_Mysql
// et l'instantie.
$db = Zend_Db::factory('Pdo_Mysql', array(
    'host'             =&gt; '127.0.0.1',
    'username'         =&gt; 'webuser',
    'password'         =&gt; 'xxxxxxxx',
    'dbname'           =&gt; 'test',
    'adapterNamespace' =&gt; 'MyProject_Db_Adapter'
));
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.factory-config"></a>Utiliser Zend_Config avec la fabrique Zend_Db</h4></div></div></div>
            

            <p>
                Optionnellement, vous pouvez passer un objet de type <a class="link" href="zend.config.html" title="Zend_Config">Zend_Config</a> en tant qu'argument de la méthode
                <code class="methodname">factory()</code>, concernant la configuration.
            </p>

            <p>
                Il est alors nécessaire que l'objet de configuration contienne une propriété
                <code class="code">adapter</code>, qui représente une chaîne de caractères décrivant l'adaptateur
                à utiliser. De plus, l'objet peut aussi contenir une propriété nommée
                <code class="code">params</code>, avec toutes les sous propriétés requises pour la configuration
                de l'adaptateur.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.factory.example1"></a><p class="title"><b>Exemple 187. Utilisation de la fabrique avec un objet de type Zend_Config</b></p>
<div class="example-contents">
                

                <p>
                    Dans l'exemple qui va suivre, l'objet <code class="classname">Zend_Config</code>
                    est crée à partir d'un tableau. Il eut été possible de le créer à partir de
                    fichiers externes, grâce à <a class="link" href="zend.config.adapters.ini.html" title="Zend_Config_Ini">Zend_Config_Ini</a> ou <a class="link" href="zend.config.adapters.xml.html" title="Zend_Config_Xml">Zend_Config_Xml</a>.
                </p>

                <pre class="programlisting">
$config = new Zend_Config(
    array(
        'database' =&gt; array(
            'adapter' =&gt; 'Mysqli',
            'params' =&gt; array(
                'host'     =&gt; '127.0.0.1',
                'dbname'   =&gt; 'test',
                'username' =&gt; 'webuser',
                'password' =&gt; 'secret',
            )
        )
    )
);

$db = Zend_Db::factory($config-&gt;database);
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Le second paramètre de la méthode <code class="methodname">factory()</code> doit être un tableau
                associatif décrivant les paramètres de l'adaptateur à utiliser. Cet argument est
                optionnel, si un objet de type <code class="classname">Zend_Config</code> est utilisé en
                premier paramètre, alors il est supposé contenir les paramètres, et le second
                paramètre de <code class="methodname">factory()</code> est alors ignoré.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.parameters"></a>Paramètres de l'adaptateur (Adapter)</h4></div></div></div>
            

            <p>
                La liste ci dessous explique les différents paramètres acceptés par les
                classes d'adaptateur <code class="classname">Zend_Db</code>.
            </p>

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>host</em></span> : le nom de l'hôte hébergeant le SGBD. Vous
                        pouvez aussi spécifier une adresse IP. Si le SGBD se situe sur la même
                        machine que l'application <acronym class="acronym">PHP</acronym>, "localhost" ou "127.0.0.1" devraient alors
                        être utilisés.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>username </em></span> : nom d'utilisateur du compte de
                        connexion au SGBD.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>password</em></span> : mot de passe de l'utilisateur du
                        compte de connexion au SGBD.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>dbname</em></span> : nom de la base de données située dans le
                        SGBD.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>port</em></span> : Certains SGBDs acceptent que l'on spécifie
                        un port pour d'y connecter. Indiquez le alors ici.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>charset</em></span> : encodage utilisé pour la connexion.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>options</em></span> : Ce paramètre est un tableau associatif
                        d'options génériques à toutes les classes
                        <code class="classname">Zend_Db_Adapter</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>driver_options</em></span> : Ce paramètre est un tableau
                        associatif d'options spécifiques à une extension de SGBD spécifique.
                        Typiquement, il est possible avec ce paramètre de passer des options
                        (attributs) au driver <acronym class="acronym">PDO</acronym>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>adapterNamespace</em></span> : fournit le commencement du nom
                        de la classe d'adaptateur, à utiliser la place de
                        "<code class="classname">Zend_Db_Adapter</code>". Utilisez ceci si vous désirez que
                        <code class="methodname">factory()</code> charge une classe non Zend.
                    </p>
                </li>
</ul></div>

            <div class="example">
<a name="zend.db.adapter.connecting.parameters.example1"></a><p class="title"><b>Exemple 188. Passer l'option de gestion de la casse à la fabrique</b></p>
<div class="example-contents">
                

                <p>
                    Vous pouvez spécifier cette option avec la constante
                    <code class="classname">Zend_Db::CASE_FOLDING</code>. Ceci correspond à l'attribut
                    <code class="constant">ATTR_CASE</code> dans les drivers <acronym class="acronym">PDO</acronym> et IBM DB2, ce qui ajuste la casse
                    des clés dans les jeux de résultats. Les valeurs possibles possibles sont
                    <code class="classname">Zend_Db::CASE_NATURAL</code> (défaut),
                    <code class="classname">Zend_Db::CASE_UPPER</code>, et
                    <code class="classname">Zend_Db::CASE_LOWER</code>.
                </p>

                <pre class="programlisting">
$options = array(
    Zend_Db::CASE_FOLDING =&gt; Zend_Db::CASE_UPPER
);

$params = array(
    'host'           =&gt; '127.0.0.1',
    'username'       =&gt; 'webuser',
    'password'       =&gt; 'xxxxxxxx',
    'dbname'         =&gt; 'test',
    'options'        =&gt; $options
);

$db = Zend_Db::factory('Db2', $params);
</pre>
            </div>
</div>
<br class="example-break">

            <div class="example">
<a name="zend.db.adapter.connecting.parameters.example2"></a><p class="title"><b>Exemple 189. Passer l'option d'auto-échappement à la fabrique</b></p>
<div class="example-contents">
                

                <p>
                    Vous pouvez spécifier cette option avec le paramètre
                    <code class="classname">Zend_Db::AUTO_QUOTE_IDENTIFIERS</code>. Si la valeur passée est
                    <code class="constant">TRUE</code> (par défaut), alors les identifiants tels que les noms de
                    tables, de colonnes, ou encore les alias <acronym class="acronym">SQL</acronym>, sont échappés (délimités) dans la
                    syntaxe de la requête <acronym class="acronym">SQL</acronym> générée par l'objet d'adaptateur. Ceci rend
                    l'utilisation de mots <acronym class="acronym">SQL</acronym> contenant des identifiant spéciaux plus simple. Dans
                    le cas de <code class="constant">FALSE</code>, vous devrez vous-même délimiter ces identifiant
                    avec la méthode <code class="methodname">quoteIdentifier()</code>.
                </p>

                <pre class="programlisting">
$options = array(
    Zend_Db::AUTO_QUOTE_IDENTIFIERS =&gt; false
);

$params = array(
    'host'           =&gt; '127.0.0.1',
    'username'       =&gt; 'webuser',
    'password'       =&gt; 'xxxxxxxx',
    'dbname'         =&gt; 'test',
    'options'        =&gt; $options
);

$db = Zend_Db::factory('Pdo_Mysql', $params);
</pre>
            </div>
</div>
<br class="example-break">

            <div class="example">
<a name="zend.db.adapter.connecting.parameters.example3"></a><p class="title"><b>Exemple 190. Passer des options de driver PDO à la fabrique</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$pdoParams = array(
    PDO::MYSQL_ATTR_USE_BUFFERED_QUERY =&gt; true
);

$params = array(
    'host'           =&gt; '127.0.0.1',
    'username'       =&gt; 'webuser',
    'password'       =&gt; 'xxxxxxxx',
    'dbname'         =&gt; 'test',
    'driver_options' =&gt; $pdoParams
);

$db = Zend_Db::factory('Pdo_Mysql', $params);

echo $db-&gt;getConnection()
        -&gt;getAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY);
</pre>
            </div>
</div>
<br class="example-break">

            <div class="example">
<a name="zend.db.adapter.connecting.parameters.example4"></a><p class="title"><b>Exemple 191. Passer des options de sérialisation à la fabrique</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$options = array(
    Zend_Db::ALLOW_SERIALIZATION =&gt; false
);

$params = array(
    'host'           =&gt; '127.0.0.1',
    'username'       =&gt; 'webuser',
    'password'       =&gt; 'xxxxxxxx',
    'dbname'         =&gt; 'test',
    'options'        =&gt; $options
);

$db = Zend_Db::factory('Pdo_Mysql', $params);
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.connecting.getconnection"></a>Gestion des connexions dites paresseuses</h4></div></div></div>
            

            <p>
                La création d'une instance d'une classe d'adaptateur ne crée pas physiquement
                une connexion au SGBD. L'adaptateur sauvegarde les paramètres et se connectera
                physiquement à la demande, la première fois que vous aurez besoin d'exécuter une
                requête. Ceci permet d'assurer que la création de l'instance elle-même est rapide,
                et ne coûte rien en performances. Vous pouvez donc créer une instance de
                l'adaptateur, même si vous ne savez pas si vous allez l'utiliser. Ainsi, si vos
                paramètres sont incorrects, il faudra attendre la tentative de connexion au SGBD
                pour le vérifier réellement.
            </p>

            <p>
                Si vous voulez forcer l'adaptateur à se connecter au SGBD, utilisez sa méthode
                <code class="methodname">getConnection()</code>. Elle retournera alors un objet représentant la
                connexion, en fonction de l'extension <acronym class="acronym">PHP</acronym> utilisée, ou une exception si la connexion
                n'a pas été réalisée. Par exemple, si votre adaptateur utilise <acronym class="acronym">PDO</acronym>, le retour sera
                un objet <acronym class="acronym">PDO</acronym>. La connexion physique au SGBD est alors réalisée.
            </p>

            <p>
                Afin de vérifier si les paramètres de connexion au SGBD sont corrects,
                surveillez les exceptions envoyées par la méthode
                <code class="methodname">getConnection()</code>.
            </p>

            <p>
                De plus, un adaptateur peut être sérialisé pour être stocké, par exemple, dans
                une variable de session. Ceci peut être utile non seulement pour l'adaptateur
                lui-même, mais aussi pour les autres objets qui l'agrègent, comme un objet
                <code class="classname">Zend_Db_Select</code>. Par défaut, les adaptateurs sont autorisés à
                être sérialisés, si vous ne le voulez pas, vous devez passer l'option
                <code class="classname">Zend_Db::ALLOW_SERIALIZATION=false</code>, regardez l'exemple
                ci-dessus. Afin de respecter le principe de connexions paresseuses, l'adaptateur ne
                se reconnectera pas après la désérialisation. Vous devez appeler vous-même
                <code class="methodname">getConnection()</code>. Vous pouvez permettre à l'adaptateur de se reconnecter
                automatiquement en utilisant l'option d'adaptateur
                <code class="classname">Zend_Db::AUTO_RECONNECT_ON_UNSERIALIZE=true</code>.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.getconnection.example"></a><p class="title"><b>Exemple 192. Gérer les exceptions de connexion</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
try {
    $db = Zend_Db::factory('Pdo_Mysql', $parameters);
    $db-&gt;getConnection();
} catch (Zend_Db_Adapter_Exception $e) {
    // probablement mauvais identifiants,
    // ou alors le SGBD n'est pas joignable
} catch (Zend_Exception $e) {
    // probablement que factory() n'a pas réussi à charger
    // la classe de l'adaptateur demandé
}
</pre>
            </div>
</div>
<br class="example-break">
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.example-database"></a>La base de données d'exemple</h3></div></div></div>
        

        <p>
            Dans cette documentation concernant <code class="classname">Zend_Db</code>, nous utilisons
            un exemple simple de tables pour illustrer nos exemples. Ces tables peuvent servir à
            stocker des informations sur la gestion des bugs dans une application. La base de
            données contient quatre tables :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>accounts</em></span> correspond aux informations sur les
                    utilisateurs qui gèrent les bugs.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>products</em></span> enregistre les produits pour lesquels des
                    bugs vont être relevés.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>bugs</em></span> est la table qui contient les bugs, à savoir
                    leur état actuel, la personne ayant relevé le bug, la personne en charge de le
                    corriger, et la personne chargée de vérifier le correctif.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>bugs_products</em></span> enregistre les relations entre les
                    bugs, et les produits. C'est une relation plusieurs à plusieurs car un même bug
                    peut faire partie de plusieurs produits, et un produit peut évidemment posséder
                    plusieurs bugs.
                </p>
            </li>
</ul></div>

        <p>
            Le pseudo-code <acronym class="acronym">SQL</acronym> suivant représente les tables de notre base de données
            d'exemple. Ces tables sont utilisées aussi pour les tests unitaires automatisés de
            <code class="classname">Zend_Db</code>.
        </p>

        <pre class="programlisting">
CREATE TABLE accounts (
  account_name      VARCHAR(100) NOT NULL PRIMARY KEY
);

CREATE TABLE products (
  product_id        INTEGER NOT NULL PRIMARY KEY,
  product_name      VARCHAR(100)
);

CREATE TABLE bugs (
  bug_id            INTEGER NOT NULL PRIMARY KEY,
  bug_description   VARCHAR(100),
  bug_status        VARCHAR(20),
  reported_by       VARCHAR(100) REFERENCES accounts(account_name),
  assigned_to       VARCHAR(100) REFERENCES accounts(account_name),
  verified_by       VARCHAR(100) REFERENCES accounts(account_name)
);

CREATE TABLE bugs_products (
  bug_id            INTEGER NOT NULL REFERENCES bugs,
  product_id        INTEGER NOT NULL REFERENCES products,
  PRIMARY KEY       (bug_id, product_id)
);
</pre>

        <p>
            Notez aussi que la table <code class="code">bugs</code> contient plusieurs référence (clés
            étrangères) vers la table <code class="code">accounts</code>. Chacune de ces clés peut référencer un
            enregistrement différent de la table <code class="code">accounts</code>, pour un bug donné.
        </p>

        <p>Le diagramme qui suit illustre le modèle physique des données.</p>

        <p>
            <img src="figures/zend.db.adapter.example-database.png" align="middle">
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.select"></a>Lecture de résultats de requête</h3></div></div></div>
        

        <p>
            Cette section décrit des méthodes de la classe d'adaptateur permettant l'obtention
            de résultats suivants une requête SELECT.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchall"></a>Récupérer tous les résultats</h4></div></div></div>
            

            <p>
                Vous pouvez à la fois exécuter une requête SELECT et récupérer tous ses
                résultats en une seule manipulation, grâce à la méthode
                <code class="methodname">fetchAll()</code>.
            </p>

            <p>
                Le premier paramètre de cette méthode est une chaîne représentant la requête
                SELECT à exécuter. Aussi, ce premier paramètre peut être un objet <a class="link" href="zend.db.select.html" title="Zend_Db_Select">Zend_Db_Select</a>, qui sera alors converti en une
                chaîne automatiquement.
            </p>

            <p>
                Le second paramètre de de <code class="methodname">fetchAll()</code> est un tableau de
                substitutions des éventuels jokers présents dans la syntaxe <acronym class="acronym">SQL</acronym>.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchall.example"></a><p class="title"><b>Exemple 193. Utiliser fetchAll()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$sql = 'SELECT * FROM bugs WHERE bug_id = ?';

$result = $db-&gt;fetchAll($sql, 2);
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetch-mode"></a>Changer le mode de récupération (Fetch Mode)</h4></div></div></div>
            

            <p>
                Par défaut, <code class="methodname">fetchAll()</code> retourne un tableau d'enregistrements.
                Chaque enregistrement étant un tableau associatif dont les clés sont les noms des
                colonnes <acronym class="acronym">SQL</acronym> désirées, ou leurs alias.
            </p>

            <p>
                Vous pouvez spécifier un mode de récupération de résultats différent, ceci par
                la méthode <code class="methodname">setFetchMode()</code>. Les modes supportés sont identifiés par des
                constantes :
            </p>

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>Zend_Db::FETCH_ASSOC</em></span> : Retourne un tableau
                        d'enregistrements. Chaque enregistrement étant un tableau associatif dont
                        les clés sont les noms des colonnes <acronym class="acronym">SQL</acronym> désirées, ou leurs alias. Il s'agit
                        du mode par défaut utilisé par les classes Zend_Db_Adapter.
                    </p>

                    <p>
                        Notez que si votre résultat comporte plusieurs colonnes avec le même
                        nom, par exemple lors d'une jointure, il ne peut y avoir qu'un clé avec un
                        nom définit dans le tableau de résultat. Vous devriez toujours utiliser des
                        alias avec le mode FETCH_ASSOC.
                    </p>

                    <p>
                        Les noms des clés des tableaux correspondants aux noms des colonnes
                        <acronym class="acronym">SQL</acronym> telles que retournées par le SGBD, vous pouvez spécifier la casse pour
                        ces noms, grâce à l'option <code class="classname">Zend_Db::CASE_FOLDING</code>.
                        Spécifiez ceci lors de l'instanciation de votre adaptateur. Voyez <a class="xref" href="zend.db.adapter.html#zend.db.adapter.connecting.parameters.example1" title="Exemple 188. Passer l'option de gestion de la casse à la fabrique">Exemple 188, « Passer l'option de gestion de la casse à la fabrique »</a>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>Zend_Db::FETCH_NUM</em></span> : Retourne les enregistrements
                        dans un tableau de tableaux. Les tableaux nichés sont indexés par des
                        entiers correspondants à la position du champ dans la syntaxe <acronym class="acronym">SQL</acronym>
                        SELECT.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>Zend_Db::FETCH_BOTH</em></span> : Retourne les enregistrements
                        dans un tableau de tableaux. Les tableaux nichés sont indexés à la fois
                        numériquement et lexicalement. C'est un mode qui réunit FETCH_ASSOC et
                        FETCH_NUM. Ainsi, vous avez deux fois plus d'enregistrements, chacun d'entre
                        eux étant doublé.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>Zend_Db::FETCH_COLUMN</em></span>: Retourne les
                        enregistrements dans un tableau de valeurs. Les valeurs correspondent à une
                        des colonnes utilisées dans la requête <acronym class="acronym">SQL</acronym> SELECT. Par défaut, il s'agit de
                        la colonne à l'index 0.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <span class="emphasis"><em>Zend_Db::FETCH_OBJ</em></span> : Retourne les enregistrements
                        dans un tableau d'objets. La classe de ces objets par défaut est la classe
                        intégrée à <acronym class="acronym">PHP</acronym> : <code class="code">stdClass</code>. Les colonnes des enregistrements
                        sont représentées par les propriétés publiques des objets.
                    </p>
                </li>
</ul></div>

            <div class="example">
<a name="zend.db.adapter.select.fetch-mode.example"></a><p class="title"><b>Exemple 194. Utiliser setFetchMode()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchAll('SELECT * FROM bugs WHERE bug_id = ?', 2);

// $result est un tableau d'objets
echo $result[0]-&gt;bug_description;
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchassoc"></a>Récupérer un enregistrement comme tableau associatif</h4></div></div></div>
            

            <p>
                La méthode <code class="methodname">fetchAssoc()</code> retourne des enregistrements sous
                forme de tableau de tableaux associatifs, quelque soit la valeur de "fetch mode"
                en utilisant la première colonne comme index.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchassoc.example"></a><p class="title"><b>Exemple 195. Utiliser f<code class="methodname">etchAssoc()</code></b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchAssoc('SELECT bug_id, bug_description, bug_status FROM bugs');

// $result est un tableau de tableaux associatifs
echo $result[2]['bug_description']; // Description du bug #2
echo $result[1]['bug_description']; // Description du bug #1
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchcol"></a>Récupérer une seule colonne d'un enregistrement</h4></div></div></div>
            

            <p>
                La méthode <code class="methodname">fetchCol()</code> retourne les enregistrements dans un
                tableau de valeurs. Les valeurs correspondent à une des colonnes utilisées dans la
                requête <acronym class="acronym">SQL</acronym> SELECT, par défaut : la première. Toute autre colonne sera ignorée. Si
                vous avez besoin de retourner une autre colonne, voyez <a class="xref" href="zend.db.statement.html#zend.db.statement.fetching.fetchcolumn" title="Récupérer une colonne simple depuis un statement exécuté">la section intitulée « Récupérer une colonne simple depuis un statement exécuté »</a>. Cette méthode est indépendante
                de la valeur de "fetch mode".
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchcol.example"></a><p class="title"><b>Exemple 196. Utiliser fetchCol()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$sql = 'SELECT bug_description, bug_id FROM bugs WHERE bug_id = ?';
$result = $db-&gt;fetchCol($sql, 2);

// Contient bug_description ; bug_id n'est pas retourné
echo $result[0];
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchpairs"></a>Récupérer des paires Clé-Valeur d'enregistrements</h4></div></div></div>
            

            <p>
                La méthode <code class="methodname">fetchPairs()</code> retourne un tableau de paires
                clés/valeurs. La clé est le résultat de la première colonne sélectionnée dans la
                requête, la valeur est le résultat de la deuxième colonne sélectionnée dans la
                requête. Il est donc inutile de sélectionner plus de deux colonnes avec cette
                méthode. De même, vous devez sélectionner exactement deux colonnes avec cette
                méthode, pas moins. Si des clés ont des doublons, alors ils seront écrasés.
            </p>

            <p>
                Vous devriez réfléchir votre requête SELECT de manière à ce que la première
                colonne sélectionnée, correspondant à la clé du tableau de résultat, soit unique
                (une clé primaire par exemple). Cette méthode est indépendante de "fetch mode"
                éventuellement précédemment défini.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchpairs.example"></a><p class="title"><b>Exemple 197. Utilisation de fetchPairs()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchPairs('SELECT bug_id, bug_status FROM bugs');

echo $result[2]; // le bug_status correspondant au bug_id numéro 2
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchrow"></a>Récupérer un seul enregistrement complet</h4></div></div></div>
            

            <p>
                La méthode <code class="methodname">fetchRow()</code> retourne un et un seul enregistrement (le
                premier si plusieurs correspondent), en fonction de "fetch mode" que vous aurez
                précédemment défini. Cette méthode ressemble donc à <code class="methodname">fetchAll()</code> si ce
                n'est qu'elle ne retournera jamais plus d'un seul enregistrement. Arrangez vous donc
                pour que votre SELECT possède une clause WHERE sur une clé primaire.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchrow.example"></a><p class="title"><b>Exemple 198. Utiliser fetchRow()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchRow('SELECT * FROM bugs WHERE bug_id = 2');

// Ce résultat sera un objet, car le fetch mode en a décidé ainsi
echo $result-&gt;bug_description;
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.select.fetchone"></a>Récupérer une colonne d'un enregistrement</h4></div></div></div>
            

            <p>
                La méthode <code class="methodname">fetchOne()</code> est une combinaison des méthodes
                <code class="methodname">fetchRow()</code> et <code class="methodname">fetchCol()</code>, ainsi elle ne retourne que la
                première colonne, du premier enregistrement retourné. La valeur de retour est donc
                une chaîne de caractères. Toute requête retournant plusieurs colonnes et/ou
                plusieurs résultats est donc inutile avec cette méthode.
            </p>

            <div class="example">
<a name="zend.db.adapter.select.fetchone.example"></a><p class="title"><b>Exemple 199. Utiliser fetchOne()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$result = $db-&gt;fetchOne('SELECT bug_status FROM bugs WHERE bug_id = 2');

// ceci est une chaine
echo $result;
</pre>
            </div>
</div>
<br class="example-break">
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.write"></a>Effectuer des changements dans la base de données</h3></div></div></div>
        

        <p>
            Il est bien entendu possible d'utiliser la classe d'adaptateur pour effectuer des
            changements dans vos données. Cette section décrit les manières de procéder.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.write.insert"></a>Insérer des données</h4></div></div></div>
            

            <p>
                Vous pouvez ajouter de nouveaux enregistrements dans une table, grâce à la
                méthode <code class="methodname">insert()</code>. Son premier paramètre est une chaîne qui représente
                le nom de la table ciblée, le second paramètre est un tableau associatif liant les
                noms des colonnes de la table, aux valeurs souhaitées.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.insert.example"></a><p class="title"><b>Exemple 200. Insertion dans une table</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$data = array(
    'created_on'      =&gt; '2007-03-22',
    'bug_description' =&gt; 'Something wrong',
    'bug_status'      =&gt; 'NEW'
);

$db-&gt;insert('bugs', $data);
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Les colonnes non citées dans le tableau associatif sont laissées telles
                quelles. Ainsi, si le SGBD possède une valeur DEFAULT pour les colonnes concernées,
                celle-ci sera utilisée, autrement, NULL sera utilisé.
            </p>

            <p>
                Par défaut, les valeurs insérées avec cette méthode sont automatiquement
                échappées. Ceci pour des raisons de sécurité, vous n'avez donc pas besoin de vous
                occuper de ce point là.
            </p>

            <p>
                Si vous avez besoin d'écrire de la syntaxe <acronym class="acronym">SQL</acronym>, comme des mots réservés, des
                noms de fonctions <acronym class="acronym">SQL</acronym>, vous voulez que ceux-ci ne soient pas échappés, et ne soient
                pas traités comme de vulgaires chaînes de caractères, mais plutôt comme des
                expressions. Pour ceci, vous devriez passer ces valeurs dans votre tableau de
                données, en tant qu'objets de type <code class="classname">Zend_Db_Expr</code> au lieu de
                chaînes de caractères banales.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.insert.example2"></a><p class="title"><b>Exemple 201. Insérer des expressions dans une table</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$data = array(
    'created_on'      =&gt; new Zend_Db_Expr('CURDATE()'),
    'bug_description' =&gt; 'Something wrong',
    'bug_status'      =&gt; 'NEW'
);

$db-&gt;insert('bugs', $data);
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.write.lastinsertid"></a>Récupérer une valeur générée</h4></div></div></div>
            

            <p>
                Certains SGBDs supportent les clé primaires auto-incrémentées. Une table qui
                utilise un tel procédé génère la valeur de la clé automatiquement lors d'une
                insertion (INSERT). La valeur de retour de la méthode <code class="methodname">insert()</code>
                <span class="emphasis"><em>n'est pas</em></span> le dernier ID inséré car la table peut ne pas avoir
                de clé auto-incrémentée. La valeur de retour est le nombres d'enregistrements
                affectés (théoriquement 1).
            </p>

            <p>
                Si votre table a été définie avec une clé auto-incrémentée, alors vous pouvez
                appeler la méthode <code class="methodname">lastInsertId()</code> après une opération d'insertion.
                Cette méthode retourne la valeur auto-incrémentée, générée dans le cadre de la
                connexion au SGBD.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.lastinsertid.example-1"></a><p class="title"><b>Exemple 202. Utiliser lastInsertId() pour les clés auto-incrémentées</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;insert('bugs', $data);

// retourne la dernière valeur générée par la clé auto-incrémentée
$id = $db-&gt;lastInsertId();
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Certains SGBD supporte un objet de séquence, qui sert à générer des valeurs
                uniques qui vont servir pour les clé primaires. Pour supporter ce procédé, la
                méthode <code class="methodname">lastInsertId()</code> accepte deux paramètres optionnels (chaînes de
                caractères). Ces paramètres nomment la table et la colonne en supposant que vous
                ayez respecté la convention qui définit que la séquence est nommée en utilisant le
                nom de la table et des colonnes utilisées, avec le suffixe "_seq". Ces conventions
                sont celles de PostgreSQL pour les colonnes de type SERIAL. Par exemple, une table
                "bugs" avec une clé primaire "bug_id" utilisera une séquence nommée
                "bugs_bug_id_seq".
            </p>

            <div class="example">
<a name="zend.db.adapter.write.lastinsertid.example-2"></a><p class="title"><b>Exemple 203. Utiliser lastInsertId() avec une séquence</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;insert('bugs', $data);

// retourne la dernière valeur générée par la séquence 'bugs_bug_id_seq'.
$id = $db-&gt;lastInsertId('bugs', 'bug_id');

// ceci retourne la dernière valeur générée par la séquence 'bugs_seq'.
$id = $db-&gt;lastInsertId('bugs');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Si le nom de votre objet de séquence ne suit pas ces conventions de nommage,
                utilisez alors <code class="methodname">lastSequenceId()</code>. Cette méthode prend un paramètre qui
                nomme la séquence explicitement.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.lastinsertid.example-3"></a><p class="title"><b>Exemple 204. Utilisation de lastSequenceId()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$db-&gt;insert('bugs', $data);

// retourne la dernière valeur générée par la séquence 'bugs_id_gen'.
$id = $db-&gt;lastSequenceId('bugs_id_gen');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Pour les SGBDs ne supportant pas les séquences, comme MariaDB, MySQL, Microsoft <acronym class="acronym">SQL</acronym>
                Server, et SQLite, les arguments passés à la méthode <code class="methodname">lastInsertId()</code>
                sont ignorés. La valeur retournée est la dernière valeur générée pour la dernière
                requête INSERT, quelque soit la table concernée (pour cette connexion). Aussi, pour
                ces SGBDs, la méthode <code class="methodname">lastSequenceId()</code> retournera toujours
                <code class="constant">NULL</code>.
            </p>

            <div class="note"><table border="0" summary='Note: Pourquoi ne pas utiliser "SELECT MAX(id) FROM table"?'>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Pourquoi ne pas utiliser "SELECT MAX(id) FROM table"?</th>
</tr>
<tr><td align="left" valign="top">
                

                <p>
                    Quelques fois, cette requête retourne la valeur la plus récente de clé
                    primaire insérée dans la table en question. Cependant, cette technique n'est pas
                    pertinente dans un environnement où beaucoup de clients insèrent beaucoup de
                    données dans une même table. Il est donc possible qu'un client insère une donnée
                    entre le moment où la dernière insertion est effectuée, et l'appel de MAX(id),
                    aboutissant ainsi à un résultat erroné. Il est très difficile de se rendre
                    compte d'un tel comportement.
                </p>

                <p>
                    Utiliser un mode d'isolation transactionnelle très élevé, comme
                    "repeatable read" peut mitiger plus ou moins les risques, mais certains SGBDs ne
                    supportent pas ce mode de transactions.
                </p>

                <p>
                    De plus, utiliser une requête du type "MAX(id)+1" pour générer une
                    nouvelle valeur de clé primaire n'est pas sécurisé non plus, car deux client
                    peuvent se connecter simultanément et créer des effets indésirables.
                </p>

                <p>
                    Tous les SGBDs fournissent un mécanisme de génération de valeurs uniques,
                    et une méthode pour les récupérer. Ces mécanismes travaillent en dehors du mode
                    transactionnel, et empêchent ainsi deux clients de générer la même valeur, ou de
                    "se marcher dessus".
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.write.update"></a>Mettre à jour des données</h4></div></div></div>
            

            <p>
                Vous pouvez mettre à jour des données dans une table en utilisant la méthode
                <code class="methodname">update()</code> de l'adaptateur. Cette méthode accepte trois arguments :
                le premier est le nom de la table, le deuxième est un tableau faisant correspondre
                les noms des colonnes <acronym class="acronym">SQL</acronym> à leurs valeurs désirées.
            </p>

            <p>
                Les valeurs dans ce tableau sont traitées comme des chaînes. Voyez <a class="xref" href="zend.db.adapter.html#zend.db.adapter.write.insert" title="Insérer des données">la section intitulée « Insérer des données »</a> pour plus d'informations sur la gestion
                des expressions <acronym class="acronym">SQL</acronym> dans ce tableau.
            </p>

            <p>
                Le troisième argument est une chaîne contenant l'expression <acronym class="acronym">SQL</acronym> utilisée comme
                critère pour la mise à jour des données dans la table. Les valeurs et les arguments
                dans ce paramètre ne sont pas échappés pour vous. Vous devez donc vous assurer de
                l'éventuel bon échappement des caractères. Voyez <a class="xref" href="zend.db.adapter.html#zend.db.adapter.quoting" title="Échapper des valeurs ou des identifiants">la section intitulée « Échapper des valeurs ou des identifiants »</a> pour plus d'informations.
            </p>

            <p>
                La valeur de retour de cette méthode est le nombre d'enregistrements affectés
                par l'opération de mise à jour (UPDATE).
            </p>

            <div class="example">
<a name="zend.db.adapter.write.update.example"></a><p class="title"><b>Exemple 205. Mettre à jour des enregistrements</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$data = array(
    'updated_on'      =&gt; '2007-03-23',
    'bug_status'      =&gt; 'FIXED'
);

$n = $db-&gt;update('bugs', $data, 'bug_id = 2');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Si vous oubliez le troisième paramètre, alors tous les enregistrements de la
                table sont mis à jour avec les valeurs spécifiées dans le tableau de données.
            </p>

            <p>
                Si vous spécifiez un tableau de chaîne en tant que troisième paramètre, alors
                ces chaînes sont jointes entre elles avec une opération <code class="constant">AND</code>.
            </p>

            <p>
                Si vous fournissez un tableau de tableaux en tant que troisième argument, les
                valeurs seront automatiquement échappées dans les clés. Elles seront ensuite
                jointes ensemble, séparées par des opérateurs <code class="constant">AND</code>.
            </p>

            <div class="example">
<a name="zend.db.adapter.write.update.example-array"></a><p class="title"><b>Exemple 206. Mettre à jour des enregistrements avec un tableau de données</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$data = array(
    'updated_on'      =&gt; '2007-03-23',
    'bug_status'      =&gt; 'FIXED'
);

$where[] = "reported_by = 'goofy'";
$where[] = "bug_status = 'OPEN'";

$n = $db-&gt;update('bugs', $data, $where);

// la requête SQL executée est :
//  UPDATE "bugs" SET "update_on" = '2007-03-23', "bug_status" = 'FIXED'
//  WHERE ("reported_by" = 'goofy') AND ("bug_status" = 'OPEN')
</pre>
            </div>
</div>
<br class="example-break">

            <div class="example">
<a name="zend.db.adapter.write.update.example-arrayofarrays"></a><p class="title"><b>Exemple 207. UMettre à jour des enregistrements avec un tableau de tableaux</b></p>
<div class="example-contents">
                
                <pre class="programlisting">
$data = array(
    'updated_on'      =&gt; '2007-03-23',
    'bug_status'      =&gt; 'FIXED'
);

$where['reported_by = ?'] = 'goofy';
$where['bug_status = ?']  = 'OPEN';

$n = $db-&gt;update('bugs', $data, $where);

// la requête SQL executée est :
//  UPDATE "bugs" SET "update_on" = '2007-03-23', "bug_status" = 'FIXED'
//  WHERE ("reported_by" = 'goofy') AND ("bug_status" = 'OPEN')
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.write.delete"></a>Supprimer des enregistrements</h4></div></div></div>
            

            <p>
                Il est possible de supprimer des enregistrements dans une table. La méthode
                <code class="methodname">delete()</code> est faite pour cela. Elle accepte deux paramètres, le premier
                est une chaîne désignant la table.
            </p>

            <p>
                Le second paramètre est une chaîne contenant l'expression <acronym class="acronym">SQL</acronym> utilisée comme
                critère pour effacer les enregistrements. Les valeurs de cette expression de sont
                pas échappées automatiquement, vous devez donc vous en occuper le cas échéant. Voyez
                <a class="xref" href="zend.db.adapter.html#zend.db.adapter.quoting" title="Échapper des valeurs ou des identifiants">la section intitulée « Échapper des valeurs ou des identifiants »</a> pour les méthodes concernant
                l'échappement.
            </p>

            <p>
                La valeur retournée par la méthode <code class="methodname">delete()</code> est le nombre
                d'enregistrements affectés (effacés).
            </p>

            <div class="example">
<a name="zend.db.adapter.write.delete.example"></a><p class="title"><b>Exemple 208. Supprimer des enregistrements</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$n = $db-&gt;delete('bugs', 'bug_id = 3');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Si vous ne spécifiez pas le second paramètres, tous les enregistrements de la
                table seront alors supprimés.
            </p>

            <p>
                Si le second paramètre est un tableau de chaînes, alors celles ci seront
                jointe en une expression <acronym class="acronym">SQL</acronym>, séparées par l'opérateur
                <code class="constant">AND</code>.
            </p>

            <p>
                Si vous fournissez un tableau de tableaux en tant que troisième argument, les
                valeurs seront automatiquement échappées dans les clés. Elles seront ensuite
                jointes ensemble, séparées par des opérateurs <code class="constant">AND</code>.
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.quoting"></a>Échapper des valeurs ou des identifiants</h3></div></div></div>
        

        <p>
            Lorsque vous envoyez des requêtes SQL au SGBD, il est souvent nécessaire d'y
            inclure des paramètres dynamiques, PHP. Ceci est risqué car si un des paramètres
            contient certains caractères, comme l'apostrophe ('), alors la requête résultante risque
            d'être mal formée. Par exemple, notez le caractère indésirable dans la requête
            suivante :
            </p>
<pre class="programlisting">
$name = "O'Reilly";
$sql = "SELECT * FROM bugs WHERE reported_by = '$name'";

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O'Reilly'
</pre>
<p>
        </p>

        <p>
            Pire encore est le cas où de telles erreurs <acronym class="acronym">SQL</acronym> peuvent être utilisées
            délibérément par une personne afin de manipuler la logique de votre requête. Si une
            personne peut manipuler un paramètre de votre requête, par exemple via un paramètre <acronym class="acronym">HTTP</acronym>
            ou une autre méthode, alors il peut y avoir une fuite de données, voire même une
            corruption totale de votre base de données. Cette technique très préoccupante de
            violation de la sécurité d'un SGBD, est appelée "injection <acronym class="acronym">SQL</acronym>" (voyez <a class="ulink" href="http://en.wikipedia.org/wiki/SQL_Injection" target="_top">http://en.wikipedia.org/wiki/SQL_Injection</a>).
        </p>

        <p>
            La classe Zend_Db Adapter possède des méthodes adaptées pour vous aider à faire
            face à de telles vulnérabilités. La solution proposée est l'échappement de tels
            caractères (comme la "quote" = ') dans les valeurs <acronym class="acronym">PHP</acronym> avant leur passage dans la chaîne
            de requête. Ceci vous protège de l'insertion malveillante ou involontaires, de
            caractères spéciaux dans les variables <acronym class="acronym">PHP</acronym> faisant partie d'une requête <acronym class="acronym">SQL</acronym>.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.quoting.quote"></a>Utilisation de quote()</h4></div></div></div>
            

            <p>
                La méthode <code class="methodname">quote()</code> accepte un seul paramètre, une chaîne de
                caractère. Elle retourne une chaîne dont les caractères spéciaux ont été échappés
                d'une manière convenable en fonction du SGBD sous-jacent. De plus, la chaîne
                échappée est entourée d'apostrophes ("<code class="code">'</code>").C'est la valeur standard de
                délimitations des chaînes en <acronym class="acronym">SQL</acronym>.
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote.example"></a><p class="title"><b>Exemple 209. Utiliser quote()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$name = $db-&gt;quote("O'Reilly");
echo $name;
// 'O\'Reilly'

$sql = "SELECT * FROM bugs WHERE reported_by = $name";

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O\'Reilly'
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Notez que la valeur de retour contient les apostrophes de délimitation autour
                de la chaîne. Ceci est différent de certaines fonctions qui se contentent juste
                d'échapper les caractères spéciaux, telle que <a class="ulink" href="http://www.php.net/mysqli_real_escape_string" target="_top">mysql_real_escape_string()</a>.
            </p>

            <p>
                Certaines valeurs en revanche n'ont pas besoin d'être délimitées. Certains
                SGBDs n'acceptent pas que les valeurs correspondant à des champs de type entier,
                soient délimitées. Autrement dit, l'exemple suivant est erroné dans certaines
                implémentations de SQL. Nous supposons <code class="code">intColumn</code> ayant un type SQL
                <code class="constant">INTEGER</code> : </p>
<pre class="programlisting">
SELECT * FROM atable WHERE intColumn = '123'
</pre>

            <p>
                Le second paramètre optionnel de <code class="methodname">quote()</code> permet de spécifier un
                type <acronym class="acronym">SQL</acronym>.
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote.example-2"></a><p class="title"><b>Exemple 210. Utiliser quote() avec un type SQL</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$value = '1234';
$sql = 'SELECT * FROM atable WHERE intColumn = '
     . $db-&gt;quote($value, 'INTEGER');
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                De plus, chaque classe Zend_Db_Adapter possèdent des constantes représentant
                les différents type <acronym class="acronym">SQL</acronym> des SGBDs respectifs qu'elles représentent. Ainsi, les
                constantes <code class="classname">Zend_Db::INT_TYPE</code>,
                <code class="classname">Zend_Db::BIGINT_TYPE</code>, et
                <code class="classname">Zend_Db::FLOAT_TYPE</code> peuvent vous permettre d'écrire un code
                portable entre différents SGBDs.
            </p>

            <p>
                Zend_Db_Table fournit les types <acronym class="acronym">SQL</acronym> à <code class="methodname">quote()</code> automatiquement en
                fonction des colonnes utilisées par la table référencée.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.quoting.quote-into"></a>Utilisation de quoteInto()</h4></div></div></div>
            

            <p>
                Une autre manière est d'échapper une expression <acronym class="acronym">SQL</acronym> contenant une variable
                <acronym class="acronym">PHP</acronym>. Vous pouvez utiliser <code class="methodname">quoteInto()</code> pour cela. Cette méthode accepte
                trois arguments. Le premier est la chaîne représentant l'expression <acronym class="acronym">SQL</acronym> dont les
                paramètres variables sont remplacés par un joker(<code class="code">?</code>), et le second
                argument est la variable <acronym class="acronym">PHP</acronym> à utiliser pour le remplacement du joker.
            </p>

            <p>
                Le joker est le même symbole que celui utilisé par beaucoup de SGBDs pour la
                substitution de paramètre dans une requête préparée.<code class="methodname">quoteInto()</code> ne fait
                qu'émuler ce comportement : la méthode ne fait que remplacer le joker par la
                valeur <acronym class="acronym">PHP</acronym>, en lui appliquant la méthode <code class="code">quote</code>. De vrais paramètres de
                requêtes préparées conservent une réelle isolation entre la requête et ses
                paramètres.
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote-into.example"></a><p class="title"><b>Exemple 211. Utiliser quoteInto()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$sql = $db-&gt;quoteInto("SELECT * FROM bugs WHERE reported_by = ?",
                      "O'Reilly");

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O\'Reilly'
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Le troisième paramètre optionnel s'utilise comme avec la méthode
                <code class="code">quote</code>. Il sert à spécifier un type <acronym class="acronym">SQL</acronym>, les types numériques ne sont
                pas délimités.
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote-into.example-2"></a><p class="title"><b>Exemple 212. Utiliser quoteInto() avec un type SQL</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
$sql = $db-&gt;quoteInto("SELECT * FROM bugs WHERE bug_id = ?",
                      '1234',
                      'INTEGER');

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 1234
</pre>
            </div>
</div>
<br class="example-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.quoting.quote-identifier"></a>Utilisation de quoteIdentifier()</h4></div></div></div>
            

            <p>
                Les valeurs ne sont pas les seuls données qui peuvent être dynamiques dans une
                requête <acronym class="acronym">SQL</acronym>,et donc passées par des variables <acronym class="acronym">PHP</acronym>. Les noms des tables, des
                colonnes, ou tout autre identifiant <acronym class="acronym">SQL</acronym> spécial de la requête peuvent aussi être
                dynamiques. En général, les identifiant spéciaux d'une requête ont une syntaxe
                identique à celle des variables <acronym class="acronym">PHP</acronym> : pas d'espaces dans les noms, certains
                autres caractères interdits, la ponctuation est interdite, etc... Aussi, les
                identifiants ne peuvent valoir certaines valeurs de mots réservés : une table
                ne peut s'appeler "FROM". Il se peut donc que vous ayez besoin aussi d'échapper des
                paramètres voués à être substitués à des identifiant dans la requête <acronym class="acronym">SQL</acronym>, et non
                plus à des valeurs.
            </p>

            <p>
                Le langage <acronym class="acronym">SQL</acronym> possède une caractéristique appelée <span class="emphasis"><em>identifiant
                délimités</em></span>. Si vous entourez un identifiant <acronym class="acronym">SQL</acronym> dans un type spécial de
                délimiteurs, alors vous pouvez écrire des requêtes qui auraient été invalides
                autrement. Ainsi, vous pouvez inclure des espaces, de la ponctuation ou des
                caractères internationaux dans vos identifiant, et aussi utiliser des mots
                réservés.
            </p>

            <p>
                La méthode <code class="methodname">quoteIdentifier()</code> fonctionne comme
                <code class="methodname">quote()</code>, mais elle utilise un caractère de délimitation spécial, en
                fonction du SGBD sous-jacent. Par exemple, le standard <acronym class="acronym">SQL</acronym> spécifie des doubles
                quotes (<code class="code">"</code>) et beaucoup de SGBDs utilisent ceci. MySQL utilise les
                apostrophes inverses (back-quotes) (<code class="code">`</code>) par défaut. Les caractères
                spéciaux sont aussi échappés.
            </p>

            <div class="example">
<a name="zend.db.adapter.quoting.quote-identifier.example"></a><p class="title"><b>Exemple 213. Utiliser quoteIdentifier()</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// nous possédons une table ayant un nom correspondant
// à un mot reservé en SQL
$tableName = $db-&gt;quoteIdentifier("order");

$sql = "SELECT * FROM $tableName";

echo $sql
// SELECT * FROM "order"
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Les identifiant <acronym class="acronym">SQL</acronym> délimités sont sensibles à la casse. Vous devriez toujours
                utiliser la casse telle qu'elle est utilisée dans votre base de données (nom des
                tables, des colonnes ...).
            </p>

            <p>
                Dans les cas où le <acronym class="acronym">SQL</acronym> est généré à l'intérieur des classes
                <code class="classname">Zend_Db</code>, alors les identifiant <acronym class="acronym">SQL</acronym> seront automatiquement
                échappés. Vous pouvez changer ce comportement avec l'option
                <code class="classname">Zend_Db::AUTO_QUOTE_IDENTIFIERS</code>.Spécifiez la lors de
                l'instanciation de l'adaptateur. Voyez <a class="xref" href="zend.db.adapter.html#zend.db.adapter.connecting.parameters.example2" title="Exemple 189. Passer l'option d'auto-échappement à la fabrique">Exemple 189, « Passer l'option d'auto-échappement à la fabrique »</a>.
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.transactions"></a>Gérer les transactions dans une base de données</h3></div></div></div>
        

        <p>
            Les bases de données définissent les transactions comme étant des unités logiques
            de travail qui peuvent êtres validées ("commit") ou annulées ("rollback") en tant qu'une
            seule opération, même sur de multiples tables. Toutes les requêtes aux bases de données
            sont considérées comme faisant partie d'une transaction, même si le driver de base de
            données fait ceci implicitement. Ceci s'appelle le mode
            <span class="emphasis"><em>auto-commit</em></span>, dans lequel le driver de base de données créer une
            transaction pour chaque requête exécutée et la valide. Par défaut toutes les classes
            <code class="classname">Zend_Db_Adapter</code> fonctionnent en mode auto-commit.
        </p>

        <p>
            Vous pouvez manuellement spécifier lorsque vous voulez démarrer une transaction.
            Vous contrôler ainsi combien de requêtes doivent y être exécutées, et valider ou annuler
            ce groupe de requêtes. Utilisez <code class="methodname">beginTransaction()</code> pour démarrer une
            transaction. Toutes les requêtes suivantes seront alors exécutées dans cette transaction
            avant que vous ne l'annuliez, ou validiez.
        </p>

        <p>
            Pour terminer une transaction, utilisez les méthodes <code class="methodname">commit()</code> ou
            <code class="methodname">rollBack()</code>. <code class="methodname">commit()</code> validera et appliquera les changements de
            la transaction au SGBD, ils deviendront alors visibles dans les autres
            transactions.
        </p>

        <p>
            <code class="methodname">rollBack()</code> fait le contraire : elle annule les changements qu'ont
            générés les requêtes dans la transaction. L'annulation n'a aucun effet sur les
            changements qui ont été opérés par d'autres transactions parallèles.
        </p>

        <p>
            Après qu'une transaction soit terminées, <code class="classname">Zend_Db_Adapter</code>
            retourne en mode auto-commit jusqu'à un nouvel appel à
            <code class="methodname">beginTransaction()</code>.
        </p>

        <div class="example">
<a name="zend.db.adapter.transactions.example"></a><p class="title"><b>Exemple 214. Manipuler les transactions pour assurer l'intégrité de la logique</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
// Démarre explicitement une transaction.
$db-&gt;beginTransaction();

try {
    // Essaye d'executer une ou plusieurs requêtes :
    $db-&gt;query(...);
    $db-&gt;query(...);
    $db-&gt;query(...);

    // Si toutes ont réussi, valide les changements en une seule passe.
    $db-&gt;commit();

} catch (Exception $e) {
    // Si une des requête s'est mal déroulée, alors nous voulons
    // annuler les changements de toutes les requêtes faisant partie
    // de la transaction, même celles qui se sont bien déroulées.
    // Tous les changements sont annulés d'un seul coup.
    $db-&gt;rollBack();
    echo $e-&gt;getMessage();
}
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.list-describe"></a>Lister et décrire les tables</h3></div></div></div>
        

        <p>
            La méthode <code class="methodname">listTables()</code> retourne un tableau de chaînes décrivant les
            tables de la base de données courante.
        </p>

        <p>
            La méthode <code class="methodname">describeTable()</code> retourne un tableau associatif de
            métadonnées sur une table. Spécifiez en le nom en paramètre. Le second paramètre est
            optionnel et définit la base de données à utiliser, comme par exemple si aucune n'a été
            sélectionnée précédemment.
        </p>

        <p>
            Les clés de ce tableau représentent les noms des colonnes, les valeurs sont un
            tableau avec les clés suivantes :
        </p>

        <div class="table">
<a name="zend.db.adapter.list-describe.metadata"></a><p class="title"><b>Tableau 63. Champs de métadonnées retournés par describeTable()</b></p>
<div class="table-contents">
            

            <table class="table" summary="Champs de métadonnées retournés par describeTable()" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">clé</th>
<th align="left">type</th>
<th align="left">description</th>
</tr></thead>
<tbody>
<tr>
<td align="left"><code class="constant">SCHEMA_NAME</code></td>
<td align="left">(chaîne)</td>
<td align="left">Nom de la base de données dans laquelle la table existe.</td>
</tr>
<tr>
<td align="left"><code class="constant">TABLE_NAME</code></td>
<td align="left">(chaîne)</td>
<td align="left">Nom de la table dans laquelle la colonne existe.</td>
</tr>
<tr>
<td align="left"><code class="constant">COLUMN_NAME</code></td>
<td align="left">(chaîne)</td>
<td align="left">Nom de la colonne.</td>
</tr>
<tr>
<td align="left"><code class="constant">COLUMN_POSITION</code></td>
<td align="left">(entier)</td>
<td align="left">Position de la colonne dans la table.</td>
</tr>
<tr>
<td align="left"><code class="constant">DATA_TYPE</code></td>
<td align="left">(chaîne)</td>
<td align="left">Nom du type de données tel que renvoyé par le <acronym class="acronym">SGBD</acronym>.</td>
</tr>
<tr>
<td align="left"><code class="constant">DEFAULT</code></td>
<td align="left">(chaîne)</td>
<td align="left">Valeur par défaut de la colonne, si une existe.</td>
</tr>
<tr>
<td align="left"><code class="constant">NULLABLE</code></td>
<td align="left">(booléen)</td>
<td align="left">
<code class="constant">TRUE</code> si la colonne accepte la valeur <acronym class="acronym">SQL</acronym>
                        '<code class="constant">NULL</code>', <code class="constant">FALSE</code> sinon.</td>
</tr>
<tr>
<td align="left"><code class="constant">LENGTH</code></td>
<td align="left">(entier)</td>
<td align="left">Longueur ou taille de la colonne telle que reportée par le
                        <acronym class="acronym">SGBD</acronym>.</td>
</tr>
<tr>
<td align="left"><code class="constant">SCALE</code></td>
<td align="left">(entier)</td>
<td align="left">Échelle du type <acronym class="acronym">SQL</acronym> <code class="constant">NUMERIC</code> ou <code class="constant">DECIMAL</code>.</td>
</tr>
<tr>
<td align="left"><code class="constant">PRECISION</code></td>
<td align="left">(entier)</td>
<td align="left">Précision du type <acronym class="acronym">SQL</acronym> <code class="constant">NUMERIC</code> ou <code class="constant">DECIMAL</code>.</td>
</tr>
<tr>
<td align="left"><code class="constant">UNSIGNED</code></td>
<td align="left">(booléen)</td>
<td align="left">
<code class="constant">TRUE</code> si le type est un entier non signé, défini par
                        <code class="constant">UNSIGNED</code>.</td>
</tr>
<tr>
<td align="left"><code class="constant">PRIMARY</code></td>
<td align="left">(booléen)</td>
<td align="left">
<code class="constant">TRUE</code> si la colonne fait partie d'une clé
                        primaire.</td>
</tr>
<tr>
<td align="left"><code class="constant">PRIMARY_POSITION</code></td>
<td align="left">(entier)</td>
<td align="left">Position de la colonne dans la clé primaire.</td>
</tr>
<tr>
<td align="left"><code class="constant">IDENTITY</code></td>
<td align="left">(booléen)</td>
<td align="left">
<code class="constant">TRUE</code> si la colonne utilise une valeur
                        auto-générée.</td>
</tr>
</tbody>
</table>
        </div>
</div>
<br class="table-break">

        <div class="note"><table border="0" summary='Note: A quoi correspond le champs de métadonnées "IDENTITY" en fonction du SGBD
            ?'>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">A quoi correspond le champs de métadonnées "IDENTITY" en fonction du SGBD
            ?</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Le champs de métadonnées "IDENTITY" a été choisi en tant que terme idiomatique
                pour représenter une relation de substitution de clés. Ce champ est généralement
                connu par les valeurs suivantes :
            </p>

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p><code class="constant">IDENTITY</code> - DB2, MSSQL</p>
                </li>
<li class="listitem">
                    <p><code class="constant">AUTO_INCREMENT</code> - MySQL / MariaDB</p>
                </li>
<li class="listitem">
                    <p><code class="constant">SERIAL</code> - PostgreSQL</p>
                </li>
<li class="listitem">
                    <p><code class="constant">SEQUENCE</code> - Oracle</p>
                </li>
</ul></div>
        </td></tr>
</table></div>

        <p>
            Si aucune table ne correspond à votre demande, alors <code class="methodname">describeTable()</code>
            retourne un tableau vide.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.closing"></a>Fermer une connexion</h3></div></div></div>
        

        <p>
            Normalement, il n'est pas nécessaire de fermer explicitement sa connexion. <acronym class="acronym">PHP</acronym>
            nettoie automatiquement les ressources laissées ouvertes en fin de traitement. Les
            extensions des SGBDs ferment alors les connexions respectives pour les ressources
            détruites par <acronym class="acronym">PHP</acronym>.
        </p>

        <p>
            Cependant, il se peut que vous trouviez utile de fermer la connexion manuellement.
            Vous pouvez alors utiliser la méthode de l'adaptateur <code class="methodname">closeConnection()</code>
            afin de fermer explicitement la connexion vers le SGBD.
        </p>

        <p>
            A partir de la version 1.7.2, vous pouvez vérifier si vous êtes actuellement
            connecté au serveur SGBD grâce à la méthode <code class="methodname">isConnected()</code>. Ceci correspond
            à une ressource de connexion qui a été initiée et qui n'est pas close. Cette fonction ne
            permet pas actuellement de tester la fermeture de la connexion au niveau du SGBD par
            exemple. Cette fonction est utilisée en interne pour fermer la connexion. Elle vous
            permet entre autres de fermer plusieurs fois une connexion sans erreurs. C'était déjà le
            cas avant la version 1.7.2 pour les adaptateurs de type <acronym class="acronym">PDO</acronym> mais pas pour les
            autres.
        </p>

        <div class="example">
<a name="zend.db.adapter.closing.example"></a><p class="title"><b>Exemple 215. Fermer une connexion à un SGBD</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$db-&gt;closeConnection();
</pre>
        </div>
</div>
<br class="example-break">

        <div class="note"><table border="0" summary="Note: Zend_Db supporte-t-il les connexions persistantes ?">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Zend_Db supporte-t-il les connexions persistantes ?</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Oui, la persistance est supportée grace à l'addition de l'option
                <code class="code">persistent</code> quand il est à une valeur true dans la configuration
                (pas celle du driver) d'un adaptateur de <code class="classname">Zend_Db</code>.
            </p>

            <div class="example">
<a name="zend.db.adapter.connecting.persistence.example"></a><p class="title"><b>Exemple 216. Utiliser l'option de persistance avec l'adaptateur Oracle</b></p>
<div class="example-contents">
                
                <pre class="programlisting">
$db = Zend_Db::factory('Oracle', array(
    'host'       =&gt; '127.0.0.1',
    'username'   =&gt; 'webuser',
    'password'   =&gt; 'xxxxxxxx',
    'dbname'     =&gt; 'test',
    'persistent' =&gt; true
));
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Notez cependant qu'utiliser des connexions persistantes peut mener à un trop grand
                nombre de connexions en attente (idle), ce qui causera plus de problème que cela
                n'est sensé en résoudre.
            </p>

            <p>
                Les connexions aux bases de données possède un état. Dans cet état sont
                mémorisés des objets propres au SGBD. Par exemples des verrous, des variables
                utilisateur, des tables temporaires, des informations sur les requêtes récentes, les
                derniers enregistrements affectés, les dernières valeurs auto-générées, etc. Avec
                des connexions persistantes, il se peut que vous accédiez à des données ne faisant
                pas partie de votre session de travail avec le SGBD, ce qui peut s'avérer
                dangereux.
            </p>

            <p>
                Actuellement, seuls les adpatateurs Oracle, DB2 et <acronym class="acronym">PDO</acronym> (si spécifiés par <acronym class="acronym">PHP</acronym>)
                supportent la persistance avec Zend_Db.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.other-statements"></a>Exécuter des requêtes sur le driver directement</h3></div></div></div>
        

        <p>
            Il peut y avoir des cas où vous souhaitez accéder directement à la connexion 'bas
            niveau', sous <code class="classname">Zend_Db_Adapter</code>.
        </p>

        <p>
            Par exemple, toute requête effectuée par <code class="classname">Zend_Db</code> est
            préparée, et exécutée. Cependant, certaines caractéristiques des bases de données ne
            sont pas compatibles avec les requêtes préparées. Par exemple, des requêtes du type
            CREATE ou ALTER ne peuvent pas être préparées sous MySQL. De même, les requêtes
            préparées ne bénéficient pas du <a class="ulink" href="http://dev.mysql.com/doc/refman/5.1/en/query-cache-how.html" target="_top"> cache de
            requêtes</a>, avant MySQL 5.1.17.
        </p>

        <p>
            La plupart des extensions <acronym class="acronym">PHP</acronym> pour les bases de données proposent une méthode
            permettant d'envoyer une requête directe, sans préparation. Par exemple, <acronym class="acronym">PDO</acronym> propose
            pour ceci la méthode <code class="methodname">exec()</code>. Vous pouvez récupérer l'objet de connexion
            "bas niveau" grâce à la méthode de l'adaptateur <code class="methodname">getConnection()</code>.
        </p>

        <div class="example">
<a name="zend.db.adapter.other-statements.example"></a><p class="title"><b>Exemple 217. Envoyer une requête directe dans un adaptateur PDO</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$result = $db-&gt;getConnection()-&gt;exec('DROP TABLE bugs');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            De la même manière, vous pouvez accéder à toutes les propriétés ou méthodes de
            l'objet "bas niveau", utilisé par <code class="classname">Zend_Db</code>. Attention toutefois en
            utilisant ce procédé, vous risquez de rendre votre application dépendante du SGBD
            qu'elle utilise, en manipulant des méthodes propres à l'extension utilisée.
        </p>

        <p>
            Dans de futures versions de <code class="classname">Zend_Db</code>, il sera possible
            d'ajouter des méthodes pour des fonctionnalités communes aux extensions de bases de
            données de <acronym class="acronym">PHP</acronym>. Ceci ne rompra pas la compatibilité.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.server-version"></a>Récupérer la version du serveur SGBD</h3></div></div></div>
        

        <p>
            A partir de la version 1.7.2, vous pouvez récupérer la version du serveur avec le
            style de syntaxe <acronym class="acronym">PHP</acronym> ce qui permet d'utiliser <code class="methodname">version_compare()</code>. Si cette
            information n'est pas disponible, vous recevrez un <code class="constant">NULL</code>.
        </p>

        <div class="example">
<a name="zend.db.adapter.server-version.example"></a><p class="title"><b>Exemple 218. Vérifier la version du serveur avant de lancer une requête</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$version = $db-&gt;getServerVersion();
if (!is_null($version)) {
    if (version_compare($version, '5.0.0', '&gt;=')) {
        // faire quelquechose
    } else {
        // faire autre chose
    }
} else {
    // impossible de lire la version du serveur
}
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.adapter.adapter-notes"></a>Notes sur des adaptateur spécifiques</h3></div></div></div>
        

        <p>
            Cette section liste des différences entre les adaptateurs, que vous devriez
            considérer.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.ibm-db2"></a>IBM DB2</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>Passez le paramètre 'Db2' à la méthode <code class="methodname">factory()</code>.</p>
                </li>
<li class="listitem">
                    <p>Cet adaptateur utilise l'extension <acronym class="acronym">PHP</acronym> ibm_db2.</p>
                </li>
<li class="listitem">
                    <p>
                        IBM DB2 supporte les séquences et les clés auto-incrémentées. Les
                        arguments de <code class="methodname">lastInsertId()</code> sont donc optionnels. Si vous ne
                        passez pas de paramètres, alors l'adaptateur retourne la dernière valeur de
                        clé auto- incrémentée. Sinon, il retourne la dernière valeur de la séquence
                        passée en paramètre, en se référant à la convention
                        '<span class="emphasis"><em>table</em></span>_<span class="emphasis"><em>colonne</em></span>_seq'.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.mysqli"></a>MySQLi</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Passez le paramètre 'Mysqli' à la méthode
                        <code class="methodname">factory()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>Cet adaptateur utilise l'extension <acronym class="acronym">PHP</acronym> mysqli.</p>
                </li>
<li class="listitem">
                    <p>
                        MySQL et MariaDB ne supportent pas les séquences, donc <code class="methodname">lastInsertId()</code>
                        ignore tout paramètre qu'on lui passe. Elle retourne toujours la valeur de
                        la dernière clé auto-incrémentée. <code class="methodname">lastSequenceId()</code>, elle,
                        retourne toujours <code class="constant">NULL</code>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.oracle"></a>Oracle</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Passez le paramètre 'Oracle' à la méthode
                        <code class="methodname">factory()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>Cet adaptateur utilise l'extension <acronym class="acronym">PHP</acronym> oci8.</p>
                </li>
<li class="listitem">
                    <p>
                        Oracle ne supporte pas les clé auto-incrémentées, donc vous devriez
                        spécifier un paramètre de séquence à <code class="methodname">lastInsertId()</code> ou
                        <code class="methodname">lastSequenceId()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        L'extension Oracle ne supporte pas les paramètres positionnés (?).
                        Vous devez utiliser des paramètres nommés (:name).
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Actuellement l'option <code class="classname">Zend_Db::CASE_FOLDING</code>
                        n'est pas supportée par l'adaptateur Oracle. Pour l'utiliser, vous devez
                        utiliser l'adaptateur basé sur <acronym class="acronym">PDO</acronym> et OCI.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Par défaut les champs LOB ("Large Objet Binaire") sont retournés sous
                        la forme d'objets OCI-Lob. Vous pouvez les récupérer sous forme de chaînes
                        pour toutes les requêtes en utilisant l'option de driver
                        <code class="code">'lob_as_string'</code> ou pour une requête en particulier en utilisant
                        la méthode <code class="methodname">setLobAsString(boolean)</code> de l'adaptateur ou de
                        l'objet statement.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.sqlsrv"></a>Microsoft SQL Server</h4></div></div></div>
            
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Specify this Adapter to the <code class="methodname">factory()</code> method with
                        the name 'Sqlsrv'.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        This Adapter uses the <acronym class="acronym">PHP</acronym> extension sqlsrv
                    </p>
                </li>
<li class="listitem">
                     <p>
                        Only Microsoft <acronym class="acronym">SQL</acronym> Server 2005 or greater is supported.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Microsoft <acronym class="acronym">SQL</acronym> Server does not support sequences, so
                        <code class="methodname">lastInsertId()</code> ignores primary key argument and
                        returns the last value generated for an auto-increment key if a table name
                        is specified or a last insert query returned id. The
                        <code class="methodname">lastSequenceId()</code> method returns
                        <code class="constant">NULL</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        <code class="classname">Zend_Db_Adapter_Sqlsrv</code> sets
                        <code class="constant">QUOTED_IDENTIFIER ON</code> immediately after connecting to
                        a <acronym class="acronym">SQL</acronym> Server database. This makes the driver use the
                        standard <acronym class="acronym">SQL</acronym> identifier delimiter symbol
                        (<span class="emphasis"><em>"</em></span>) instead of the proprietary square-brackets
                        syntax <acronym class="acronym">SQL</acronym> Server uses for delimiting identifiers.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        You can specify <span class="property">driver_options</span> as a key in the options
                        array. The value can be a anything from here <a class="ulink" href="http://msdn.microsoft.com/en-us/library/cc296161(SQL.90).aspx" target="_top">http://msdn.microsoft.com/en-us/library/cc296161(SQL.90).aspx</a>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        You can use <code class="methodname">setTransactionIsolationLevel()</code> to set
                        isolation level for current connection. The value can be
                        <code class="constant">SQLSRV_TXN_READ_UNCOMMITTED</code>,
                        <code class="constant">SQLSRV_TXN_READ_COMMITTED</code>,
                        <code class="constant">SQLSRV_TXN_REPEATABLE_READ</code>,
                        <code class="constant">SQLSRV_TXN_SNAPSHOT</code> or
                        <code class="constant">SQLSRV_TXN_SERIALIZABLE</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        As of Zend Framework 1.9, the minimal supported build of the
                        <acronym class="acronym">PHP</acronym> <acronym class="acronym">SQL</acronym> Server extension from
                        Microsoft is 1.0.1924.0. and the <acronym class="acronym">MSSQL</acronym> Server Native
                        Client version 9.00.3042.00.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-ibm"></a>PDO pour IBM DB2 et Informix Dynamic Server (IDS)</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Passez le paramètre 'Pdo_Ibm' à la méthode
                        <code class="methodname">factory()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>Cet adaptateur utilise les extensions <acronym class="acronym">PHP</acronym> pdo et pdo_ibm.</p>
                </li>
<li class="listitem">
                    <p>
                        Vous devez possédez l'extension PDO_IBM en version 1.2.2 minimum. Si
                        ce n'est pas le cas, vous devrez la mettre à jour via <acronym class="acronym">PECL</acronym>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-mssql"></a>PDO Microsoft SQL Server</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Passez le paramètre 'Pdo_Mssql' à la méthode
                        <code class="methodname">factory()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>Cet adaptateur utilise les extensions <acronym class="acronym">PHP</acronym> pdo et pdo_dblib.</p>
                </li>
<li class="listitem">
                    <p>
                        Microsoft <acronym class="acronym">SQL</acronym> Server ne supporte pas les séquences, ainsi
                        <code class="methodname">lastInsertId()</code> ignore les paramètres qu'on lui passe et
                        retourne toujours la valeur de la dernière clé auto-incrémentée.
                        <code class="methodname">lastSequenceId()</code> retourne toujours <code class="constant">NULL</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Si vous travaillez avec des chaînes Unicode avec un encodage autre que
                        UCS-2 (comme UTF-8), vous devrez peut-être réaliser une conversion dans
                        votre code d'application ou stocker les données dans un champs binaire.
                        Reportez vous à la <a class="ulink" href="http://support.microsoft.com/kb/232580" target="_top"> base
                        de connaissance Microsoft</a> pour plus d'informations.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Zend_Db_Adapter_Pdo_Mssql met <code class="constant">QUOTED_IDENTIFIER</code> à ON dès
                        que la connexion a été effectuée. Le driver utilise donc le délimiteur
                        d'identifiant <acronym class="acronym">SQL</acronym> <code class="code">"</code> au lieu de son délimiteur habituel.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Vous pouvez spécifier la clé <code class="code">pdoType</code> dans le tableau
                        d'options de construction de l'adaptateur. La valeur peut être "mssql"
                        (défaut), "dblib", "freetds", ou "sybase". Cette option affecte la syntaxe
                        du préfixe DSN que l'adaptateur utilisera. "freetds" et "sybase" impliquent
                        un préfixe "sybase:", qui est utilisé par les librairies <a class="ulink" href="http://www.freetds.org/" target="_top">FreeTDS</a>.Voyez aussi <a class="ulink" href="http://www.php.net/manual/en/ref.pdo-dblib.connection.php" target="_top">
                        http://www.php.net/manual/en/ref.pdo-dblib.connection.php</a> pour plus
                        d'informations sur les DSN pour ce driver.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-mysql"></a>PDO MySQL</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Passez le paramètre 'Pdo_Mysql' à la méthode
                        <code class="methodname">factory()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>Cet adaptateur utilise les extensions <acronym class="acronym">PHP</acronym> pdo et pdo_mysql.</p>
                </li>
<li class="listitem">
                    <p>
                        MySQL et MariaDB ne supportent pas les séquences, ainsi <code class="methodname">lastInsertId()</code>
                        ignore les paramètres qu'on lui passe et retourne toujours la valeur de la
                        dernière clé auto-incrémentée. <code class="methodname">lastSequenceId()</code> retourne
                        toujours <code class="constant">NULL</code>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-oci"></a>PDO Oracle</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Passez le paramètre 'Pdo_Oci' à la méthode
                        <code class="methodname">factory()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>Cet adaptateur utilise les extensions <acronym class="acronym">PHP</acronym> pdo et pdo_oci.</p>
                </li>
<li class="listitem">
                    <p>
                        Oracle ne supporte pas les clé auto-incrémentées, donc vous devriez
                        spécifier un paramètre de séquence à <code class="methodname">lastInsertId()</code> ou
                        <code class="methodname">lastSequenceId()</code>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-pgsql"></a>PDO PostgreSQL</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Passez le paramètre 'PDO_Pgsql' à la méthode
                        <code class="methodname">factory()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>Cet adaptateur utilise les extensions <acronym class="acronym">PHP</acronym> pdo et pdo_pgsql.</p>
                </li>
<li class="listitem">
                    <p>
                        PostgreSQL supporte les séquences et les clés auto-incrémentées. Les
                        arguments de <code class="methodname">lastInsertId()</code> sont donc optionnels. Si vous ne
                        passez pas de paramètres, alors l'adaptateur retourne la dernière valeur de
                        clé auto- incrémentée. Sinon, il retourne la dernière valeur de la séquence
                        passée en paramètre, en se référant à la convention
                        '<span class="emphasis"><em>table</em></span>_<span class="emphasis"><em>colonne</em></span>_seq'.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.pdo-sqlite"></a>PDO SQLite</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>
                        Passez le paramètre 'PDO_Sqlite' à la méthode
                        <code class="methodname">factory()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>Cet adaptateur utilise les extensions <acronym class="acronym">PHP</acronym> pdo et pdo_sqlite.</p>
                </li>
<li class="listitem">
                    <p>
                        SQLite ne supporte pas les séquences, ainsi
                        <code class="methodname">lastInsertId()</code> ignore les paramètres qu'on lui passe et
                        retourne toujours la valeur de la dernière clé auto-incrémentée.
                        <code class="methodname">lastSequenceId()</code> retourne toujours <code class="constant">NULL</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Pour vous connecter à une base de données SQLite2, spécifiez le
                        paramètre <code class="code">'sqlite2'=&gt;true</code> dans le tableau d'options passé à
                        l'adaptateur, lors de la création de l'instance de Pdo_Sqlite
                        Adapter.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Pour vous connecter à une base de données SQLite en mémoire, spécifiez
                        le paramètre <code class="code">'dsnprefix'=&gt;':memory:'</code> dans le tableau
                        d'options passé à l'adaptateur, lors de la création de l'instance de
                        Pdo_Sqlite Adapter.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Les anciennes versions du driver SQLite pour <acronym class="acronym">PHP</acronym> ne semblent pas
                        supporter les commandes PRAGMA nécessaires pour s'assurer que les colonnes
                        ayant un nom court soient utilisées dans les résultats. Si vous avez des
                        problèmes, tels que vos enregistrements sont retournés avec une forme
                        "nomtable.nomcolonne" lors de vos jointures, vous devriez alors mettre à
                        jour votre version de <acronym class="acronym">PHP</acronym>.
                    </p>
                </li>
</ul></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.adapter.adapter-notes.firebird"></a>Firebird (Interbase)</h4></div></div></div>
            

            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                    <p>Cet adaptateur utilise l'extension <acronym class="acronym">PHP</acronym> php_interbase.</p>
                </li>
<li class="listitem">
                    <p>
                        Firebird (Interbase) ne supporte pas les clé auto-incrémentées, donc
                        vous devez spécifier un paramètre de séquence à <code class="methodname">lastInsertId()</code>
                        ou <code class="methodname">lastSequenceId()</code>.
                    </p>
                </li>
<li class="listitem">
                    <p>
                        Pour l'instant l'option <code class="classname">Zend_Db::CASE_FOLDING</code>
                        n'est pas supportée par l'adaptateur Firebird (Interbase). Tout identificateur
                        non échappé sera automatiquement retourné en majuscules.
                    </p>
                </li>
<li class="listitem">
                    <p>Le nom de l'adaptateur est ZendX_Db_Adapter_Firebird.</p>
                    <p>
                        Rappelez vous qu'il est nécessaire d'utiliser le paramètre
                        'adapterNamespace' avec la valeur ZendX_Db_Adapter.
                    </p>
                    <p>
                        Nous recommandons de mettre à jour gds32.dll (ou l'équivalent linux)
                        embarqué avec <acronym class="acronym">PHP</acronym>, à la même version que celle du serveur. Pour Firebird
                        l'équivalent à <code class="filename">gds32.dll</code> est
                        <code class="filename">fbclient.dll</code>.
                    </p>
                    <p>
                        Par défaut tous les identifiants (nomde tables, de cahmps) sont retournés en
                        majuscules.
                    </p>
                </li>
</ul></div>
        </div>
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.db.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.db.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.db.statement.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Zend_Db </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Zend_Db_Statement</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
