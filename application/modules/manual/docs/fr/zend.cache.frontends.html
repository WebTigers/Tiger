<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Les frontends Zend_Cache</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.cache.html" title="Zend_Cache">
<link rel="prev" href="zend.cache.theory.html" title="Aspect théorique">
<link rel="next" href="zend.cache.backends.html" title="Les backends Zend_Cache">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Les frontends Zend_Cache</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.cache.theory.html">Précédent</a> </td>
<th width="60%" align="center">Zend_Cache</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.cache.backends.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.cache.frontends"></a>Les frontends Zend_Cache</h2></div></div></div>
    

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.core"></a>Zend_Cache_Core</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.core.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Core</code> est un frontend spécial parce qu'il est le
                coeur du module. C'est le frontend de cache générique qui est étendu par les autres
                classes.
            </p>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    Tous les frontends héritent de <code class="classname">Zend_Cache_Core</code> ainsi ses
                    méthodes et options (décrites ci-dessous) seront aussi disponibles dans les
                    autres frontends, cependant ils ne sont pas documentés ici.
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.core.options"></a>Options disponibles</h4></div></div></div>
            

            <p>
                Ces options sont passées à la méthode de fabrique comme montrées dans les
                exemples précédents.
            </p>

            <div class="table">
<a name="zend.cache.frontends.core.options.table"></a><p class="title"><b>Tableau 20. Options du frontend Core</b></p>
<div class="table-contents">
                

                <table class="table" summary="Options du frontend Core" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Type de données</th>
<th>Valeur par défaut</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>caching</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">TRUE</code></td>
<td>
                                Active / désactive le cache (peut-être très utile pour le
                                débogage de scripts en cache)
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>cache_id_prefix</em></span></td>
<td><span class="type">String</span></td>
<td><code class="constant">NULL</code></td>
<td>
                                Un préfixe pour tous les ID de cache, si réglé à
                                <code class="constant">NULL</code>, aucun préfixe d'ID de cache ne sera
                                utilisé. Le préfixe d'ID de cache sert essentiellement à créer des
                                espaces de noms dans le cache, permettant à plusieurs applications
                                ou sites Web d'utiliser un cache partagé. Chaque application ou
                                site web peut utilisé un préfixe d'ID de cache différent et un
                                préfixe peut aussi être utilisé plusieurs fois.
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>lifetime</em></span></td>
<td><span class="type">Integer</span></td>
<td>3600</td>
<td>
                                Temps de vie (en secondes) du cache, si défini à
                                <code class="constant">NULL</code>, le cache est valide indéfiniment
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>logging</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                Si défini à <code class="constant">TRUE</code>, la journalisation par
                                <code class="classname">Zend_Log</code> est activé (mais le système sera
                                plus lent)
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>write_control</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">TRUE</code></td>
<td>
                                Active / désactive le contrôle d'écriture (le cache est lu
                                juste après l'écriture pour détecter des entrées corrompues),
                                activer "writeControl" va ralentir un petit peu
                                l'écriture du cache, mais pas la lecture (il peut détecter des
                                fichiers de cache corrompus, mais ceci n'est pas un contrôle
                                parfait).
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>automatic_serialization</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                Active / désactive la sérialisation automatique, il peut
                                être utilisé pour enregistrer directement des données qui ne sont
                                pas des chaînes de caractères (mais c'est plus lent).
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>automatic_cleaning_factor</em></span></td>
<td><span class="type">Integer</span></td>
<td>0</td>
<td>
                                Active / désactive le nettoyage automatique ("garbage
                                collector"): 0 signifie aucun nettoyage automatique de cache, 1
                                signifie un nettoyage systématique du cache et x &gt; 1 signifie le
                                nettoyage aléatoire 1 fois toute les x écritures.
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>ignore_user_abort</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                Si réglé à <code class="constant">TRUE</code>, le cache active le drapeau
                                <acronym class="acronym">PHP</acronym> "ignore_user_abort" dans la méthode
                                <code class="methodname">save()</code> pour prévenir de la corruption du
                                cache dans certains cas.
                            </td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.core.examples"></a>Exemples</h4></div></div></div>
            

            <p>Un exemple est donné dans le manuel, tout au début.</p>

            <p>
                Si vous stocker uniquement des chaînes de caractères dans le cache (parce
                qu'avec l'option "automatic_serialization", il est possible de stocker
                des booléens), vous pouvez utiliser une construction plus compact comme :
            </p>

            <pre class="programlisting">
// nous avons déjà $cache

$id = 'myBigLoop'; // id de cache de "ce que l'on veut cacher"

if ( ($data = $cache-&gt;load($id)) === false ) {
    // cache absent

    $data = '';
    for ($i = 0; $i &lt; 10000; $i++) {
        $data = $data . $i;
    }

    $cache-&gt;save($data);

}

// [...] fait quelque chose avec $data
// (affichage, passage ailleurs, etc, etc)
</pre>

            <p>
                Si vous voulez cacher des blocs multiples ou des instances de données, l'idée
                reste la même :
            </p>

            <pre class="programlisting">
// on s'assure que l'on utilise des identifiant uniques
$id1 = 'foo';
$id2 = 'bar';

// block 1
if ( ($data = $cache-&gt;load($id1)) === false ) {
    // cache absent

    $data = '';
    for ($i=0;$i&lt;10000;$i++) {
        $data = $data . $i;
    }

    $cache-&gt;save($data);

}
echo($data);

// ceci n'est pas affecté par la mise en cache
echo('NEVER CACHED! ');

// block 2
if ( ($data = $cache-&gt;load($id2)) === false ) {
    // cache missed

    $data = '';
    for ($i=0;$i&lt;10000;$i++) {
        $data = $data . '!';
    }

    $cache-&gt;save($data);

}
echo($data);
</pre>

            <p>
                Si vous voulez cacher des valeurs "spéciales" (des booléens avec l'option
                "automatic_serialization") ou des chaînes vides, vous ne pouvez pas
                utiliser la construction compacte montrée ci-dessus. Vous devez tester de manière
                formelle l'état du cache.
            </p>

            <pre class="programlisting">
// La construction compacte (ne pas utiliser si vous cachez
// des chaînes et/ou des booléens)
if ( ($data = $cache-&gt;load($id)) === false ) {

    // cache absent

    // [...] on crée $data

    $cache-&gt;save($data);

}

// on fait qqch avec $data

// [...]

// La construction complète (fonctionne dans tous les cas)
if (!($cache-&gt;test($id))) {

    // cache absent

    // [...] on crée $data

    $cache-&gt;save($data);

} else {

    // lecture du cache

    $data = $cache-&gt;load($id);

}

// on fait qqch avec $data
</pre>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.output"></a>Zend_Cache_Frontend_Output</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.output.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Output</code> est un frontend capturant la
                sortie. Il utilise la bufferisation de sortie de <acronym class="acronym">PHP</acronym> pour
                capturer tout ce qui passe entre les méthodes <code class="methodname">start()</code> et
                <code class="methodname">end()</code>.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.output.options"></a>Options disponibles</h4></div></div></div>
            

            <p>
                Ce frontend n'a pas d'options spécifiques autres que celles de
                <code class="classname">Zend_Cache_Core</code>.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.output.examples"></a>Exemples</h4></div></div></div>
            

            <p>
                Un exemple est donnée dans le manuel, tout au début. Le voici avec des
                changements mineurs :
            </p>

            <pre class="programlisting">
// s'il y a un cache manquant, la bufferisation de sortie est lancée
if (!$cache-&gt;start('mypage')) {

    // affiche tout comme d'habitude
    echo 'Hello world! ';
    echo 'This is cached ('.time().') ';

    $cache-&gt;end(); // affiche ce qu'il y a dans le buffer
}

echo 'This is never cached ('.time().').';
</pre>

            <p>
                Utiliser cette forme est assez simple pour définir une mise de cache de
                sortie dans vos projets déjà en production, avec peu de refactorisation de
                code.
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.function"></a>Zend_Cache_Frontend_Function</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.function.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Function</code> met en cache les résultats des
                appels de fonction. Elle a une seule méthode principale appelée
                <code class="methodname">call()</code> qui prend un nom de fonction et des paramètres pour
                l'appel dans un tableau.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.function.options"></a>Options disponibles</h4></div></div></div>
            

            <div class="table">
<a name="zend.cache.frontends.function.options.table"></a><p class="title"><b>Tableau 21. Options du frontend Function</b></p>
<div class="table-contents">
                

                <table class="table" summary="Options du frontend Function" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Type de données</th>
<th>Valeur par défaut</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>cache_by_default</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">TRUE</code></td>
<td>
                                si <code class="constant">TRUE</code>, les appels de fonction seront mis en
                                cache par défaut
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>cached_functions</em></span></td>
<td><span class="type">Array</span></td>
<td>''</td>
<td>les noms de fonctions seront toujours mis en cache</td>
</tr>
<tr>
<td><span class="emphasis"><em>non_cached_functions</em></span></td>
<td><span class="type">Array</span></td>
<td>''</td>
<td>
                                les noms de fonctions ne doivent jamais être mis en
                                cache
                            </td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.function.examples"></a>Exemples</h4></div></div></div>
            

            <p>
                Utiliser la fonction <code class="methodname">call()</code> est la même chose qu'utiliser
                <code class="methodname">call_user_func_array()</code> en <acronym class="acronym">PHP</acronym> :
            </p>

            <pre class="programlisting">
$cache-&gt;call('veryExpensiveFunc', $params);

// $params est dans un tableau par exemple, pour appeler
// (avec mise en cache) : veryExpensiveFunc(1, 'foo', 'bar')
// vous devriez utiliser
$cache-&gt;call('veryExpensiveFunc', array(1, 'foo', 'bar'));
</pre>

            <p>
                <code class="classname">Zend_Cache_Frontend_Function</code> est assez intelligente pour
                mettre en cache la valeur de retour de la fonction, ainsi que sa sortie interne.
            </p>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    Vous pouvez passer n'importe quelle fonction utilisateur à l'exception de
                    <code class="methodname">array()</code>, <code class="methodname">echo()</code>,
                    <code class="methodname">empty()</code>, <code class="methodname">eval()</code>,
                    <code class="methodname">exit()</code>, <code class="methodname">isset()</code>,
                    <code class="methodname">list()</code>, <code class="methodname">print()</code>
                    et <code class="methodname">unset()</code>.
                </p>
            </td></tr>
</table></div>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.class"></a>Zend_Cache_Frontend_Class</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.class.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Class</code> est différent de
                <code class="classname">Zend_Cache_Frontend_Function</code> parce qu'elle permet de mettre
                en cache les objets et les méthodes statiques.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.class.options"></a>Options disponibles</h4></div></div></div>
            

            <div class="table">
<a name="zend.cache.frontends.class.options.table"></a><p class="title"><b>Tableau 22. Options du frontend Class</b></p>
<div class="table-contents">
                

                <table class="table" summary="Options du frontend Class" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Type de données</th>
<th>Valeur par défaut</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>
<span class="emphasis"><em>cached_entity</em></span> (requis)</td>
<td><span class="type">Mixed</span></td>
<td> </td>
<td>
                                si défini avec un nom de classe, nous allons mettre en cache
                                une classe abstraite et utiliser uniquement les appels
                                statiques ; si défini avec un objet, nous allons mettre en
                                cache les méthodes de cet objet.
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>cache_by_default</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">TRUE</code></td>
<td>
                                si <code class="constant">TRUE</code>, les appels vont être cachés par
                                défaut
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>cached_methods</em></span></td>
<td><span class="type">Array</span></td>
<td> </td>
<td>
                                les noms des méthodes qui seront toujours mis en
                                cache
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>non_cached_methods</em></span></td>
<td><span class="type">Array</span></td>
<td> </td>
<td>
                                les noms des méthodes qui ne doivent jamais être mises en
                                cache
                            </td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.class.examples"></a>Exemples</h4></div></div></div>
            

            <p>Par exemple, pour mettre en cache des appels statiques :</p>

            <pre class="programlisting">
class test {

    // Méthode statique
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' =&gt; 'test' // Le nom de la classe
);
// [...]

// l'appel caché
$res = $cache-&gt;foobar('1', '2');
</pre>

            <p>Pour mettre en cache des appels classiques aux méthodes :</p>

            <pre class="programlisting">
class test {

    private $_string = 'hello !';

    public function foobar2($param1, $param2) {
        echo($this-&gt;_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' =&gt; new test() // Une instance de la classe
);
// [...]

// L'appel mis en cache
$res = $cache-&gt;foobar2('1', '2');
</pre>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.file"></a>Zend_Cache_Frontend_File</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.file.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_File</code> est un frontend piloté par la
                modification d'un "fichier maître". C'est vraiment intéressant, par exemple, dans
                les problématiques de configuration ou de templates. Il est également possible
                d'utiliser plusieurs fichiers maîtres.
            </p>

            <p>
                Par exemple, vous avez un fichier de configuration <acronym class="acronym">XML</acronym> qui est
                analysé par une fonction, celle-ci retourne un "objet de configuration" (comme avec
                <code class="classname">Zend_Config</code>). Avec
                <code class="classname">Zend_Cache_Frontend_File</code>, vous pouvez stocker l'objet de
                configuration dans le cache (pour éviter d'analyser le fichier de configuration
                <acronym class="acronym">XML</acronym> chaque fois) mais avec une sorte de forte dépendance au
                fichier maître. Ainsi si le fichier <acronym class="acronym">XML</acronym> de configuration est
                modifié, le cache est immédiatement invalide.
            </p>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.file.options"></a>Options disponibles</h4></div></div></div>
            

            <div class="table">
<a name="zend.cache.frontends.file.options.table"></a><p class="title"><b>Tableau 23. Options du frontend File</b></p>
<div class="table-contents">
                

                <table class="table" summary="Options du frontend File" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Type de données</th>
<th>Valeur par défaut</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>
<span class="emphasis"><em>master_file</em></span> (déprécié)</td>
<td><span class="type">String</span></td>
<td>''</td>
<td>le chemin complet et le nom du fichier maître</td>
</tr>
<tr>
<td><span class="emphasis"><em>master_files</em></span></td>
<td><span class="type">Array</span></td>
<td><code class="methodname">array()</code></td>
<td>un tableau de chemin complet de fichiers maîtres</td>
</tr>
<tr>
<td><span class="emphasis"><em>master_files_mode</em></span></td>
<td><span class="type">String</span></td>
<td><code class="constant">Zend_Cache_Frontend_File::MODE_OR</code></td>
<td>
                                <code class="constant">Zend_Cache_Frontend_File::MODE_AND</code> ou
                                <code class="constant">Zend_Cache_Frontend_File::MODE_OR</code> ; si
                                <code class="constant">MODE_AND</code>, alors tous les fichiers maîtres
                                doivent être modifiés pour rendre invalide le cache, si
                                <code class="constant">MODE_OR</code>, alors un seul fichier maître modifié
                                est nécessaire pour invalider le cache
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>ignore_missing_master_files</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                si <code class="constant">TRUE</code>, l'absence de fichiers maîtres est
                                ignoré silencieusement (sinon une exception est levée)
                            </td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.file.examples"></a>Exemples</h4></div></div></div>
            

            <p>
                L'utilisation de ce frontend est la même que celle de
                <code class="classname">Zend_Cache_Core</code>. Il n'y a pas besoin d'exemple spécifique -
                la seule chose à faire est de définir le <span class="emphasis"><em>master_file</em></span> lors de
                l'utilisation de la fabrique.
            </p>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.page"></a>Zend_Cache_Frontend_Page</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.page.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Page</code> est comme
                <code class="classname">Zend_Cache_Frontend_Output</code> mais créé pour une page complète.
                Il est impossible d'utiliser <code class="classname">Zend_Cache_Frontend_Page</code> pour
                mettre en cache un bloc unique.
            </p>

            <p>
                D'un autre côté, le "cache ID", est calculé automatiquement avec
                <code class="varname">$_SERVER['REQUEST_URI']</code> et (en fonction des options)
                <code class="varname">$_GET</code>, <code class="varname">$_POST</code>, <code class="varname">$_SESSION</code>,
                <code class="varname">$_COOKIE</code>, <code class="varname">$_FILES</code>. De plus, vous avez
                seulement une méthode pour appeler (<code class="methodname">start()</code>) parce que
                l'appel à <code class="methodname">end()</code> est totalement automatique lorsque la page
                est terminé.
            </p>

            <p>
                Pour le moment, ceci n'est pas implémenté mais nous prévoyons d'ajouter un
                système de condition <acronym class="acronym">HTTP</acronym> pour économiser de la bande passante
                (le système émettra un en-tête "<acronym class="acronym">HTTP</acronym> 304 Not Modified" si le
                cache est trouvé, et si le navigateur a déjà la bonne version).
            </p>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    Ce frontend opère en enregistrant une fonction de rappel qui doit être appelée
                    quand le buffer de sortie qu'il utilise est nettoyé. Dans le but de fonctionner
                    correctement, il doit être le buffer de sortie final de la requête. Pour
                    garantir ceci, le buffer de sortie utilisé par le distributeur (Dispatcher)
                    <span class="emphasis"><em>doit</em></span> être désactivé en appelant la méthode
                    <code class="methodname">setParam()</code> de
                    <code class="classname">Zend_Controller_Front</code>, par exemple
                    <span class="command"><strong>$front-&gt;setParam('disableOutputBuffering', true);</strong></span> ou en
                    ajoutant "resources.frontcontroller.params.disableOutputBuffering = true"
                    à votre fichier d'amorçage (présumé de type <acronym class="acronym">INI</acronym>) si vous
                    utilisez <code class="classname">Zend_Application</code>.
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.page.options"></a>Options disponibles</h4></div></div></div>
            

            <div class="table">
<a name="zend.cache.frontends.page.options.table"></a><p class="title"><b>Tableau 24. Options du frontend Page</b></p>
<div class="table-contents">
                

                <table class="table" summary="Options du frontend Page" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Option</th>
<th>Type de données</th>
<th>Valeur par défaut</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><span class="emphasis"><em>http_conditional</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                utilisez le système "httpConditionnal" ou pas
                                (pas encore implémenté)
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>debug_header</em></span></td>
<td><span class="type">Boolean</span></td>
<td><code class="constant">FALSE</code></td>
<td>
                                si <code class="constant">TRUE</code>, un texte de débogage est ajouté avant
                                chaque page de cache
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>default_options</em></span></td>
<td><span class="type">Array</span></td>
<td><code class="methodname">array(...see below...)</code></td>
<td>
                                un tableau associatif d'options par défaut :
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> par
                                            défaut) cache</em></span> :
                                            le cache est activé si <code class="constant">TRUE</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> par
                                            défaut) cache_with_get_variables</em></span> : si
                                            <code class="constant">TRUE</code>, le cache est toujours activé
                                            même s'il y a des variables dans le tableau
                                            <code class="varname">$_GET</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> par
                                            défaut) cache_with_post_variables</em></span> : si
                                            <code class="constant">TRUE</code>, le cache est toujours activé
                                            même s'il y a des variables dans le tableau
                                            <code class="varname">$_POST</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> par
                                            défaut) cache_with_session_variables</em></span> :
                                            si <code class="constant">TRUE</code>, le cache est toujours
                                            activé s'il y a des variables dans le tableau
                                            <code class="varname">$_SESSION</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> par
                                            défaut) cache_with_files_variables</em></span> : si
                                            <code class="constant">TRUE</code>, le cache est toujours activé
                                            s'il y a des variables dans le tableau
                                            <code class="varname">$_FILES</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">FALSE</code> par
                                            défaut) cache_with_cookie_variables</em></span> : si
                                            <code class="constant">TRUE</code>, le cache est toujours activé
                                            s'il y a des variables dans le tableau
                                            <code class="varname">$_COOKIE</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> par
                                            défaut) make_id_with_get_variables</em></span> : si
                                            <code class="constant">TRUE</code>, l'identifiant du cache sera
                                            dépendant du contenu du tableau <code class="varname">$_GET</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> par
                                            défaut) make_id_with_post_variables</em></span> :
                                            si <code class="constant">TRUE</code>, l'identifiant du cache
                                            sera dépendant du contenu du tableau
                                            <code class="varname">$_POST</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> par
                                            défaut) make_id_with_session_variables</em></span> :
                                            si <code class="constant">TRUE</code>, l'identifiant du cache
                                            sera dépendant du contenu du tableau
                                            <code class="varname">$_SESSION</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> par
                                            défaut) make_id_with_files_variables</em></span> :
                                            si <code class="constant">TRUE</code>, l'identifiant du cache
                                            sera dépendant du contenu du tableau
                                            <code class="varname">$_FILES</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(boolean, <code class="constant">TRUE</code> par
                                            défaut) make_id_with_cookie_variables</em></span> :
                                            si <code class="constant">TRUE</code>, l'identifiant du cache
                                            sera dépendant du contenu du tableau
                                            <code class="varname">$_COOKIE</code>
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(int, <code class="constant">FALSE</code> par défaut)
                                            specific_lifetime</em></span> : si
                                            <code class="constant">TRUE</code>, la durée de vie fournie sera
                                            utilisée pour l'expression régulière choisie
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(array, <code class="methodname">array()</code> par
                                                défaut) tags</em></span> :
                                            balises pour l'enregistrement en cache
                                        </p>
                                    </li>
<li class="listitem">
                                        <p>
                                            <span class="emphasis"><em>(int, <code class="constant">NULL</code> par défaut)
                                                priority</em></span> :
                                            priorité (si le backend le supporte)
                                        </p>
                                    </li>
</ul></div>
</td>
</tr>
<tr>
<td><span class="emphasis"><em>regexps</em></span></td>
<td><span class="type">Array</span></td>
<td><code class="methodname">array()</code></td>
<td>
                                un tableau associatif pour définir les options, uniquement
                                pour certaines <code class="constant">REQUEST_URI</code>, les clés sont des
                                expressions régulières <acronym class="acronym">PCRE</acronym>, les valeurs sont
                                des tableaux associatifs avec des options spécifiques pour définir
                                si les expressions régulières correspondent dans
                                <code class="varname">$_SERVER['REQUEST_URI']</code> (voir les options par
                                défaut pour la liste des options disponibles) ; si plusieurs
                                expressions régulières correspondent à un
                                <code class="varname">$_SERVER['REQUEST_URI']</code>, seule la dernière
                                sera utilisée.
                            </td>
</tr>
<tr>
<td><span class="emphasis"><em>memorize_headers</em></span></td>
<td><span class="type">Array</span></td>
<td><code class="methodname">array()</code></td>
<td>
                                un tableau de chaînes correspondant aux noms d'en-têtes
                                <acronym class="acronym">HTTP</acronym>. Les en-têtes listés seront stockées avec
                                les données de cache et renvoyées lorsque le cache sera rappelé.
                            </td>
</tr>
</tbody>
</table>
            </div>
</div>
<br class="table-break">
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.page.examples"></a>Exemples</h4></div></div></div>
            

            <p>
                L'utilisation de <code class="classname">Zend_Cache_Frontend_Page</code> est vraiment
                trivial :
            </p>

            <pre class="programlisting">
// [...] // require, configuration et factory

$cache-&gt;start();
// si le cache est trouvé, le résultat est envoyé au navigateur
// et le script s'arrête là

// reste de la page ...
</pre>

            <p>
                Un exemple plus complexe qui montre un moyen pour obtenir une gestion
                centralisée du cache dans un fichier d'amorçage (pour utiliser avec
                <code class="classname">Zend_Controller</code> par exemple)
            </p>

            <pre class="programlisting">
// vous devriez éviter de mettre trop de lignes avant la section
// de cache par exemple, pour des performances optimales,
// "require_once" ou "Zend_Loader::loadClass" devrait être
// après la section de cache

$frontendOptions = array(
   'lifetime' =&gt; 7200,
   'debug_header' =&gt; true, // pour le déboguage
   'regexps' =&gt; array(
       // met en cache la totalité d'IndexController
       '^/$' =&gt; array('cache' =&gt; true),

       // met en cache la totalité d'IndexController
       '^/index/' =&gt; array('cache' =&gt; true),

       // nous ne mettons pas en cache l'ArticleController...
       '^/article/' =&gt; array('cache' =&gt; false),

       // ...mais nous mettons en cache l'action "view"
       '^/article/view/' =&gt; array(
            // de cet ArticleController
           'cache' =&gt; true,

           // et nous mettons en cache même lorsqu'il y a
           // des variables dans $_POST
           'cache_with_post_variables' =&gt; true,

           // (mais le cache sera dépendent du tableau $_POST)
           'make_id_with_post_variables' =&gt; true,
       )
   )
);
$backendOptions = array(
    'cache_dir' =&gt; '/tmp/'
);

// obtenir un objet Zend_Cache_Frontend_Page
$cache = Zend_Cache::factory('Page',
                             'File',
                             $frontendOptions,
                             $backendOptions);

$cache-&gt;start();
// si nous trouvons un cache, le résultat est envoyé au navigateur,
// et le script s'arrête là

// [...] la fin du fichier de démarrage
// (ces lignes ne seront pas exécutées si on trouve un cache)
</pre>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.page.cancel"></a>La méthode spécifique cancel()</h4></div></div></div>
            

            <p>
                A cause de problèmes de design, dans certains cas (par exemple quand on
                utilise des codes de retour <acronym class="acronym">HTTP</acronym> autres que 200), vous
                pouvez avoir besoin de stopper le processus de mise en cache courant. Il a donc été
                introduit pour ce frontend en particulier, la méthode
                <code class="methodname">cancel()</code>.
            </p>

            <pre class="programlisting">
// [...] require, configuration et fabrique

$cache-&gt;start();

// [...]

if ($unTest) {
    $cache-&gt;cancel();
    // [...]
}

// [...]
</pre>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.cache.frontends.capture"></a>Zend_Cache_Frontend_Capture</h3></div></div></div>
        

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.cache.frontends.capture.introduction"></a>Introduction</h4></div></div></div>
            

            <p>
                <code class="classname">Zend_Cache_Frontend_Capture</code> is like
                <code class="classname">Zend_Cache_Frontend_Output</code> but designed for a complete page.
                It's impossible to use <code class="classname">Zend_Cache_Frontend_Capture</code> for
                caching only a single block. This class is specifically designed to operate in
                concert only with the <code class="classname">Zend_Cache_Backend_Static</code> backend to
                assist in caching entire pages of <acronym class="acronym">HTML</acronym> / <acronym class="acronym">XML</acronym>
                or other content to a physical static file on the local filesystem.
            </p>

            <p>
                Please refer to the documentation on
                <code class="classname">Zend_Cache_Backend_Static</code> for all use cases pertaining to
                this class.
            </p>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    This frontend operates by registering a callback function to be called
                    when the output buffering it uses is cleaned. In order for this to operate
                    correctly, it must be the final output buffer in the request. To guarantee
                    this, the output buffering used by the Dispatcher <span class="emphasis"><em>must</em></span> be
                    disabled by calling <code class="classname">Zend_Controller_Front</code>'s
                    <code class="methodname">setParam()</code> method, for example,
                    <span class="command"><strong>$front-&gt;setParam('disableOutputBuffering', true);</strong></span> or adding
                    "resources.frontcontroller.params.disableOutputBuffering = true"
                    to your bootstrap configuration file (assumed <acronym class="acronym">INI</acronym>) if using
                    <code class="classname">Zend_Application</code>.
                </p>
            </td></tr>
</table></div>
        </div>
     </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.cache.theory.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.cache.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.cache.backends.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Aspect théorique </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Les backends Zend_Cache</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
