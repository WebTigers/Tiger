<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Utiliser les adaptateurs de traduction</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.translate.html" title="Zend_Translate">
<link rel="prev" href="zend.translate.adapter.html" title="Adaptateurs pour Zend_Translate">
<link rel="next" href="zend.translate.sourcecreation.html" title="Creating source files">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Utiliser les adaptateurs de traduction</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.translate.adapter.html">Précédent</a> </td>
<th width="60%" align="center">Zend_Translate</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.translate.sourcecreation.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.translate.using"></a>Utiliser les adaptateurs de traduction</h2></div></div></div>
    

    <p>L'étape suivante est d'utiliser l'adaptateur dans votre code.</p>

    <div class="example">
<a name="zend.translate.using.example1"></a><p class="title"><b>Exemple 905. Exemple de code PHP monolingue</b></p>
<div class="example-contents">
        

        <pre class="programlisting">
print "Exemple\n";
print "=======\n";
print "Ceci la ligne une\n";
print "Aujourd'hui nous sommes le " . date("d/m/Y") . "\n";
print "\n";
print "Correction de la langue ceci est la ligne deux\n";
</pre>
    </div>
</div>
<br class="example-break">

    <p>
        L'exemple ci-dessus montre l'affichage sans le support de traduction. Vous écrivez
        probablement votre code dans votre langue maternelle. Généralement vous devez traduire non
        seulement l'affichage, mais également les messages d'erreur et les messages de log.
    </p>

    <p>
        La prochaine étape est d'inclure <code class="classname">Zend_Translate</code> dans votre code
        existant. Naturellement il est beaucoup plus facile si vous écrivez dès le début votre code
        en utilisant <code class="classname">Zend_Translate</code> au lieu de modifier votre code
        après.
    </p>

    <div class="example">
<a name="zend.translate.using.example2"></a><p class="title"><b>Exemple 906. Exemple de code PHP multilingue</b></p>
<div class="example-contents">
        

        <pre class="programlisting">
$translate = new Zend_Translate(
    array(
        'adapter' =&gt; 'gettext',
        'content' =&gt; '/my/path/source-de.mo',
        'locale'  =&gt; 'de'
    )
);
$translate-&gt;addTranslation(
    array(
        'content' =&gt; '/path/to/translation/fr-source.mo',
        'locale'  =&gt; 'fr'
    )
);

print $translate-&gt;_("Exemple")."\n";
print "=======\n";
print $translate-&gt;_("Ceci la ligne une")."\n";
printf($translate-&gt;_("Aujourd'hui nous sommes le %1\$s") . "\n",
                     date("d/m/Y"));
print "\n";

$translate-&gt;setLocale('fr');
print $translate-&gt;_("Correction de la langue ceci est la ligne deux") . "\n";
</pre>
    </div>
</div>
<br class="example-break">

    <p>
        Maintenant regardons plus attentivement ce qui a été fait et la façon d'intégrer
        <code class="classname">Zend_Translate</code> dans votre code.
    </p>

    <p>
        Créer un nouvel objet de traduction et définir l'adaptateur de base : </p>
<pre class="programlisting">
$translate = new Zend_Translate(
    array(
        'adapter' =&gt; 'gettext',
        'content' =&gt; '/path/to/translation/source-de.mo',
        'locale'  =&gt; 'de'
    )
);
</pre>
<p> Dans cet exemple nous avons décidé d'utiliser <span class="emphasis"><em>l'adaptateur
        Gettext</em></span>. Nous plaçons notre fichier <code class="code">source-de.mo</code> dans le dossier
        <code class="code">/chemin/vers</code>. Le fichier gettext inclura la traduction allemande. Et nous avons
        également ajouté un autre fichier de langue pour le français.
    </p>

    <p>
        L'étape suivante est d'envelopper toutes les chaînes qui doivent être traduites.
        L'approche la plus simple est d'avoir seulement des chaînes simples ou des phrases comme
        celle-ci : </p>
<pre class="programlisting">
print $translate-&gt;_("Exemple")."\n";
print "=======\n";
print $translate-&gt;_("Ceci la ligne une")."\n";
</pre>
<p>Certaines chaînes ne sont pas nécessairement traduites. La ligne séparatrice
        est toujours la même, même dans d'autres langues.
    </p>

    <p>
        Avoir des valeurs de données intégrées dans une chaîne de traduction est également
        supporté par l'utilisation des paramètres inclus. </p>
<pre class="programlisting">
printf($translate-&gt;_("Aujourd'hui nous sommes le %1\$s") . "\n",
                     date("d/m/Y"));
</pre>
<p> Au lieu de <code class="methodname">print()</code>, utiliser la fonction <code class="methodname">printf()</code>
        et remplacer tous les paramètres avec des éléments de type <span class="emphasis"><em>%1\$s</em></span>. Le premier
        est <span class="emphasis"><em>%1\$s</em></span>, le second <span class="emphasis"><em>%2\$s</em></span>, et ainsi de suite. De cette façon une
        traduction peut être faite sans savoir la valeur exacte. Dans notre exemple, la date est
        toujours le jour actuel, mais la chaîne peut être traduite sans connaissance du jour
        actuel.
    </p>

    <p>
        Chaque chaîne est identifiée dans le stockage de traduction par un identificateur de
        message. Vous pouvez employer l'identificateur de message au lieu des chaînes dans votre
        code, comme ceci : </p>
<pre class="programlisting">
print $translate-&gt;_(1)."\n";
print "=======\n";
print $translate-&gt;_(2)."\n";
</pre>
<p> faire ceci a plusieurs inconvénients :
 </p>

    <p>
        Vous ne pouvez pas voir ce que votre code devrait afficher juste en lisant
        celui-ci.
    </p>

    <p>
        En outre vous obtiendrez des problèmes si certaines chaînes ne sont pas traduites.
        Vous devez toujours imaginer comment la traduction fonctionne. Premièrement
        <code class="classname">Zend_Translate</code> vérifie si la langue choisie a une traduction pour
        l'identificateur de message ou la chaîne fournie. Si aucune chaîne de traduction n'a été
        trouvée, elle se reporte sur la langue suivante comme définie dans
        <code class="classname">Zend_Locale</code>. Ainsi le "<span class="emphasis"><em>de_AT</em></span>" devient seulement
        "<span class="emphasis"><em>de</em></span>". Si aucune traduction n'est trouvée pour le
        "<span class="emphasis"><em>de</em></span>", alors le message original est retourné. De cette façon vous avez
        toujours un affichage, au cas où la traduction de message n'existerait pas dans votre
        stockage des messages. <code class="classname">Zend_Translate</code> ne lève jamais d'erreur ou
        d'exception en traduisant les chaînes.
    </p>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.structure"></a>Structures des sources de traduction</h3></div></div></div>
        

        <p>
            L'étape suivante est la création des sources de traduction pour les multiples
            langues vers lesquelles vous traduisez. Chaque adaptateur est créé de sa propre manière
            comme décrit ici. Mais il y a quelques dispositifs généraux qui sont valables pour tous
            les adaptateurs.
        </p>

        <p>
            Vous devrez savoir où stocker vos fichiers sources de traduction. Avec
            <code class="classname">Zend_Translate</code> vous n'avez aucune restriction. Les structures
            suivantes sont préférables :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>Structure de source unique</p>

                <pre class="programlisting">
/application
/languages
  lang.en
  lang.de
/library
</pre>

                <p>
                    Positif : Tous les fichiers sources pour chacune des langues peuvent être
                    trouvés dans un dossier. Aucun fractionnement des fichiers.
                </p>
            </li>
<li class="listitem">
                <p>Source structurée par langue</p>

                <pre class="programlisting">
/application
/languages
  /en
    lang.en
    other.en
  /de
    lang.de
    other.de
/library
</pre>

                <p>
                    Positif : chaque langue est située dans un dossier. La traduction est
                    facilitée car un seul dossier doit être traduit par une équipe de langue. En
                    outre l'utilisation de dossiers multiples est transparente.
                </p>
            </li>
<li class="listitem">
                <p>Source structurée par application</p>

                <pre class="programlisting">
/application
  /languages
    lang.en
    lang.de
    other.en
    other.de
</pre>

                <p>
                    Positif : tous les fichiers sources pour chacune des langues peuvent être
                    trouvés dans un seul dossier. Aucun fractionnement des fichiers.
                </p>

                <p>
                    Négatif : avoir des dossiers multiples pour la même langue est
                    problématique.
                </p>
            </li>
<li class="listitem">
                <p>Source structurée par Gettext</p>

                <pre class="programlisting">
/languages
  /de
    /LC_MESSAGES
      lang.mo
      other.mo
  /en
    /LC_MESSAGES
      lang.mo
      other.mo
</pre>

                <p>
                    Positif : de vieilles sources de gettext peuvent être utilisées sans
                    changer la structure.
                </p>

                <p>
                    Négatif : avoir des dossiers de dossiers peut être embrouillant pour les
                    personnes qui n'ont pas utilisé gettext avant.
                </p>
            </li>
<li class="listitem">
                <p>Source structurée par fichier</p>

                <pre class="programlisting">
/application
  /models
    mymodel.php
    mymodel.de
    mymodel.en
  /views
  /controllers
    mycontroller.de
/document_root
  /images
  /styles
  .htaccess
  index.php
  index.de
/library
  /Zend
</pre>

                <p>Positif : chaque fichier est lié à sa propre source de traduction.</p>

                <p>
                    Négatif : de multiples petits fichiers sources de traduction rendent plus
                    difficile la traduction. En outre chaque fichier doit être ajouté comme source
                    de traduction.
                </p>
            </li>
</ul></div>

        <p>
            Les fichiers source uniques et structurés par langue sont les plus utilisés pour
            <code class="classname">Zend_Translate</code>.
        </p>

        <p>
            Maintenant, que nous connaissons la structure que nous voulons avoir, nous devons
            créer nos fichiers sources de traduction.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.source.array"></a>Créer des fichiers sources de type tableau</h3></div></div></div>
        

        <p>
            Les fichiers sources de type tableau sont simplement des tableaux. Mais vous devez
            les définir manuellement parce qu'il n'y a aucun outil pour automatiser cela. Mais parce
            qu'ils sont très simples, ils représentent la manière la plus rapide de rechercher des
            messages si votre code fonctionne comme prévu. C'est généralement le meilleur adaptateur
            pour démarrer avec des systèmes multilingues.
        </p>

        <pre class="programlisting">
$english = array('message1' =&gt; 'message1',
                 'message2' =&gt; 'message2',
                 'message3' =&gt; 'message3');
$german = array('message1' =&gt; 'Nachricht1',
                'message2' =&gt; 'Nachricht2',
                'message3' =&gt; 'Nachricht3');

$translate = new Zend_Translate('array', $english, 'en');
$translate-&gt;addTranslation($deutsch, 'de');
</pre>

        <p>
            Depuis la version 1.5 il est également possible d'avoir des tableaux inclus dans
            un fichier externe. Vous devez simplement fournir le nom de fichier,
            <code class="classname">Zend_Translate</code> l'inclura automatiquement et recherchera le
            tableau. Voir l'exemple suivant pour les détails :
        </p>

        <pre class="programlisting">
// montableau.php
return array(
    'message1' =&gt; 'Nachricht1',
    'message2' =&gt; 'Nachricht2',
    'message3' =&gt; 'Nachricht3');

// contrôleur
$translate = new Zend_Translate('array',
                                'chemin/vers/montableau.php',
                                'de');
</pre>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Les fichiers qui ne renvoient pas un tableau ne seront pas inclus. N'importe
                quel rendu issu de ce fichier sera ignoré et également supprimé.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.source.gettext"></a>Créer des fichiers sources Gettext</h3></div></div></div>
        

        <p>
            Des fichiers source Gettext sont créés par la bibliothèque GNU gettext. Il y a
            plusieurs outils libres disponibles qui peuvent analyser vos fichiers de code et créer
            les fichiers sources nécessaires à gettext. Ces fichiers se terminent par
            <span class="emphasis"><em>*.mo</em></span> et ce sont des fichiers binaires. Un gratuiciel pour créer ces
            fichiers est <a class="ulink" href="http://sourceforge.net/projects/poedit/" target="_top">poEdit</a>. Cet
            outil vous aide également pour le processus de traduction lui-même.
        </p>

        <pre class="programlisting">
// Les fichiers mo sont créés et déjà traduits
$translate = new Zend_Translate('gettext',
                                'chemin/vers/english.mo',
                                'en');
$translate-&gt;addTranslation('chemin/vers/german.mo', 'de');
</pre>

        <p>
            Comme vous pouvez le voir, les adaptateurs sont utilisés exactement de la même
            manière, avec juste une petite différence : changer "<code class="code">array</code>" en
            "<code class="code">gettext</code>". Toutes autres utilisations sont exactement les mêmes qu'avec
            tous autres adaptateurs. Avec l'adaptateur de gettext vous ne devez plus vous occuper de
            la structure des répertoires, du "<code class="code">bindtextdomain</code>" et du
            "<code class="code">textdomain</code>". Fournissez juste le chemin et le nom de fichier à
            l'adaptateur.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Vous devriez toujours employer UTF-8 comme source d'encodage. Autrement vous
                aurez des problèmes si vous employez deux encodages différents. Par exemple, si un
                de vos fichiers source est encodé en ISO-8815-1 et un fichier différent est codé
                avec CP815. Vous ne pouvez utiliser qu'un seul encodage pour vos fichiers sources,
                ainsi une de vos langues ne s'affichera probablement pas correctement.
            </p>

            <p>
                UTF-8 est un format portable qui supporte toutes les langues. Si vous employez
                l'encodage UTF-8 pour toutes les langues, vous éliminez le problème des encodages
                incompatibles.
            </p>
        </td></tr>
</table></div>

        <p>
            La plupart des éditeur gettext ajoutent les informations de l'adaptateur comme
            chaines de traduction vides. C'est pour cela que traduire des chaines vides ne
            fonctionne pas avec l'adaptateur gettext. A la place, elles sont effacées de la table de
            traduction. <code class="methodname">getAdapterInfo()</code> retourne les informations de l'adaptateur
            gettext, notamment les informations des fichiers gettext ajoutés.
        </p>

        <pre class="programlisting">
// Informations sur l'adaptateur
$translate = new Zend_Translate('gettext',
                                'path/to/english.mo',
                                'en');
print_r $translate-&gt;getAdapterInfo();
</pre>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.source.tmx"></a>Créer des fichiers source TMX</h3></div></div></div>
        

        <p>
            Les fichiers sources TMX sont les nouveaux standards industriels. Ils ont
            l'avantage d'être des fichiers <acronym class="acronym">XML</acronym> et ainsi ils sont lisibles par tout éditeur de
            fichier et naturellement ils sont lisibles pour l'homme. Vous pouvez soit créer des
            fichiers TMX manuellement avec un éditeur de texte, soit utiliser un outil. Mais la
            plupart des programmes actuellement disponibles pour développer des fichiers source TMX
            ne sont pas des gratuiciels.
        </p>

        <div class="example">
<a name="zend.translate.using.source.tmx.example"></a><p class="title"><b>Exemple 907. Exemple de fichier TMX</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
&lt;?xml version="1.0" ?&gt;
&lt;!DOCTYPE tmx SYSTEM "tmx14.dtd"&gt;
&lt;tmx version="1.4"&gt;
 &lt;header creationtoolversion="1.0.0" datatype="winres"
         segtype="sentence" adminlang="en-us" srclang="de-at"
         o-tmf="abc" creationtool="XYZTool" &gt;
 &lt;/header&gt;
 &lt;body&gt;
  &lt;tu tuid='message1'&gt;
   &lt;tuv xml:lang="de"&gt;&lt;seg&gt;Nachricht1&lt;/seg&gt;&lt;/tuv&gt;
   &lt;tuv xml:lang="en"&gt;&lt;seg&gt;message1&lt;/seg&gt;&lt;/tuv&gt;
  &lt;/tu&gt;
  &lt;tu tuid='message2'&gt;
   &lt;tuv xml:lang="en"&gt;&lt;seg&gt;message2&lt;/seg&gt;&lt;/tuv&gt;
   &lt;tuv xml:lang="de"&gt;&lt;seg&gt;Nachricht2&lt;/seg&gt;&lt;/tuv&gt;
  &lt;/tu&gt;
</pre>

            <pre class="programlisting">
$translate = new Zend_Translate('tmx',
                                'chemin/vers/mytranslation.tmx',
                                'en');
// TMX peut contenir différentes langues dans le même fichier
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Les fichiers TMX peuvent avoir plusieurs langues dans le même fichier. Toute autre
            langue incluse est ajoutée automatiquement, ainsi vous n'avez pas à appeler
            <code class="methodname">addLanguage()</code>.
        </p>

        <p>
            Si vous voulez avoir seulement les langues spécifiées de la source traduite, vous
            pouvez régler l'option <code class="code">defined_language</code> à <code class="constant">TRUE</code>. Avec cette
            option vous pouvez ajouter les langues souhaitées explicitement avec
            <code class="methodname">addLanguage()</code>. La valeur par défaut pour cette option est d'ajouter toutes
            les langues.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.source.csv"></a>Créer des fichiers source CSV</h3></div></div></div>
        

        <p>
            Les fichiers sources CSV sont petits et lisibles pour l'homme. Si vos clients
            veulent eux-mêmes traduire, vous utiliserez probablement l'adaptateur CSV.
        </p>

        <div class="example">
<a name="zend.translate.using.source.csv.example"></a><p class="title"><b>Exemple 908. Exemple avec un fichier CSV</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
#Exemple de fichier csv
message1;Nachricht1
message2;Nachricht2
</pre>

            <pre class="programlisting">
$translate = new Zend_Translate('csv',
                                'chemin/vers/matraduction.csv',
                                'de');
$translate-&gt;addTranslation('chemin/vers/autretraduction.csv',
                           'fr');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Il existe trois options différentes pour l'adaptateur CSV. Vous pouvez paramétrer
            "<code class="code">delimiter</code>", "<code class="code">limit</code>" et "<code class="code">enclosure</code>".
        </p>

        <p>
            Le délimiteur standard des fichiers CSV est le signe "<code class="code">;</code>". Mais
            celui-ci n'est pas obligatoire. Avec l'option "<code class="code">delimiter</code>" vous pouvez
            décider d'utiliser un autre signe de séparation.
        </p>

        <p>
            La taille limite d'une ligne de fichier CSV est par défaut "<code class="code">0</code>" Ce qui
            veut dire que la fin de la ligne est recherchée automatiquement. Si vous paramétrez
            l'option "<code class="code">limit</code>" avec une valeur quelconque, alors le fichier CSV sera lu
            plus rapidement, mais toute ligne dont la longueur excédera la limite sera
            tronquée.
        </p>

        <p>
            "L'échappement" par défaut d'un fichier CSV est le "<code class="code">"</code>". Vous pouvez
            en paramétrer un autre avec l'option "<code class="code">enclosure</code>".
        </p>

        <div class="example">
<a name="zend.translate.using.source.csv.example2"></a><p class="title"><b>Exemple 909. Exemple avec un fichier CSV (2)</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
#Exemple de fichier csv
# original 'message,1'
"message,1",Nachricht1
# traduction 'Nachricht,2'
message2,"Nachricht,2"
# original 'message3,'
"message3,",Nachricht3
</pre>

            <pre class="programlisting">
$translate = new Zend_Translate('csv',
                                'chemin/vers/matraduction.csv',
                                'de',
                                array('delimiter' =&gt; ','));
$translate-&gt;addTranslation('chemin/vers/autretraduction.csv',
                           'fr');
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.source.ini"></a>Créer des fichiers sources INI</h3></div></div></div>
        

        <p>
            Les fichiers sources <acronym class="acronym">INI</acronym> sont lisibles par l'homme mais habituellement pas très
            petits puisqu'ils incluent également d'autres données à côté des traductions. Si vous
            avez des données qui seront éditables par vos clients, vous pouvez aussi utiliser
            l'adaptateur <acronym class="acronym">INI</acronym> dans ce cas.
        </p>

        <div class="example">
<a name="zend.translate.using.source.ini.example"></a><p class="title"><b>Exemple 910. Exemple avec un fichier INI</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
[Test]
;Commentaires possibles
Message_1="Nachricht 1 (de)"
Message_2="Nachricht 2 (de)"
Message_3="Nachricht :3 (de)"
</pre>

            <pre class="programlisting">
$translate = new Zend_Translate('ini',
                                'path/to/mytranslation.ini',
                                'de');
$translate-&gt;addTranslation('path/to/other.ini',
                           'it');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Les fichiers <acronym class="acronym">INI</acronym> ont de multiples restrictions. Si une valeur dans le fichier <acronym class="acronym">INI</acronym>
            contient un caractère non-alphanumérique, il doit être entouré avec des guillemets
            doubles ("). Il y a aussi des mots réservés qui ne doivent pas être utilisés en tant que
            clés des fichiers <acronym class="acronym">INI</acronym>. Ceci inclut : <code class="constant">NULL</code>, <code class="code">yes</code>,
            <code class="code">no</code>, <code class="constant">TRUE</code> et <code class="constant">FALSE</code>. Les valeurs <code class="constant">NULL</code>,
            <code class="code">no</code> et <code class="constant">FALSE</code> sont retournées sous la forme "". <code class="code">yes</code>
            et <code class="constant">TRUE</code> sont retournés en "1". Les caractères {}|&amp;~![()" ne doivent pas
            être utilisés dans la clé et ont une signification particulière dans la valeur. Ne les
            utilisez pas ou vous rencontrerez des comportements inattendus.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.options"></a>Options pour les adaptateurs</h3></div></div></div>
        

        <p>
            Les options peuvent être utilisées avec tous les adaptateurs. Bien sûr chacun
            d'eux accepte des options différentes. Vous pouvez passer des options quand vous créez
            l'adaptateur. Pour l'instant il y a qu'une option qui est valable pour tous les
            adaptateurs. '<code class="code">clear</code>' décide si des données de traduction peuvent être
            ajoutées à l'existant ou non. Le comportement standard est d'ajouter des nouvelles
            données de traduction à l'existant. Les données de traduction sont seulement effacées
            pour la langue choisie. Donc on ne touchera pas aux autres langues.
        </p>

        <p>
            Vous pouvez régler des options temporaires en utilisant
            <code class="methodname">addTranslation($data, $locale, array $options = array())</code> comme troisième
            paramètre optionnel. Ou vous pouvez utiliser la fonction <code class="methodname">setOptions()</code> pour
            régler une option.
        </p>

        <div class="example">
<a name="zend.translate.using.options.example"></a><p class="title"><b>Exemple 911. Utiliser les options de traduction</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
// définir ':' comme séparateur pour les fichiers sources de traduction
$options = array('delimiter' =&gt; ':');
$translate = new Zend_Translate('csv',
                                'chemin/vers/matraduction.csv',
                                'fr',
                                $options);

...

// efface le langage défini et utilise de nouvelles données de traduction
$options = array('clear' =&gt; true);
$translate-&gt;addTranslation('chemin/vers/nouveau.csv',
                           'en',
                           $options);
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Ici vous pouvez trouver toutes les options disponibles pour les différents
            adaptateurs avec une description de leur utilisation :
        </p>

        <div class="table">
<a name="zend.translate.using.options.alloptions"></a><p class="title"><b>Tableau 168. Options des adaptateurs de traduction</b></p>
<div class="table-contents">
            

            <table class="table" summary="Options des adaptateurs de traduction" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Adaptateur</th>
<th>Option</th>
<th>Valeur standard</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>Tous</td>
<td><code class="code">clear</code></td>
<td><code class="constant">FALSE</code></td>
<td>Si réglé à <code class="constant">TRUE</code>, les traductions déjà lues seront
                        effacées. Ceci peut être utilisé au lieu de créer une nouvelle instance
                        quand on lit de nouvelles données de traduction.</td>
</tr>
<tr>
<td>Tous</td>
<td><code class="code">disableNotices</code></td>
<td><code class="constant">FALSE</code></td>
<td>Si réglé à <code class="constant">TRUE</code>, toutes les notices concernant la
                        non-disponibilité des traductions seront désactivées. Vous devriez
                        mettre cette option à <code class="constant">TRUE</code> dans votre environnement de
                        production.</td>
</tr>
<tr>
<td>Tous</td>
<td><code class="code">ignore</code></td>
<td><span class="emphasis"><em>.</em></span></td>
<td>Tous les dossiers et les fichiers commençant par ce caractère
                        seront ignorés dans la recherche automatique de traductions. La valeur
                        par défaut est <span class="emphasis"><em>'.'</em></span>, ce qui signifie que tous les
                        fichiers cachés (Unix) seront ignorés. Mettre une valeur par exemple à
                        'tmp' aura pour effet d'ignorer les dossiers ou fichiers 'tmpImages' ou
                        encore 'tmpFiles' (par exemple), ainsi que tous les
                        sous-dossiers</td>
</tr>
<tr>
<td>all</td>
<td>log</td>
<td><span class="emphasis"><em>null</em></span></td>
<td>An instance of Zend_Log where untranslated messages and notices will
                        be written to</td>
</tr>
<tr>
<td>logMessage</td>
<td>all</td>
<td>The message which will be written into the log</td>
<td>
                            <span class="emphasis"><em>Untranslated message within '%locale%': %message%</em></span>
                        </td>
</tr>
<tr>
<td>all</td>
<td>logUntranslated</td>
<td><span class="emphasis"><em>false</em></span></td>
<td>When this option is set to true, all message id's which can not be
                        translated will be written into a also attached log</td>
</tr>
<tr>
<td>Tous</td>
<td><code class="code">scan</code></td>
<td><code class="constant">NULL</code></td>
<td>Si réglé à <code class="constant">NULL</code>, aucun scan de la structure de
                        répertoire ne sera effectué. Si réglé à
                        <code class="classname">Zend_Translate::LOCALE_DIRECTORY</code>, la localisation
                        sera détectée dans le répertoire. Si réglé à
                        <code class="classname">Zend_Translate::LOCALE_FILENAME</code>, la localisation
                        sera détectée dans le nom de fichier. Voir <a class="xref" href="zend.translate.using.html#zend.translate.using.detection" title="Détéction automatique de la source">la section intitulée « Détéction automatique de la source »</a> pour de plus amples
                        détails.</td>
</tr>
<tr>
<td>Csv</td>
<td><code class="code">delimiter</code></td>
<td><code class="code">;</code></td>
<td>Définit quel signe est utilisé pour la séparation de la source et
                        de la traduction.</td>
</tr>
<tr>
<td>Csv</td>
<td><code class="code">length</code></td>
<td><code class="code">0</code></td>
<td>Définit la longueur maximum d'une ligne de fichier. Réglé à 0, la
                        recherche sera automatique.</td>
</tr>
<tr>
<td>Csv</td>
<td><code class="code">enclosure</code></td>
<td><code class="code">"</code></td>
<td>Définit le caractère d'échappement.</td>
</tr>
</tbody>
</table>
        </div>
</div>
<br class="table-break">

        <p>
            Si vous souhaitez avoir vos propres définitions d'options, vous pouvez les
            utiliser avec tous les adaptateurs. La méthode <code class="methodname">setOptions()</code> peut être
            utilisée pour définir vos options. La méthode <code class="methodname">setOptions()</code> nécessite un
            tableau avec les options que vous voulez paramétrer. Si une option fournie existe déjà,
            elle sera alors ré-assignée. Vous pouvez définir autant d'options que nécessaire car
            elles ne seront pas vérifiées par l'adaptateur. Vérifiez simplement que vous ne créez
            pas une option qui existe déjà dans l'adaptateur, vous affecteriez alors une nouvelle
            valeur.
        </p>

        <p>
            Pour récupérer l'ensemble des options, vous pouvez utiliser la méthode
            <code class="methodname">getOptions()</code>. Quand <code class="methodname">getOptions()</code> est appelée sans paramètre,
            elle retourne l'ensemble des options. Si un paramètre est fourni, seule l'option
            particulière sera retournée.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.languages"></a>Gérer les langues</h3></div></div></div>
        

        <p>
            En travaillant avec différentes langues il y a quelques méthodes qui seront
            utiles.
        </p>

        <p>
            La méthode <code class="methodname">getLocale()</code> peut être utilisée pour récupérer la langue
            actuellement réglée. Elle peut retourner soit une instance de
            <code class="classname">Zend_Locale</code>, soit un identifiant de localisation.
        </p>

        <p>
            La méthode <code class="methodname">setLocale()</code> règle une nouvelle langue standard pour la
            traduction. Ceci évite de placer le paramètre facultatif de langue plus d'une fois lors
            de l'appel de la méthode <code class="methodname">translate()</code>. Si la langue donnée n'existe pas, ou
            si aucune donnée de traduction n'est disponible pour la langue, <code class="methodname">setLocale()</code>
            essaye de remonter à la langue sans région si elle est indiquée. Une langue
            <code class="code">fr_FR</code> serait remontée à <code class="code">fr</code>. Si la remontée n'est pas possible,
            une exception sera levée.
        </p>

        <p>
            La méthode <code class="methodname">isAvailable()</code> vérifie si une langue donnée est déjà
            disponible. Elle retourne <code class="constant">TRUE</code> si des données existent pour la langue
            fournie.
        </p>

        <p>
            Et enfin la méthode <code class="methodname">getList()</code> peut être utilisée pour récupérer sous
            la forme d'un tableau tous les langues paramétrées pour un adaptateur.
        </p>

        <div class="example">
<a name="zend.translate.using.languages.example"></a><p class="title"><b>Exemple 912. Gestion des langues avec des adaptateurs</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
// retourne la langue paramétrée actuelle
$actual = $translate-&gt;getLocale();

...
// vous pouvez utiliser le paramètre optionel au moment de la traduction
echo $translate-&gt;_("mon_texte", "fr");
// ou paramètrer une langue standard
$translate-&gt;setLocale("fr");
echo $translate-&gt;_("mon_texte");
// référence à la langue de base... fr_CH sera remonté à fr
$translate-&gt;setLocale("fr_CH");
echo $translate-&gt;_("mon_texte");
...
// vérifie si la langue existe
if ($translate-&gt;isAvailable("fr")) {
    // la langue existe
}
</pre>
        </div>
</div>
<br class="example-break">

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.using.languages.automatic"></a>Gestion automatique des langues</h4></div></div></div>
            

            <p>
                Notez que tant que vous ajouterez les nouvelles sources de traduction
                seulement via la méthode <code class="methodname">addTranslation()</code>,
                <code class="classname">Zend_Translate</code> cherchera automatiquement la langue
                correspondant au mieux à votre environnement quand vous utiliserez une des
                localisations automatiques "<code class="code">auto</code>" ou "<code class="code">browser</code>". Donc
                normalement vous ne devriez pas appeler <code class="methodname">setLocale()</code>. Ceci ne doit être
                utilisé qu'en conjonction avec la détection automatique des sources de
                traduction.
            </p>

            <p>
                L'algorithme recherchera la meilleure locale suivant le navigateur des
                utilisateurs et votre environnement. Voyez l'exemple suivant pour les détails
                :
            </p>

            <div class="example">
<a name="zend.translate.using.languages.automatic.example"></a><p class="title"><b>Exemple 913. Comment la détection automatique de la langue fonctionne-t-elle ?</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// Assumons que le navigateur retourne ces valeurs
// HTTP_ACCEPT_LANGUAGE = "de_AT=1;fr=1;en_US=0.8";

// Exemple 1 :
$translate = new Zend_Translate('gettext',
                                '\my_it.mo',
                                'auto',
                                array('scan' =&gt; Zend_Translate::LOCALE_FILENAME);
// pas de langue trouvée, on retourne le messageid

// Exemple 2 :
$translate = new Zend_Translate('gettext',
                                '\my_fr.mo',
                                'auto',
                                array('scan' =&gt; Zend_Translate::LOCALE_FILENAME);
// langue correspondante trouvée "en_US"

// Exemple 3 :
$translate = new Zend_Translate('gettext',
                                '\my_de.mo',
                                'auto',
                                array('scan' =&gt; Zend_Translate::LOCALE_FILENAME);
// langue correspondante trouvée "de" car "de_AT" est descendue à "de"

// Exemple 4 :
$translate = new Zend_Translate('gettext',
                                '\my_it.mo',
                                'auto',
                                array('scan' =&gt; Zend_Translate::LOCALE_FILENAME);
$translate-&gt;addTranslation('\my_ru.mo', 'ru');
$translate-&gt;setLocale('it_IT');
// retourne "it_IT" comme source de traduction et surcharge le réglage automatique
</pre>
            </div>
</div>
<br class="example-break">

            <p>
                Si vous utilisez <code class="methodname">setLocale()</code>, la detection automatique de la
                langue sera alors annulée, et la langue à utiliser sera celle spécifiée par l'appel
                de la méthode.
            </p>

            <p>
                Si vous voulez réactiver la détection automatique, réappelez
                <code class="methodname">setLocale()</code> et passez lui la valeur <span class="emphasis"><em>auto</em></span>.
            </p>

            <p>
                Depuis Zend Framework 1.7.0 <code class="classname">Zend_Translate</code> reconnait
                une locale globale pour l'application. Vous pouvez ainsi simplement mettre un objet
                <code class="classname">Zend_Locale</code> dans le registre, comme montré ci-après. Avec
                cette fonctionnalité, vous pouvez oublier le passage de la locale à votre objet de
                traduction.
            </p>

            <pre class="programlisting">
// En fichier d'amorçage (bootstrap)
$locale = new Zend_Locale('de_AT');
Zend_Registry::set('Zend_Locale', $locale);

// ailleurs dans votre application
$translate = new Zend_Translate('gettext', '\my_de.mo');
$translate-&gt;getLocale();
</pre>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.detection"></a>Détéction automatique de la source</h3></div></div></div>
        

        <p>
            Zend_Translate peut détecter les sources de traduction de manière automatique.
            Ainsi vous n'avez pas à déclarer toutes les sources manuellement. Vous laissez
            Zend_Translate faire ce travail et scanner complètement tout un répertoire à la
            recherche de fichiers de langue de traduction.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                La détection automatique des sources de traduction est disponible depuis Zend
                Framework version 1.5.
            </p>
        </td></tr>
</table></div>

        <p>
            L'utilisation est assez semblable à celle qui permet de spécifier une source de
            langue. Vous devez simplement donner un dossier, et non plus un fichier, à l'adaptateur.
            Ce dossier sera alors scanné
        </p>

        <div class="example">
<a name="zend.translate.using.languages.directory.example"></a><p class="title"><b>Exemple 914. Scanner un dossier à la recherche de sources de traduction</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
// Soit la structure suivante :
//  /language
//  /language/login/login.tmx
//  /language/logout/logout.tmx
//  /language/error/loginerror.tmx
//  /language/error/logouterror.tmx

$translate = new Zend_Translate('tmx', '/language');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Notez que Zend_Translate cherche dans tous les sous-repertoires. L'utilisation
            devient alors relativement simple. Aussi, Zend_Translate ignorera tout fichier qui ne
            l'interresse pas : des fichiers non représentatifs de traductions ou encore des fichiers
            illisibles. Vérifiez donc que le dossier principal ne contienne que des fichiers de
            traductions, car Zend_Translate ne renverra aucune erreur dans le cas contraire, il
            ignorera simplement de tels fichiers.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Selon la compléxité de la récursivité, la traversée du répertoire principal
                peut devenir longue et couteuse.
            </p>
        </td></tr>
</table></div>

        <p>
            Dans notre exemple, nous utilisons l'adaptateur TMX qui inclut la langue à
            utiliser dans le fichier en question. D'autres adaptateurs n'agissent pas comme cela,
            ainsi les noms de fichiers devront comporter les noms des langues à considérer pour de
            tels adaptateurs.
        </p>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.using.detection.directory"></a>La langue se trouve dans le nom des dossiers</h4></div></div></div>
            

            <p>
                One way to include automatic language detection is to name the directories
                related to the language which is used for the sources within this directory. This is
                the easiest way and is used for example within standard gettext
                implementations.
            </p>

            <p>
                Zend_Translate needs the 'scan' option to know that it should search the names
                of all directories for languages. See the following example for details:
            </p>

            <div class="example">
<a name="zend.translate.using.detection.directory.example"></a><p class="title"><b>Exemple 915. Directory scanning for languages</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// expect we have the following structure
//  /language
//  /language/de/login/login.mo
//  /language/de/error/loginerror.mo
//  /language/en/login/login.mo
//  /language/en/error/loginerror.mo

$translate = new Zend_Translate('gettext',
                                '/language',
                                null,
                                array('scan' =&gt;
                                    Zend_Translate::LOCALE_DIRECTORY));
</pre>
            </div>
</div>
<br class="example-break">

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    This works only for adapters which do not include the language within the
                    source file. Using this option for example with TMX will be ignored. Also
                    language definitions within the filename will be ignored when using this
                    option.
                </p>
            </td></tr>
</table></div>

            <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                <p>
                    You should be aware if you have several subdirectories under the same
                    structure. Expect we have a structure like
                    <code class="code">/language/module/de/en/file.mo</code>. The path contains in this case
                    multiple strings which would be detected as locale. It could be eigther
                    <code class="code">de</code> or <code class="code">en</code>. As the behaviour is, in this case, not
                    declared it is recommended that you use file detection in such
                    situations.
                </p>
            </td></tr>
</table></div>
        </div>

        <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.using.detection.filename"></a>Language through filenames</h4></div></div></div>
            

            <p>
                Another way to detect the langage automatically is to use special filenames.
                You can either name the complete file or parts of a file with the used language. To
                use this way of detection you will have to set the 'scan' option at initiation.
                There are several ways of naming the sourcefiles which are described below:
            </p>

            <div class="example">
<a name="zend.translate.using.detection.filename.example"></a><p class="title"><b>Exemple 916. Filename scanning for languages</b></p>
<div class="example-contents">
                

                <pre class="programlisting">
// expect we have the following structure
//  /language
//  /language/login/login_en.mo
//  /language/login/login_de.mo
//  /language/error/loginerror_en.mo
//  /language/error/loginerror_de.mo

$translate = new Zend_Translate('gettext',
                                '/language',
                                null,
                                array('scan' =&gt;
                                    Zend_Translate::LOCALE_FILENAME));
</pre>
            </div>
</div>
<br class="example-break">

            <div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.translate.using.detection.filename.complete"></a>Complete Filename</h5></div></div></div>
                

                <p>
                    Having the whole file named after the language is the simplest way but
                    only usable if you have only one file per directory.
                </p>

                <pre class="programlisting">
/languages
  en.mo
  de.mo
  es.mo
</pre>
            </div>

            <div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.translate.using.detection.filename.extension"></a>Extension of the file</h5></div></div></div>
                

                <p>
                    Another very simple way if to use the extension of the file for the
                    language detection. But this may be confusing because you will no longer know
                    which file extension the file originally was.
                </p>

                <pre class="programlisting">
/languages
  view.en
  view.de
  view.es
</pre>
            </div>

            <div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.translate.using.detection.filename.token"></a>Filename tokens</h5></div></div></div>
                

                <p>
                    Zend_Translate is also captable of detecting the language if it is
                    included within the filename. But if you use this way you will have to seperate
                    the language with a token. There are three supported tokens which can be used: A
                    point '.', a underline '_', or a hyphen '-'.
                </p>

                <pre class="programlisting">
/languages
  view_en.mo  -&gt; detects english
  view_de.mo  -&gt; detects german
  view_it.mo  -&gt; detects italian
</pre>

                <p>
                    The first found token which can be detected as locale will be used. See
                    the following example for details.
                </p>

                <pre class="programlisting">
/languages
  view_en_de.mo  -&gt; detects english
  view_en_es.mo  -&gt; detects english and overwrites the first file
                    because the same messageids are used
  view_it_it.mo  -&gt; detects italian
</pre>

                <p>
                    All three tokens are used to detect the locale. The first one is the point
                    '.', the second is the underline '_' and the third the hyphen '-'. If you have
                    several tokens within the filename the first found depending on the order of the
                    tokens will be used. See the following example for details.
                </p>

                <pre class="programlisting">
/languages
  view_en-it.mo  -&gt; detects english because '_' will be used before '-'
  view-en_it.mo  -&gt; detects italian because '_' will be used before '-'
  view_en.it.mo  -&gt; detects italian because '.' will be used before '_'
</pre>
            </div>
        </div>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.istranslated"></a>Vérifier les traductions</h3></div></div></div>
        

        <p>
            Normalement le texte sera traduit sans aucun calcul. Mais il est quelquefois
            nécessaire si un texte est traduit ou non dans la source. Dans ce cas la méthode
            <code class="methodname">isTranslated()</code> peut être utilisé.
        </p>

        <p>
            <code class="methodname">isTranslated($messageId, $original = false, $locale = null)</code> prend
            comme premier paramètre le texte dont vous voulez vérifier que la traduction est
            possible. Et comme troisième paramètre optionnel la langue dont vous voulez connaître la
            traduction. Le second paramètre optionnel détermine si la traduction est fixée à la
            langue déclarée ou si une autre langue peut être utilisée. Si vous avez un texte qui
            peut être traduit en "fr" mais pas en "fr_fr" vous obtiendriez normalement la traduction
            fournie, mais avec <code class="varname">$original</code> réglé à <code class="constant">TRUE</code>, la méthode
            <code class="methodname">isTranslated()</code> retournera <code class="constant">FALSE</code> dans ce cas.
        </p>

        <div class="example">
<a name="zend.translate.using.istranslated.example"></a><p class="title"><b>Exemple 917. Vérifier si une texte est traduisible</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
$english = array('message1' =&gt; 'Nachricht 1',
                 'message2' =&gt; 'Nachricht 2',
                 'message3' =&gt; 'Nachricht 3');
$translate = new Zend_Translate('array', $english, 'de_AT');

if ($translate-&gt;isTranslated('message1')) {
    print "'message1' peut être traduit";
}
if (!($translate-&gt;isTranslated('message1', true, 'de'))) {
    print "'message1' ne peut pas être traduit en 'de', "
        . "il est seulement disponible en 'de_AT'";
}
if ($translate-&gt;isTranslated('message1', false, 'de')) {
    print "'message1' peut être traduit en 'de_AT' "
        . "et par conséquent en 'de'";}
</pre>
        </div>
</div>
<br class="example-break">
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.logging"></a>How to log not found translations</h3></div></div></div>

        

        <p>
            When you have a bigger site or you are creating the translation files manually, you
            often have the problem that some messages are not translated. But there is a easy
            solution for you when you are using <code class="classname">Zend_Translate</code>.
        </p>

        <p>
            You have to follow two or three simple steps. First, you have to create a instance of
            <code class="classname">Zend_Log</code>. And then you have to attach this instance to
            <code class="classname">Zend_Translate</code>. See the following example:
        </p>

        <div class="example">
<a name="zend.translate.using.logging.example"></a><p class="title"><b>Exemple 918. Log translations</b></p>
<div class="example-contents">
            
            <pre class="programlisting">
$translate = new Zend_Translate('gettext', $path, 'de');

// Create a log instance
$writer = new Zend_Log_Writer_Stream('/path/file.log');
$log = new Zend_Log($writer);

// Attach it to the translation instance
$translate-&gt;setOptions(array(
    'log' =&gt; $log,
    'logUntranslated' =&gt; true));

$translate-&gt;translate('unknown string');
</pre>
        </div>
</div>
<br class="example-break">

        <p>
            Now you will have in the log a new notice:
            <code class="code">Untranslated message within 'de': unknown string</code>.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                You should note that any translation which can not be found will be logged. This
                means all translations when a user requests a not supported language. But also every
                request to a message which can not be translated will be logged. Be aware that when
                100 people request the same translation you will have 100 notices logged.
            </p>
        </td></tr>
</table></div>

        <p>
            This feature can not only be used to log messages but also to attach this not translated
            messages into a empty translation file. To archive this you will have to write your own
            log writer which writes the format you want to have and strips the prepending
            "Untranslated message" for you.
        </p>

        <p>
            You can also set the '<code class="code">logMessage</code>' option when you want to have your own log
            message. Use the '<code class="code">%message%</code>' token for placing the messageId within your log
            message, and the '<code class="code">%locale%</code>' token for the requested locale. See the
            following example for a self defined log message:
        </p>

        <div class="example">
<a name="zend.translate.using.logging.example2"></a><p class="title"><b>Exemple 919. Self defined log messages</b></p>
<div class="example-contents">
            
            <pre class="programlisting">
$translate = new Zend_Translate('gettext', $path, 'de');

// Create a log instance
$writer = new Zend_Log_Writer_Stream('/path/to/file.log');
$log    = new Zend_Log($writer);

// Attach it to the translation instance
$translate-&gt;setOptions(array(
    'log'             =&gt; $log,
    'logMessage'      =&gt; "Missing '%message%' within locale '%locale%'",
    'logUntranslated' =&gt; true));

$translate-&gt;translate('unknown string');
</pre>
        </div>
</div>
<br class="example-break">

    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.using.sourcedata"></a>Access to the source data</h3></div></div></div>
        

        <p>
            Of course sometimes it is useful to have access to the translation source data.
            Therefor two functions exist.
        </p>

        <p>
            The <code class="methodname">getMessageIds($locale = null)</code> method returns all known message
            ids as array.
        </p>

        <p>
            And the <code class="methodname">getMessages($locale = null)</code> method returns the complete
            translation source as array. The message id is used as key and the translation data as
            value.
        </p>

        <p>
            Both methods accept an optional parameter <code class="varname">$locale</code> which, when set,
            returns the translation data for the specified language. If this parameter is not given,
            the actual set language will be used. Keep in mind that normally all translations should
            be available in all languages. Which means that in a normal situation you will not have
            to set this parameter.
        </p>

        <p>
            Additionally the <code class="methodname">getMessages()</code> method is able to return the complete
            translation dictionary with the pseudo-locale 'all'. This will return all available
            translation data for each added locale.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Attention: The returned array can be <span class="emphasis"><em>very big</em></span>, depending
                on the count of added locales and the amount of translation data.
            </p>
        </td></tr>
</table></div>

        <div class="example">
<a name="zend.translate.using.sourcedata.example"></a><p class="title"><b>Exemple 920. Handling languages with adapters</b></p>
<div class="example-contents">
            

            <pre class="programlisting">
...
// returns all known message ids
$messageids = $translate-&gt;getMessageIds();
print_r($messageids);

...
// or just for the specified language
$messageids = $translate-&gt;getMessageIds('en_US');
print_r($messageids);

...
// returns all the complete translation data
$source = $translate-&gt;getMessages();
print_r($source);
</pre>
        </div>
</div>
<br class="example-break">
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.translate.adapter.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.translate.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.translate.sourcecreation.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Adaptateurs pour Zend_Translate </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Creating source files</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
