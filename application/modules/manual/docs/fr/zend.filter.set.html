<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Classes de filtre standards</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
<link rel="home" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.filter.html" title="Zend_Filter">
<link rel="prev" href="zend.filter.introduction.html" title="Introduction">
<link rel="next" href="zend.filter.filter_chains.html" title="Chaînes de filtrage">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Classes de filtre standards</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.filter.introduction.html">Précédent</a> </td>
<th width="60%" align="center">Zend_Filter</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.filter.filter_chains.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.filter.set"></a>Classes de filtre standards</h2></div></div></div>
    

    <p>
        Zend Framework est fourni avec un jeu de filtres standards, qui sont directement
        utilisables.
    </p>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.alnum"></a>Alnum</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Filter_Alnum</code> est un filtre qui ne retourne que des caractères
        alphabétiques et des chiffres. Tout autre caractère est supprimé.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.alnum.options"></a>Options supportées par Zend_Filter_Alnum</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Filter_Alnum</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowwhitespace</span></em></span>: Si activée, les espaces
                    seront autorisés, autrement ils sont supprimés. Par défaut, les espaces ne sont pas
                    autorisés et supprimés.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.alnum.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voyez l'exemple suivant pour le comportement par défaut de ce filtre.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Alnum();
$return = $filter-&gt;filter('This is (my) content: 123');
// retourne 'Thisismycontent123'
</pre>

        <p>
            L'exemple ci-dessus retourne 'Thisismycontent123'. Comme vous le voyez, tous les espaces et le double-point
            sont filtrés.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                <code class="classname">Zend_Filter_Alnum</code> fonctionne sur presque tous les langages. Les exceptions
                sont le chinois, le japonnais et le coréen. Ces langues utiliseront l'alphabet anglais plutot que
                le leur. Le langage est détecté par <code class="classname">Zend_Locale</code>.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.alnum.whitespace"></a>Autoriser les espaces</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Filter_Alnum</code> peut aussi autoriser les espaces. Ca peut être utile, voyez
            l'exemple suivant:
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Alnum(array('allowwhitespace' =&gt; true));
$return = $filter-&gt;filter('This is (my) content: 123');
// retourne 'This is my content 123'
</pre>

        <p>
            L'exemple ci-dessus retourne 'This is my content 123'. Comme vous le voyez, le double-point est filtré
            ainsi que les parenthèses, mais pas les espaces.
        </p>

        <p>
            Pour changer <span class="property">allowWhiteSpace</span> après construction de l'objet, utilisez
            <code class="methodname">setAllowWhiteSpace()</code> et
            <code class="methodname">getAllowWhiteSpace()</code>.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.alpha"></a>Alpha</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Filter_Alpha</code> est un filtre qui va retourner
        <code class="varname">$value</code> en enlevant tout caractère non alphabétique. Ce filtre propose
        une option pour autoriser le caractère espace.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.alpha.options"></a>Options supportées par Zend_Filter_Alpha</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Filter_Alpha</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">allowwhitespace</span></em></span>: Si activée, les espaces
                    seront autorisés. Par défaut, ils sont supprimés.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.alpha.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voici un exemple de base:
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Alpha();

print $filter-&gt;filter('This is (my) content: 123');
</pre>

        <p>
            L'exemple ci-dessus affiche 'Thisismycontent'. Remarquez que les espaces et le double-point
            ont été supprimés.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                <code class="classname">Zend_Filter_Alpha</code> fonctionne sur presque tous les langages. Les exceptions
                sont le chinois, le japonnais et le coréen. Ces langues utiliseront l'alphabet anglais plutot que
                le leur. Le langage est détecté par <code class="classname">Zend_Locale</code>.
            </p>
        </td></tr>
</table></div>
    </div>

     <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.alpha.whitespace"></a>Autoriser les espaces</h4></div></div></div>
         

        <p>
            <code class="classname">Zend_Filter_Alpha</code> peut aussi autoriser les espaces. Ca peut être utile, voyez
            l'exemple suivant:
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Alpha(array('allowwhitespace' =&gt; true));

print $filter-&gt;filter('This is (my) content: 123');
</pre>

        <p>
            L'exemple ci-dessus retourne 'This is my content'. Comme vous le voyez, le double-point ainsi que
            les chiffres et les parenthèses sont filtrés mais pas les espaces.
        </p>

        <p>
            Pour changer <span class="property">allowWhiteSpace</span> après construction de l'objet, utilisez
            <code class="methodname">setAllowWhiteSpace()</code> et
            <code class="methodname">getAllowWhiteSpace()</code>.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.basename"></a>BaseName</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Filter_BaseName</code> permet de retourner le nom d'un fichier
        dans une chaine représentant un chemin vers ce fichier.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.basename.options"></a>Options supportées par Zend_Filter_BaseName</h4></div></div></div>
        

        <p>
            Il n'y a pas d'option supplémentaire gérée par <code class="classname">Zend_Filter_BaseName</code>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.basename.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voici un exemple de base:
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_BaseName();

print $filter-&gt;filter('/vol/tmp/filename');
</pre>

        <p>
            Ceci va afficher 'filename'.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_BaseName();

print $filter-&gt;filter('/vol/tmp/filename.txt');
</pre>

        <p>
            Ceci affichera '<code class="filename">filename.txt</code>'.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.boolean"></a>Boolean</h3></div></div></div>
    

    <p>
        Ce filtre transforme toute donnée en valeur <code class="constant">BOOLEAN</code>. Ce peut être
        utile en travaillant avec des bases de données ou des formulaires.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.boolean.options"></a>Options supportées par Zend_Filter_Boolean</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Filter_Boolean</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">casting</span></em></span> : quand cette option
                    est fixée à <code class="constant">TRUE</code> alors toute entrée sera transtypée en
                    booléen. Cette option vaut <code class="constant">TRUE</code> par défaut.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">locale</span></em></span> : cette option permet
                    de spécifier la locale qui sera utilisée pour détecter une entrée localisée.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">type</span></em></span> : l'option
                    <span class="property">type</span> spécifie le type de booléen qui sera utilisé.
                    Lisez ce qui suit pour plus de détails.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.boolean.default"></a>Comportement par défaut de Zend_Filter_Boolean</h4></div></div></div>
        

        <p>
            Par défaut, ce filtre transtype sa valeur vers un
            <code class="constant">BOOLEEN</code> ; en d'autres termes, il fonctionne comme un appel
            PHP de type <span class="command"><strong>(boolean) $value</strong></span>.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Boolean();
$value  = '';
$result = $filter-&gt;filter($value);
// retourne false
</pre>

        <p>
            Ceci signifie que sans paramètre additionnel,
            <code class="classname">Zend_Filter_Boolean</code> prend toute valeur d'entrée et retourne un
            <code class="constant">BOOLEEN</code> comme le transtypage PHP vers le
            <code class="constant">BOOLEEN</code>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.boolean.types"></a>Changer le comportement de Zend_Filter_Boolean</h4></div></div></div>
        

        <p>
            Parfois, le transtypage tel que <span class="command"><strong>(boolean)</strong></span> peut ne pas suffire.
            <code class="classname">Zend_Filter_Boolean</code> permet ainsi de configurer les types d'entrée
            à convertir, et ceux à ignorer.
        </p>

        <p>
            Les types suivants sont acceptés :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>boolean</em></span> : retourne la valeur booléenne telle quelle.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>integer</em></span> : convertit l'entier <span class="emphasis"><em>0</em></span>
                    en <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>float</em></span> : convertit le flottant
                    <span class="emphasis"><em>0.0</em></span> en <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>string</em></span> : convertit la chaîne vide
                    <span class="emphasis"><em>''</em></span> en <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>zero</em></span> : convertit la chaîne contenant zéro
                    (<span class="emphasis"><em>'0'</em></span>) en <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>empty_array</em></span> : convertit le tableau vide
                    <span class="emphasis"><em>array()</em></span> en <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>null</em></span> : convertit une valeur <code class="constant">NULL</code>
                    en <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>php</em></span> : convertit une valeur, comme
                    <acronym class="acronym">PHP</acronym> le ferait, en <code class="constant">BOOLEEN</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>false_string</em></span> : convertit une chaîne contenant le mot
                    "false" en booléen <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>yes</em></span> : convertit une chaîne localisée contenant le mot
                    "no" en <code class="constant">FALSE</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>all</em></span> : convertit tous les types ci-dessus vers un
                    <code class="constant">BOOLEEN</code>.
                </p>
            </li>
</ul></div>

        <p>
            Toute autre valeur fournie retournera <code class="constant">TRUE</code>.
        </p>

        <p>
            Pour préciser les options ci-dessus, plusieurs manières sont données : utilisez des
            chaînes, des constantes, ajoutez les, utilisez des tableaux... Voyez l'exemple :
        </p>

        <pre class="programlisting">
// convertit 0 vers false
$filter = new Zend_Filter_Boolean(Zend_Filter_Boolean::INTEGER);

// convertit 0 et '0' vers false
$filter = new Zend_Filter_Boolean(
    Zend_Filter_Boolean::INTEGER + Zend_Filter_Boolean::ZERO
);

// convertit 0 et '0' vers false
$filter = new Zend_Filter_Boolean(array(
    'type' =&gt; array(
        Zend_Filter_Boolean::INTEGER,
        Zend_Filter_Boolean::ZERO,
    ),
));

// convertit 0 et '0' vers false
$filter = new Zend_Filter_Boolean(array(
    'type' =&gt; array(
        'integer',
        'zero',
    ),
));
</pre>

        <p>
            Vous pouvez aussi passer une instance de <code class="classname">Zend_Config</code> pour
            préciser les options. Pour préciser ces options après la création de votre objet,
            utilisez la méthode <code class="methodname">setType()</code>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.boolean.localized"></a>Booléens localisés</h4></div></div></div>
        

        <p>
            Comme déjà précisé, <code class="classname">Zend_Filter_Boolean</code> reconnaît les chaînes
            localisées "yes" et "no". Ceci signifie que vous pouvez demander au client au travers
            d'un formulaire "oui" ou "non" dans sa propre langue et
            <code class="classname">Zend_Filter_Boolean</code> convertira la valeur vers le booléen
            approprié.
        </p>

        <p>
            Préciser la locale s'effectue grâce à la clé de configuration
            <span class="property">locale</span> ou la méthode <code class="methodname">setLocale()</code>.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Boolean(array(
    'type'   =&gt; Zend_Filter_Boolean::ALL,
    'locale' =&gt; 'de',
));

// retourne false
echo $filter-&gt;filter('nein');

$filter-&gt;setLocale('en');

// retourne true
$filter-&gt;filter('yes');
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.boolean.casting"></a>Désactiver le transtypage</h4></div></div></div>
        

        <p>
            Il peut arriver de ne vouloir que reconnaître <code class="constant">TRUE</code> ou
            <code class="constant">FALSE</code> et donc retourner les autres valeurs telles quelles.
            <code class="classname">Zend_Filter_Boolean</code> permet un tel comportement via son
            option <span class="property">casting</span> lorsque réglée sur <code class="constant">FALSE</code>.
        </p>

        <p>
            Dans un tel cas, <code class="classname">Zend_Filter_Boolean</code> fonctionnera comme décrit
            dans le tableau ci-dessous qui montre quelles valeurs retournent
            <code class="constant">TRUE</code> ou <code class="constant">FALSE</code>. Toute autre valeur non
            présente dans ce tableau sera retournée telle quelle lorsque l'option
            <span class="property">casting</span> vaut <code class="constant">FALSE</code>.
        </p>

        <div class="table">
<a name="zend.filter.set.boolean.casting.table"></a><p class="title"><b>Tableau 75. Utilisation sans transtypage</b></p>
<div class="table-contents">
            
            <table class="table" summary="Utilisation sans transtypage" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Type</th>
<th>True</th>
<th>False</th>
</tr></thead>
<tbody>
<tr>
<td><code class="constant">Zend_Filter_Boolean::BOOLEAN</code></td>
<td><code class="constant">TRUE</code></td>
<td><code class="constant">FALSE</code></td>
</tr>
<tr>
<td><code class="constant">Zend_Filter_Boolean::INTEGER</code></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><code class="constant">Zend_Filter_Boolean::FLOAT</code></td>
<td>0.0</td>
<td>1.0</td>
</tr>
<tr>
<td><code class="constant">Zend_Filter_Boolean::STRING</code></td>
<td>""</td>
<td> </td>
</tr>
<tr>
<td><code class="constant">Zend_Filter_Boolean::ZERO</code></td>
<td>"0"</td>
<td>"1"</td>
</tr>
<tr>
<td><code class="constant">Zend_Filter_Boolean::EMPTY_ARRAY</code></td>
<td><code class="methodname">array()</code></td>
<td> </td>
</tr>
<tr>
<td><code class="constant">Zend_Filter_Boolean::NULL</code></td>
<td><code class="constant">NULL</code></td>
<td> </td>
</tr>
<tr>
<td><code class="constant">Zend_Filter_Boolean::FALSE_STRING</code></td>
<td>"false" (non sensible à la casse)</td>
<td>"true" (non sensible à la casse)</td>
</tr>
<tr>
<td><code class="constant">Zend_Filter_Boolean::YES</code></td>
<td>"oui" localisé (non sensible à la casse)</td>
<td>"non" localisé (non sensible à la casse)</td>
</tr>
</tbody>
</table>
        </div>
</div>
<br class="table-break">

        <p>
            L'exemple qui suit illustre l'utilisation de l'option
            <span class="property">casting</span> :
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Boolean(array(
    'type'    =&gt; Zend_Filter_Boolean::ALL,
    'casting' =&gt; false,
));

// retourne false
echo $filter-&gt;filter(0);

// retourne true
echo $filter-&gt;filter(1);

// retourne la valeur
echo $filter-&gt;filter(2);
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.callback"></a>Callback</h3></div></div></div>
    
    <p>
        Ce filtre vous permet d'utiliser votre propre fonction en tant que filtre de
        <code class="classname">Zend_Filter</code>. Nul besoin de créer un filtre si une fonction ou
        méthode fait déja le travail.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.callback.options"></a>Options supportées par Zend_Filter_Callback</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Filter_Callback</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">callback</span></em></span> : ceci spécifie
                    le callback qui sera utilisé.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">options</span></em></span> : cette propriété
                    les options utilisées lorsque le callback est exécuté.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.callback.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            L'utilisation de ce filtre est assez simple. Prenos par exemple un filtre qui inverse
            une chaine.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Callback('strrev');

print $filter-&gt;filter('Hello!');
// retourne "!olleH"
</pre>

        <p>
            C'est très simple de passer une fonction à appliquer comme filtre. Dans le cas de
            méthodes de classes, passez un tableau comme callback.
        </p>

        <pre class="programlisting">
// Notre classe
class MyClass
{
    public function Reverse($param);
}

// La définition du filtre
$filter = new Zend_Filter_Callback(array('MyClass', 'Reverse'));
print $filter-&gt;filter('Hello!');
</pre>

        <p>
            Pour récupérer la fonction de filtrage actuelle, utilisez
            <code class="methodname">getCallback()</code> et pour en affecter une nouvelle, utilisez
            <code class="methodname">setCallback()</code>.
        </p>

        <div class="note"><table border="0" summary="Note: Exception possible">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Exception possible</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Notez que passer une fonction qui ne peut être appelée mènera à une exception.
            </p>
        </td></tr>
</table></div>

    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.callback.parameters"></a>Default parameters within a callback</h4></div></div></div>
        

        <p>
            Il est aussi possible de définir des paramètres par défaut qui sont alors passés à la
            méthode appelée lorsque le filtre est exécuté.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Callback(
    array(
        'callback' =&gt; 'MyMethod',
        'options'  =&gt; array('key' =&gt; 'param1', 'key2' =&gt; 'param2')
    )
);
$filter-&gt;filter(array('value' =&gt; 'Hello'));
</pre>

        <p>
            L'appel manuel à une telle fonction se serait fait comme cela:
        </p>

        <pre class="programlisting">
$value = MyMethod('Hello', 'param1', 'param2');
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.compress"></a>Compression et décompression</h3></div></div></div>
    
    <p>
        Ces deux filtres sont capables de compresser et décompresser des chaines, des fichiers ou
        des dossiers.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.options"></a>Options supportées par Zend_Filter_Compress et Zend_Filter_Decompress</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par
            <code class="classname">Zend_Filter_Compress</code> et
            <code class="classname">Zend_Filter_Decompress</code> :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">adapter</span></em></span> : l'adaptateur de
                    compression qui doit être utrilisé. Vaut par défaut <span class="property">Gz</span>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">options</span></em></span> : options additionnelles
                    qui sont fournies à l'initialisation de l'adaptateur. Chaque adaptateur
                    supporte ses propres options.
                </p>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.basic"></a>Adaptateurs de compression supportés</h4></div></div></div>
        

        <p>
            Les formats de compression suivants sont supportés par leurs adaptateurs
            respectifs :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Bz2</em></span>
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Gz</em></span>
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Lzf</em></span>
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Rar</em></span>
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Tar</em></span>
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Zip</em></span>
                </p>
            </li>
</ul></div>

        <p>
            Chaque format de compression possède des caractéristiques propres et ils s'utilisent
            tous d'une manière commune. Seules leurs options vont différer ainsi que les types
            de compressions qu'ils offrent (algorithmes, fichiers, chaines et dossiers)
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.generic"></a>Les bases</h4></div></div></div>
        

        <p>
            Pour créer un filtre de compression vous devez sélectionner le format que vous désirez.
            La description suivante utilisera l'adaptateur <span class="emphasis"><em>Bz2</em></span>. Les détails
            des autres adaptateurs seront précisés plus tard dans la section suivante.
        </p>

        <p>
            Les deux filtres (compression et décompression) sont identiques lorsqu'ils utilisent le
            même adaptateur. Simplement <code class="classname">Zend_Filter_Compress</code> est utilisé
            pour les opérations de compression alors que <code class="classname">Zend_Filter_Decompress</code>
            est utilisé pour la décompression.
        </p>

        <p>
            Par exemple, si nous voulons compresser une chaine nous devons instancier
            <code class="classname">Zend_Filter_Compress</code> et indiquer un adaptateur.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Compress('Bz2');
</pre>

        <p>
            Les adaptateurs se spécifient donc dans le constructeur.
        </p>

        <p>
            Il est aussi possible de passer des options sous forme de tableau ou d'objet
            <code class="classname">Zend_Config</code>. Si vous souhaitez préciser des options, vous devez
            alors au minimum indiquer la clé "adapter". Les clés "options" ou
            "adapterOptions" peuvent ensuite être utilisées et doivent représenter un tableau.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Compress(array(
    'adapter' =&gt; 'Bz2',
    'options' =&gt; array(
        'blocksize' =&gt; 8,
    ),
));
</pre>

        <div class="note"><table border="0" summary="Note: Adaptateur de compression par défaut">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Adaptateur de compression par défaut</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Lorsque vous ne précisez aucun adaptateur, <span class="emphasis"><em>Gz</em></span> sera utilisé
                par défaut.
            </p>
        </td></tr>
</table></div>

        <p>
            Concernant la décompression, le principe est exactement identique.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Decompress('Bz2');
</pre>

        <p>
            Pour récupérer une chaine compressée, il faut indiquer la chaine originale.
            La valeur "filtrée" récupérée sera alors la chaine compressée, tout simplement.
        </p>

        <pre class="programlisting">
$filter     = new Zend_Filter_Compress('Bz2');
$compressed = $filter-&gt;filter('Uncompressed string');
// Retourne la chaine compressée
</pre>

        <p>
            La décompression suit exactement le même principe.
        </p>

        <pre class="programlisting">
$filter     = new Zend_Filter_Decompress('Bz2');
$compressed = $filter-&gt;filter('Compressed string');
// Retourne la chaine décompressée
</pre>

        <div class="note"><table border="0" summary="Note: Note sur la compression de chaines">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note sur la compression de chaines</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Tous les adaptateurs ne supportent pas la compression de chaines. Les formats tels que
                <span class="emphasis"><em>Rar</em></span> ne savent que traiter des fichiers ou des répertoires. Pour les détails,
                consultez la documentation relative à l'adaptateur en question.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.archive"></a>Créer une archive</h4></div></div></div>
        

        <p>
            Créer une archive fonctionne quasiment de la même manière que la compression d'une chaine.
            Cependant dans ce cas, nous devons préciser une options supplémentaire indiquant le nom
            de l'archive à créer.
        </p>

        <pre class="programlisting">
$filter     = new Zend_Filter_Compress(array(
    'adapter' =&gt; 'Bz2',
    'options' =&gt; array(
        'archive' =&gt; 'filename.bz2',
    ),
));
$compressed = $filter-&gt;filter('Uncompressed string');
// Retourne true en cas de succès et crée le fichier d'archive
</pre>

        <p>
            Dans l'exemple ci-dessus, la chaine est compressée puis retournée dans une archive.
        </p>

        <div class="note"><table border="0" summary="Note: Les archives existantes seront écrasées">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Les archives existantes seront écrasées</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Si l'archive existe déja, elle sera écrasée.
            </p>
        </td></tr>
</table></div>

        <p>
            Si vous souhaitez compresser un fichier, vous devez fournir son chemin.
        </p>

        <pre class="programlisting">
$filter     = new Zend_Filter_Compress(array(
    'adapter' =&gt; 'Bz2',
    'options' =&gt; array(
        'archive' =&gt; 'filename.bz2'
    ),
));
$compressed = $filter-&gt;filter('C:\temp\compressme.txt');
// Retourne true en cas de succès et crée le fichier d'archive
</pre>

        <p>
            Il est aussi possible de préciser le nom d'un dossier plutôt que d'un fichier.
            Dans ce cas, tout le dossier sera compressé, récursivement.
        </p>

        <pre class="programlisting">
$filter     = new Zend_Filter_Compress(array(
    'adapter' =&gt; 'Bz2',
    'options' =&gt; array(
        'archive' =&gt; 'filename.bz2'
    ),
));
$compressed = $filter-&gt;filter('C:\temp\somedir');
// Retourne true en cas de succès et crée le fichier d'archive
</pre>

        <div class="note"><table border="0" summary="Note: Ne compressez pas un dossier trop gros ou trop profond">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Ne compressez pas un dossier trop gros ou trop profond</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Vous ne devriez jamais tenter de compresser un dossier trop gros ou trop profond, comme
                par exemple une partition complète. Une telle opération s'avère très longue et très
                couteuse en ressources ce qui peut provoquer des problèmes sur votre serveur.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.decompress"></a>Décompresser une archive</h4></div></div></div>
        

        <p>
            Décompresser une archive s'éxecute d'une manière sensiblement identique à la compression.
            Vous devez passer le paramètre <span class="property">archive</span> ou préciser le nom du fichier.
        </p>

        <pre class="programlisting">
$filter     = new Zend_Filter_Decompress('Bz2');
$compressed = $filter-&gt;filter('filename.bz2');
// Retourne true en cas de succès et décompresse le fichier d'archive
</pre>

        <p>
            Certains adaptateurs permettent la décompression d'une archive dans un dossier cible,
            dans ce cas le paramètre <span class="property">target</span> permet de l'indiquer.
        </p>

        <pre class="programlisting">
$filter     = new Zend_Filter_Decompress(array(
    'adapter' =&gt; 'Zip',
    'options' =&gt; array(
        'target' =&gt; 'C:\temp',
    )
));
$compressed = $filter-&gt;filter('filename.zip');
// Retourne true en cas de succès et décompresse le fichier d'archive
// dans le dossier spécifié
</pre>

        <div class="note"><table border="0" summary="Note: Les dossiers de cible doivent exister">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Les dossiers de cible doivent exister</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Lorsque vous souhaitez décompresser une archive dans un dossier cible, vérifiez
                bien que celui-ci existe déja.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.bz2"></a>Adaptateur Bz2</h4></div></div></div>
        

        <p>
            L'adaptateur Bz2 peut compresser et décompresser:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>Chaines</p>
            </li>
<li class="listitem">
                <p>Fichiers</p>
            </li>
<li class="listitem">
                <p>Dossiers</p>
            </li>
</ul></div>

        <p>
            Cet adaptateur utilise l'extension <acronym class="acronym">PHP</acronym> Bz2.
        </p>

        <p>
            Pour personnaliser la compression, cet adaptateur utilise les options suivantes:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Archive</em></span>: Précise l'archive à utiliser ou à créer.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Blocksize</em></span>: Précise la taille des blocs. Des valeurs de
                    '0' à '9' sont permises. La valeur par défaut est '4'.
                </p>
            </li>
</ul></div>

        <p>
            Toutes les options peuvent être passées à l'instanciation ou en utilisant des méthodes.
            Par exemple pour la tailles des blocs, <code class="methodname">getBlocksize()</code> et
            <code class="methodname">setBlocksize()</code>. La méthode
            <code class="methodname">setOptions()</code> est aussi présente, elle accepte un tableau
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.gz"></a>Adaptateur Gz</h4></div></div></div>
        

        <p>
            L'adaptateur Bz2 peut compresser et décompresser:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>Chaines</p>
            </li>
<li class="listitem">
                <p>Fichiers</p>
            </li>
<li class="listitem">
                <p>Dossiers</p>
            </li>
</ul></div>

        <p>
            Cet adaptateur utilise l'extension <acronym class="acronym">PHP</acronym> Zlib.
        </p>

        <p>
            Pour personnaliser la compression, cet adaptateur utilise les options suivantes:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Archive</em></span>: L'archive à créer ou à utiliser.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Level</em></span>: Niveau de compression. Des valeurs de '0'
                    à '9' sont utilisables, par défaut : '9'.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Mode</em></span>: Il existe deux modes supportés : 'compress'
                    et 'deflate'. La valeur par défaut est 'compress'.
                </p>
            </li>
</ul></div>

        <p>
            Toutes les options peuvent être passées en constructeur ou en utilisant des méthodes.
            Par exemple, pour l'option 'Level', <code class="methodname">getLevel()</code> et
            <code class="methodname">setLevel()</code>. La méthode
            <code class="methodname">setOptions()</code> est aussi présente et accepte un tableau.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.lzf"></a>Adaptateur Lzf</h4></div></div></div>
        

        <p>
            L'adaptateur Lzf peut compresser et décompresser:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>Chaines</p>
            </li></ul></div>

        <div class="note"><table border="0" summary="Note: Lzf ne supporte que les chaines de caractères">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Lzf ne supporte que les chaines de caractères</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Lzf ne supporte pas les fichiers et les dossiers.
            </p>
        </td></tr>
</table></div>

        <p>
            Cet adaptateur utilise l'extension <acronym class="acronym">PHP</acronym>Lzf.
        </p>

        <p>
            Il n'existe pas d'options pour personnaliser cet adaptateur.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.rar"></a>Adaptateur Rar</h4></div></div></div>
        

        <p>
            L'adaptateur Rar peut compresser et décompresser:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>Fichiers</p>
            </li>
<li class="listitem">
                <p>Dossiers</p>
            </li>
</ul></div>

        <div class="note"><table border="0" summary="Note: Rar ne supporte pas les chaines de caractères">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Rar ne supporte pas les chaines de caractères</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                L'adaptateur Rar ne supporte pas les chaines de caractères
            </p>
        </td></tr>
</table></div>

        <p>
            Cet adaptateur utilise l'extension <acronym class="acronym">PHP</acronym> Rar.
        </p>

        <div class="note"><table border="0" summary="Note: Compression Rar non supportée">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Compression Rar non supportée</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                Des restrictions du format Rar ne permettent pas la compression gratuite. Si vous souhaitez
                compresser avec cet adaptateur, vous devrez passer une fonction de callback qui utilisera
                un algorithme ou fera appel à un programme externe.
            </p>
        </td></tr>
</table></div>

        <p>
            Cet adaptateur accepte les options suivantes:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Archive</em></span>: Précise l'archive à créer ou à utiliser.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Callback</em></span>: Une fonction de callback fournissant des services
                    de compression à l'adaptateur.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Password</em></span>: Le mot de passe à utiliser éventuellement en cas
                    de décompression.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Target</em></span>: La cible vers laquelle les fichiers décompressés seront
                    écrits.
                </p>
            </li>
</ul></div>

        <p>
            Toutes les options peuvent être passées au constructeurs ou via des méthodes.
            Par exemple, pour l'option 'Target', <code class="methodname">getTarget()</code> et
            <code class="methodname">setTarget()</code>.La méthode
            <code class="methodname">setOptions()</code> est aussi disponible et accepte un tableau.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.tar"></a>Tar Adapter</h4></div></div></div>
        

        <p>
            L'adaptateur Tar peut compresser et décompresser:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>Fichiers</p>
            </li>
<li class="listitem">
                <p>Dossiers</p>
            </li>
</ul></div>

        <div class="note"><table border="0" summary="Note: Tar ne supporte pas les chaines de caractères">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Tar ne supporte pas les chaines de caractères</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                L'adaptateur Tar ne supporte pas les chaines de caractères
            </p>
        </td></tr>
</table></div>

        <p>
            Cet adaptateur utilise le paquet <acronym class="acronym">PEAR</acronym>
            <code class="classname">Archive_Tar</code>.
        </p>

        <p>
            Cet adaptateur accepte les options suivantes:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Archive</em></span>: Précise l'archive à utiliser ou à créer.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Mode</em></span>: Mode de compression. Les modes supportés sont
                    'null' qui signifie pas de compression, 'Gz' qui utilisera l'extension
                    <acronym class="acronym">PHP</acronym> Zlib et 'Bz2' qui utilisera l'extension
                    <acronym class="acronym">PHP</acronym>Bz2. La valeur par défaut est 'null'.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Target</em></span>: La cible vers laquelle les fichier décompressés
                    seront écrits.
                </p>
            </li>
</ul></div>

        <p>
            Toutes les options peuvent être passées au constructeurs ou via des méthodes.
            Par exemple, pour l'option 'Target', <code class="methodname">getTarget()</code> et
            <code class="methodname">setTarget()</code>.La méthode
            <code class="methodname">setOptions()</code> est aussi disponible et accepte un tableau.
        </p>

        <div class="note"><table border="0" summary="Note: Utilisation avec des dossiers">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Utilisation avec des dossiers</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                La compression des dossiers avec Tar utilise le chemin complet comme nom de fichier.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.compress.zip"></a>Adaptateur Zip</h4></div></div></div>
        

        <p>
            L'adaptateur Zip peut compresser et décompresser:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>Chaines</p>
            </li>
<li class="listitem">
                <p>Fichiers</p>
            </li>
<li class="listitem">
                <p>Dossiers</p>
            </li>
</ul></div>

        <div class="note"><table border="0" summary="Note: Zip ne supporte pas la décompression vers des chaines">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Zip ne supporte pas la décompression vers des chaines</th>
</tr>
<tr><td align="left" valign="top">
            

            <p>
                L'adaptateur Zip ne supporte pas la décompression vers des chaines.
                Un fichier sera systématiquement crée.
            </p>
        </td></tr>
</table></div>

        <p>
            Cet adaptateur utilise l'extension <acronym class="acronym">PHP</acronym>
            <code class="classname">Zip</code>.
        </p>

        <p>
            Les options suivantes sont supportées :
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Archive</em></span>: Précise l'archive qui sera utilisée ou
                    créee.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>Target</em></span>: La cible vers laquelle décompresser.
                </p>
            </li>
</ul></div>

        <p>
            Toutes les options peuvent être passées au constructeurs ou via des méthodes.
            Par exemple, pour l'option 'Target', <code class="methodname">getTarget()</code> et
            <code class="methodname">setTarget()</code>.La méthode
            <code class="methodname">setOptions()</code> est aussi disponible et accepte un tableau.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.decrypt"></a>Decrypt</h3></div></div></div>
    
    <p>
        Ce filtre va décrypter toute chaine grâce aux paramètres utilisés. Des adaptateurs sont utilisés.
        Actuellement des aptateurs existent pour les extensions <code class="code">Mcrypt</code> et <code class="code">OpenSSL</code>
        de php.
    </p>

    <p>
        Pour plus de détails sur l'encryptage de contenu, voyez le filtre <code class="code">Encrypt</code>. La
        documentation de celui-ci couvre les bases en matière de cryptage, nous n'aborderons ici que
        les méthodes utilisées pour le décryptage.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.decrypt.mcrypt"></a>Décryptage avec Mcrypt</h4></div></div></div>
        
        <p>
            Pour décrypter une données cryptées avec <code class="code">Mcrypt</code>, vous avez besoin des paramètres
            utilisés pour encrypter, ainsi que du vecteur.
        </p>

        <p>
            Si vous n'aviez pas passé de vecteur spécifique à l'encryptage, alors vous devriez récupérer
            le vecteur utilisé grâce à la méthode <code class="methodname">getVector()</code>. Sans ce vecteur, aucun décryptage
            de la données originale n'est possible.
        </p>

        <p>
            Le décryptage s'effectue aussi simplement que l'encryptage.
        </p>

        <pre class="programlisting">
// Utilisation des paramètres blowfish par défaut
$filter = new Zend_Filter_Decrypt('myencryptionkey');

// Utilisation du vecteur utilisé lors de l'encryptage
$filter-&gt;setVector('myvector');

$decrypted = $filter-&gt;filter('texte_encodé_non_lisible');
print $decrypted;
</pre>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Si l'extension mcrypt n'est pas présente dans votre environement, une exception sera levée.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Vos paramètres sont vérifiés à la création de l'instance ou à l'appel de setEncryption().
                Si mcrypt détecte des problèmes avec ces paramètres, une exception sera levée.
            </p>
        </td></tr>
</table></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.decrypt.openssl"></a>Decryptage avec OpenSSL</h4></div></div></div>
        
        <p>
            Le décryptage avec <code class="code">OpenSSL</code> est aussi simple que l'encryptage. Mais vous aurez besoin de toutes
            les données concernant la personne ayant crypté la donnée de référence.
        </p>

        <p>
            Pour décrypter avec <code class="code">OpenSSL</code> vous devez posséder:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>private</em></span>: votre clé privée. Ce peut être un nom de fichier
                    ou juste le contenu de ce fichier : la clé.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>envelope</em></span>: la clé enveloppe cryptée de l'utilisateur qui
                    a crypté le document. Un chemin de fichier ou une chaine peuvent être utilisés.
                    Lorsque l'option <span class="property">package</span> est paramétrée, vous pouvez
                    omettre ce paramètre.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>package</em></span>: si la clé enveloppe a été empaqueté avec la valeur
                    encryptée. Par défaut vaut <code class="constant">FALSE</code>.
                </p>
            </li>
</ul></div>

        <pre class="programlisting">
// Utilise OpenSSL avec une clé spécifiée
$filter = new Zend_Filter_Decrypt(array(
    'adapter' =&gt; 'openssl',
    'private' =&gt; '/path/to/mykey/private.pem'
));

// Passage des clés enveloppe
$filter-&gt;setEnvelopeKey(array(
    '/key/from/encoder/first.pem',
    '/key/from/encoder/second.pem'
));
</pre>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                L'adaptateur <code class="code">OpenSSL</code> ne fonctionnera pas avec des clés non valides.
            </p>
        </td></tr>
</table></div>

        <p>
            Optionnellement il peut être nécessaire de passer la passphrase pour décrypter les clés
            elles-mêmes. Utilisez alors <code class="methodname">setPassphrase()</code>.
        </p>

        <pre class="programlisting">
// Utilise OpenSSL avec une clé spécifiée
$filter = new Zend_Filter_Decrypt(array(
    'adapter' =&gt; 'openssl',
    'private' =&gt; '/path/to/mykey/private.pem'
));

// Passage des clés enveloppe
$filter-&gt;setEnvelopeKey(array(
    '/key/from/encoder/first.pem',
    '/key/from/encoder/second.pem'
));
$filter-&gt;setPassphrase('mypassphrase');
</pre>

        <p>
            Enfin, décryptez le contenu. Voici l'exemple complet:
        </p>

        <pre class="programlisting">
// Utilise OpenSSL avec une clé spécifiée
$filter = new Zend_Filter_Decrypt(array(
    'adapter' =&gt; 'openssl',
    'private' =&gt; '/path/to/mykey/private.pem'
));

// Passage des clés enveloppe
$filter-&gt;setEnvelopeKey(array(
    '/key/from/encoder/first.pem',
    '/key/from/encoder/second.pem'
));
$filter-&gt;setPassphrase('mypassphrase');

$decrypted = $filter-&gt;filter('texte_encodé_illisible');
print $decrypted;
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.digits"></a>Digits</h3></div></div></div>
    

    <p>
        Retourne la chaine <code class="varname">$value</code>, mais uniquement les chiffres
        la composant.
    </p>

     <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.digits.options"></a>Options supportées par Zend_Filter_Digits</h4></div></div></div>
        

        <p>
            Il n'y a pas d'option supplémentaire pour <code class="classname">Zend_Filter_Digits</code>.
        </p>
    </div>

     <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.digits.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voici un exemple de base:
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Digits();

print $filter-&gt;filter('October 2009');
</pre>

        <p>
            Ceci affiche "2009".
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Digits();

print $filter-&gt;filter('HTML 5 for Dummies');
</pre>

        <p>
            Ceci affiche "5".
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.dir"></a>Dir</h3></div></div></div>
    

    <p>
        Ce filtre retournera le dossier dans une chaine représentant le chemin vers
        un fichier.
    </p>

     <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.dir.options"></a>Options supportées par Zend_Filter_Dir</h4></div></div></div>
        

        <p>
            Il n'y a pas d'options supplémentaire pour <code class="classname">Zend_Filter_Dir</code>.
        </p>
    </div>

     <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.dir.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voici un exemple de base:
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Dir();

print $filter-&gt;filter('/etc/passwd');
</pre>

        <p>
            Ceci affiche "<code class="filename">/etc</code>".
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Dir();

print $filter-&gt;filter('C:/Temp/x');
</pre>

        <p>
            Ceci affiche "<code class="filename">C:/Temp</code>".
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.encrypt"></a>Encrypt</h3></div></div></div>
    
    <p>
        Ce filtre va crypter toute chaine avec les paramètres spécifiés. Des adaptateurs sont utilisés.
        Actuellement, il existe des adaptateurs pour les extensions PHP <code class="code">Mcrypt</code> et
        <code class="code">OpenSSL</code>.
    </p>

    <p>
        Comme ces deux méthodes d'encryptage sont très différentes, l'utilisation de leurs adaptateurs
        l'est aussi.
    </p>

    <pre class="programlisting">
// Utiliser Mcrypt
$filter1 = new Zend_Filter_Encrypt(array('adapter' =&gt; 'mcrypt'));

// Utiliser OpenSSL
$filter2 = new Zend_Filter_Encrypt(array('adapter' =&gt; 'openssl'));
</pre>

    <p>
        Les méthodes <code class="code">setAdapter()</code> et <code class="code">getAdapter()</code> existent aussi.
    </p>

    <pre class="programlisting">
// Utiliser Mcrypt
$filter = new Zend_Filter_Encrypt();
$filter-&gt;setAdapter('openssl');
</pre>

    <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
        <p>
            Si vous ne précisez pas d'adaptateur, <code class="code">Mcrypt</code> est utilisé par défaut.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.encrypt.mcrypt"></a>Cryptage avec Mcrypt</h4></div></div></div>
        
        <p>
            Cet adaptateur nécessite la présence de l'extension PHP <code class="code">Mcrypt</code>. Voici ses options:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>key</em></span>: La clé d'encryptage. Cette même clé sera nécessaire pour le
                    décryptage.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>algorithm</em></span>: L'algorithme à utiliser pour le cryptage. Voyez
                    <a class="ulink" href="http://php.net/mcrypt" target="_top">PHP's mcrypt ciphers</a>. Si non précisé,
                    <code class="code">blowfish</code> sera utilisé par défaut.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>algorithm_directory</em></span>: Le dossier dans lequel se trouve l'algorithme. Si
                    non précisé, le dossier spécifié par l'extension mcrypt est alors utilisé.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>mode</em></span>: Le mode de cryptage à utiliser. Un des
                    <a class="ulink" href="http://php.net/mcrypt" target="_top">modes mcrypt</a> doit être utilisé.
                    Par défaut, <code class="code">cbc</code> est utilisé.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>mode_directory</em></span>: Le dossier dans lequel se trouve le mode. Si
                    non précisé, le dossier spécifié par l'extension mcrypt est alors utilisé.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>vector</em></span>: Le vecteur d'initialisation à utiliser. Un vecteur aléatoire
                    est utilisé si non précisé.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>salt</em></span>: Si la clé doit être utilisé comme grain de sel. Dans ce cas la clé
                    utilisée pour le cryptage sera elle même cryptée. Par défaut false : ce n'est pas le cas.
                </p>
            </li>
</ul></div>

        <p>
            Si vous passez une chaine à la place d'un tableau pour la clé, celle-ci sera utilisée.
        </p>

        <p>
            Les méthodes <code class="code">getEncryption()</code> et <code class="code">setEncryption()</code> sont aussi présentes.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Une exception sera levée si l'extension PHP mcrypt n'est pas disponible.
            </p>
        </td></tr>
</table></div>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Notez aussi que tous vos paramètres utilisés à la création de l'instance ou avec setEncryption()
                vont être vérifiés. Si mcrypt détecte un problème, une exception sera levée.
            </p>
        </td></tr>
</table></div>

        <p>
            <code class="code">getVector()</code> et <code class="code">setVector()</code> sont aussi disponibles si besoin.
            Une chaine passée sera mise à la taille du vecteur pour être utilisée avec l'algorithme en cours.
        </p>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Notez que si vous n'utilisez pas un vecteur spécifique, alors vous devrez le récupérer et le stocker.
                En effet, celui-ci est indispensable pour décoder la valeur dans le futur.
            </p>
        </td></tr>
</table></div>

        <pre class="programlisting">
// Utilise blowfish par défaut
$filter = new Zend_Filter_Encrypt('myencryptionkey');

// Affecte un vecteur précis.
$filter-&gt;setVector('myvector');
// $filter-&gt;getVector(); est nécessaire sinon, pour décoder la valeur plus tard

$encrypted = $filter-&gt;filter('text_to_be_encoded');
print $encrypted;

// Pour le décryptage, voyez le code du filtre Decrypt
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.encrypt.openssl"></a>Cryptage avec OpenSSL</h4></div></div></div>
        
        <p>
            Lorsque vous avez installé l'extension PHP <code class="code">OpenSSL</code>, vous pouvez utiliser l'adaptateur
            du même nom, dont voici les options d'instanciation:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>public</em></span>: La clé publique de l'utilisateur auquel vous voulez proposer
                    du contenu crypté. Plusieurs clés peuvent être spécifiées via un tableau. Il est possible
                    de préciser le contenu de la clé, ou alors un chemin vers une clé.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>private</em></span>: Votre clé privée utilisée pour crypter le contenu.
                    La encore la clé peut être précisée sous forme textuelle, ou alors un chemin vers
                    un fichier contenant la clé.
                </p>
            </li>
</ul></div>

        <p>
            <code class="code">getPublicKey()</code> et <code class="code">setPublicKey()</code> sont aussi présentes, ainsi que
            <code class="code">getPrivateKey()</code> et <code class="code">setPrivateKey()</code>.
        </p>

        <pre class="programlisting">
// Utiliser openssl
$filter = new Zend_Filter_Encrypt(array(
    'adapter' =&gt; 'openssl',
    'private' =&gt; '/path/to/mykey/private.pem'
));

// utilisation des méthodes
$filter-&gt;setPublicKey(array(
    '/public/key/path/first.pem',
    '/public/key/path/second.pem'
));
</pre>

        <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
            <p>
                Attention l'adaptateur <code class="code">OpenSSL</code> ne fonctionnera pas si vous ne passez pas des clés
                valides.
            </p>
        </td></tr>
</table></div>

        <p>
            Si vous souhaitez encoder aussi les clés, passez alors une passphrase via
            <code class="code">setPassphrase()</code>. Attention, la passphrase sera nécessaire pour décoder les clés.
        </p>

        <pre class="programlisting">
// Utilise openssl avec une clé privée
$filter = new Zend_Filter_Encrypt(array(
    'adapter' =&gt; 'openssl',
    'private' =&gt; '/path/to/mykey/private.pem'
));

// utilisation des méthodes pour specifier la clé publique
$filter-&gt;setPublicKey(array(
    '/public/key/path/first.pem',
    '/public/key/path/second.pem'
));
$filter-&gt;setPassphrase('mypassphrase');
</pre>

        <p>
            Pour décrypter le document, la passphrase (si utilisée) et les clés enveloppe sont nécessaires.
        </p>

        <p>
            Ceci signifie que vous devez appeler la méthode <code class="code">getEnvelopeKey()</code> après le cryptage
            pour récupérer l'enveloppe.
        </p>

        <p>
            Voici donc un exemple complet de cryptage de données avec <code class="code">OpenSSL</code>.
        </p>

        <pre class="programlisting">
// Utilisons openssl avec une clé privée
$filter = new Zend_Filter_Encrypt(array(
    'adapter' =&gt; 'openssl',
    'private' =&gt; '/path/to/mykey/private.pem'
));

// Voici la clé publique
$filter-&gt;setPublicKey(array(
    '/public/key/path/first.pem',
    '/public/key/path/second.pem'
));
$filter-&gt;setPassphrase('mypassphrase');

$encrypted = $filter-&gt;filter('text_to_be_encoded');
$envelope  = $filter-&gt;getEnvelopeKey();
print $encrypted;

// Le décryptage est expliqué dans le filtre Decrypt
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.htmlentities"></a>HtmlEntities</h3></div></div></div>
    

    <p>
        Retourne la chaine <code class="varname">$value</code> en convertissant les caractères en leur entité
        <acronym class="acronym">HTML</acronym> équivalente si elle existe.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.htmlentities.options"></a>Options gérées par Zend_Filter_HtmlEntities</h4></div></div></div>
        

        <p>
            Les options suivantes sont supportées par <code class="classname">Zend_Filter_HtmlEntities</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">quotestyle</span></em></span>: Equivalent au paramètre
                    <span class="emphasis"><em>quote_style</em></span> de la fonction <acronym class="acronym">PHP</acronym> htmlentities.
                    Ceci permet de définir ce qui sera fait avec les 'simples' et "doubles" quotes.
                    Les constantes suivantes sont acceptées:
                    <code class="constant">ENT_COMPAT</code>, <code class="constant">ENT_QUOTES</code>
                    <code class="constant">ENT_NOQUOTES</code>, par défaut il s'agira de
                    <code class="constant">ENT_COMPAT</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">charset</span></em></span>: Equivalent au paramètre
                    <span class="emphasis"><em>charset</em></span> de la fonction <acronym class="acronym">PHP</acronym> htmlentities.
                    Ceci indique le jeu de caractères à utiliser pour le filtre. Contrairement à la fonction
                    <acronym class="acronym">PHP</acronym> native, la valeur par défaut est 'UTF-8'. Voyez
                    "http://php.net/htmlentities" pour la liste des jeux de caractères supportés.
                </p>

                <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                    <p>
                     Cette option peut être passées via le paramètre <code class="varname">$options</code> comme un
                     tableau ou objet <code class="classname">Zend_Config</code>. L'encodage ou le jeu de caractères
                     seront reconnus.
                    </p>
                </td></tr>
</table></div>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">doublequote</span></em></span>: Equivalent au paramètre
                    <span class="emphasis"><em>double_encode</em></span> de la fonction <acronym class="acronym">PHP</acronym> htmlentities.
                    Si passé à false, les entités html existantes ne seront pas encodées. Par défaut sur
                    true (conversion totale).
                </p>

                <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
                    <p>
                        Cette option peut être passée via le paramètre <code class="varname">$options</code> ou la
                        méthode <code class="methodname">setDoubleEncode()</code>.
                    </p>
                </td></tr>
</table></div>
            </li>
</ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.htmlentities.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voyez l'exemple qui suit pour le comportement de ce filtre.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_HtmlEntities();

print $filter-&gt;filter('&lt;');
</pre>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.htmlentities.quotestyle"></a>Styles de quote</h4></div></div></div>
        

        <p>
            <code class="classname">Zend_Filter_HtmlEntities</code> permet de changer les styles de quote
            à filtrer. Ceci est utile si vous voulez laisser intactes les doubles, simples ou les deux
            types de quotes. Voici un exemple:
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_HtmlEntities(array('quotestyle' =&gt; ENT_QUOTES));

$input  = "A 'single' and " . '"double"';
print $filter-&gt;filter($input);
</pre>

        <p>
            Ceci affiche
            <span class="emphasis"><em>A 'single' and "double"</em></span>. Notez que les 'simples'
            et les "doubles" quotes ont été filtrées.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_HtmlEntities(array('quotestyle' =&gt; ENT_COMPAT));

$input  = "A 'single' and " . '"double"';
print $filter-&gt;filter($input);
</pre>

        <p>
            L'exemple ci-dessus affichera <span class="emphasis"><em>A 'single' and "double"</em></span>.
            Notez que seules les "doubles" quotes ont été filtrées.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_HtmlEntities(array('quotestyle' =&gt; ENT_NOQUOTES));

$input  = "A 'single' and " . '"double"';
print $filter-&gt;filter($input);
</pre>

        <p>
            L'exemple ci-dessus affichera <span class="emphasis"><em>A 'single' and "double"</em></span>. Notez qu'ici aucune
            des "doubles" ou 'simples' quotes n'ont été altérées.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.htmlentities."></a>Méthodes d'aide</h4></div></div></div>
        

        <p>
            Pour changer ou récupérer la valeur de <span class="property">quotestyle</span> après instantiation,
            les méthodes <code class="methodname">setQuoteStyle()</code> et
            <code class="methodname">getQuoteStyle()</code> peuvent être utilisées.
            <code class="methodname">setQuoteStyle()</code> accepte un paramètre
            <code class="varname">$quoteStyle</code>. Les constantes suivantes sont autorisées:
            <code class="constant">ENT_COMPAT</code>, <code class="constant">ENT_QUOTES</code>,
            <code class="constant">ENT_NOQUOTES</code>
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_HtmlEntities();

$filter-&gt;setQuoteStyle(ENT_QUOTES);
print $filter-&gt;getQuoteStyle(ENT_QUOTES);
</pre>

        <p>
            Pour changer ou récupérer la valeur de <span class="property">charset</span> après instantiation,
            les méthodes <code class="methodname">setCharSet()</code> et <code class="methodname">getCharSet()</code>
            peuvent être utilisées. <code class="methodname">setCharSet()</code> accepte un paramètre
            <code class="varname">$charSet</code>. Voyez "http://php.net/htmlentities" pour une liste des valeurs
            acceptées.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_HtmlEntities();

$filter-&gt;setQuoteStyle(ENT_QUOTES);
print $filter-&gt;getQuoteStyle(ENT_QUOTES);
</pre>

        <p>
            Pour changer ou récupérer la valeur de <span class="property">doublequote</span> après instantiation,
            les méthodes <code class="methodname">setDoubleQuote()</code> et
            <code class="methodname">getDoubleQuote()</code> peuvent être utilisées.
            <code class="methodname">setDoubleQuote()</code> accepte un booléen
            <code class="varname">$doubleQuote</code>.
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_HtmlEntities();

$filter-&gt;setQuoteStyle(ENT_QUOTES);
print $filter-&gt;getQuoteStyle(ENT_QUOTES);
</pre>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.int"></a>Int</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Filter_Int</code> permet de transformer une valeur scalaire contenant un
        chiffre en entier.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.int.options"></a>Options supportées par Zend_Filter_Int</h4></div></div></div>
        

        <p>
            Il n'y a pas d'option supplémentaire pour <code class="classname">Zend_Filter_Int</code>.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.int.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voici un exemple de base:
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Int();

print $filter-&gt;filter('-4 is less than 0');
</pre>

        <p>
            Ceci affichera '-4'.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.localizedtonormalized"></a>LocalizedToNormalized</h3></div></div></div>

    

    <p>
        Ce filtre va transformer toute entrée localisée en sa représentation normalisée. La transformation est effectuée
        grâce à <code class="classname">Zend_Locale</code> en interne.
    </p>

    <p>
        Ceci permet à l'utilisateur de saisir des information dans sa propre locale, et du coté serveur de stocker les informations
        normalisées relatives.
    </p>

    <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
        <p>
            Attention la normalisation n'est pas de la traduction. Ce filtre ne sait pas traduire des chaines d'un langage à un autre.
        </p>
    </td></tr>
</table></div>

    <p>
        Les types suivants peuvent être normalisés:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                <span class="emphasis"><em>entiers</em></span>: Nombres entiers localisés. Ils seront normalisés
                dans la notation anglaise internationnale.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>float</em></span>: Nombres flottants. Ils seront normalisés
                dans la notation anglaise internationnale.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>nombres</em></span>: Nombres réels. Ils seront normalisés
                dans la notation anglaise internationnale.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>time</em></span>: Valeurs de temps. Normalisées sous forme de tableaux.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>date</em></span>: Valeurs de date. Normalisées sous forme de tableaux.
            </p>
        </li>
</ul></div>

    <p>
        Tout autre type d'entrée sera retourné tel quel, sans tranformation, par ce filtre.
    </p>

    <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
        <p>
            Notez bien que toute sortie normalisée de ce filtre est de type chaine de caractères.
        </p>
    </td></tr>
</table></div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.localizedtonormalized.numbers"></a>Normaliser des nombres</h4></div></div></div>

        

        <p>
            Tout type de nombre peut être normalisé, excepté les nombres représentant une notation scientifique.
        </p>

        <p>
            Voici un exemple:
        </p>

        <pre class="programlisting">
// Initialise le filtre
$filter = new Zend_Filter_LocalizedToNormalized();
$filter-&gt;filter('123.456,78');
// retourne '123456.78'
</pre>

        <p>
            Imaginons que nous utilisoons la locale 'de' de manière globale sur toute l'application.
            <code class="classname">Zend_Filter_LocalizedToNormalized</code> va utiliser cette locale là pour calculer sa sortie.
        </p>

        <p>
            Il est possible de contrôler la normalisation des nombres. Toute options accépté par
            <code class="classname">Zend_Locale_Format</code> peut alors être utilisée. Les plus courantes sont:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>date_format</em></span>
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>locale</em></span>
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>precision</em></span>
                </p>
            </li>
</ul></div>

        <p>
            Pour plus de détails à ce sujet, voyez le chapitre <a class="link" href="zend.locale.parsing.html" title="Normalization and Localization">
            Zend_Locale</a>.
        </p>

        <p>
            Voici un exemple utilisant la précision:
        </p>

        <pre class="programlisting">
// Numeric Filter
$filter = new Zend_Filter_LocalizedToNormalized(array('precision' =&gt; 2));

$filter-&gt;filter('123.456');
// retourne '123456.00'

$filter-&gt;filter('123.456,78901');
// retourne '123456.79'
</pre>

    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.localizedtonormalized.dates"></a>Normaliser des dates et des temps</h4></div></div></div>

        

        <p>
            Les dates et temps peuvent être normalisés eux aussi. La sortie du filtre sera alors toujours de type tableau.
        </p>

        <pre class="programlisting">
// Initialise le filtre
$filter = new Zend_Filter_LocalizedToNormalized();
$filter-&gt;filter('12.April.2009');
// retourne array('day' =&gt; '12', 'month' =&gt; '04', 'year' =&gt; '2009')
</pre>

        <p>
            Imaginons une fois de plus une locale globale 'de'. L'entrée est donc automatiquement reconnue comme date
            et vous aurez un tableau en sortie.
        </p>

        <p>
            Vous pouvez contrôler la transformation du filtre grâce aux paramètres
            <span class="emphasis"><em>date_format</em></span> et <span class="emphasis"><em>locale</em></span>.
        </p>

        <pre class="programlisting">
// Date Filter
$filter = new Zend_Filter_LocalizedToNormalized(
    array('date_format' =&gt; 'ss:mm:HH')
);

$filter-&gt;filter('11:22:33');
// retourne array('hour' =&gt; '33', 'minute' =&gt; '22', 'second' =&gt; '11')
</pre>
    </div>

</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.normalizedtolocalized"></a>NormalizedToLocalized</h3></div></div></div>

    

    <p>
        Ce filtre est l'inverse de
        <code class="classname">Zend_Filter_LocalizedToNormalized</code> et convertira toute entrée normalisée
        en entrée localisée. Il utilise <code class="classname">Zend_Locale</code> pour celà.
    </p>

    <p>
        Ceci permet de représenter une valeur normalisée dans la locale de l'utilisateur, qu'il reconnaitra
        donc sans problème.
    </p>

    <div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
        <p>
            Notez bien que la localisation n'est pas de la traduction, ce filtre ne sait pas traduire des chaines
            d'une langue à l'autre (comme des noms de jours ou de mois).
        </p>
    </td></tr>
</table></div>

    <p>
        Les types suivants peuvent être localisés:
    </p>

    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <p>
                <span class="emphasis"><em>entiers</em></span>: Nombres entiers.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>float</em></span>: Nombres flottants.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>nombres</em></span>: Autres nombres, comme les réels.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>temps</em></span>: Valeurs de temps, localisées sous forme de chaines.
            </p>
        </li>
<li class="listitem">
            <p>
                <span class="emphasis"><em>date</em></span>: Valeurs de dates, localisées sour forme de chaines.
            </p>
        </li>
</ul></div>

    <p>
        Tout autre type d'entrée sera retourné tel quel, sans transformation.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.normalizedtolocalized.numbers"></a>Localisation des nombres</h4></div></div></div>

        

        <p>
            Tout type de nombre peut être localisé, à l'exception des nombres représentant une notation scientifique.
        </p>

        <p>
            Comment fonctionne la localisation pour les nombres ?:
        </p>

        <pre class="programlisting">
// Initialise le filtre
$filter = new Zend_Filter_NormalizedToLocalized();
$filter-&gt;filter(123456.78);
// retourne '123.456,78'
</pre>

        <p>
            Imaginons que vous avez affecté une locale 'de' comme locale de l'application.
            <code class="classname">Zend_Filter_NormalizedToLocalized</code> va utiliser cette locale
            pour détecter le type de sortie à produire, ceci sous forme de chaine de caractères.
        </p>

        <p>
            Il est aussi possible de contrôler le look de vos nombres localisés. Pour cela vous pouvez préciser toute option
            que <code class="classname">Zend_Locale_Format</code> reconnait. Les plus courantes sont:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>date_format</em></span>
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>locale</em></span>
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>precision</em></span>
                </p>
            </li>
</ul></div>

        <p>
            Pour plus de détails sur ces options, voyez le <a class="link" href="zend.locale.parsing.html" title="Normalization and Localization"> chapitre sur
            Zend_Locale </a>.
        </p>

        <p>
            Voici un exemple utilisant ces options:
        </p>

        <pre class="programlisting">
// Numeric Filter
$filter = new Zend_Filter_NormalizedToLocalized(array('precision' =&gt; 2));

$filter-&gt;filter(123456);
// retourne '123.456,00'

$filter-&gt;filter(123456.78901);
// retourne '123.456,79'
</pre>

    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.normalizedtolocalized.dates"></a>Localiser des dates et des temps</h4></div></div></div>

        

        <p>
            Les dates et les temps peuvent aussi être localisés. Des chaines de caractères sont alors retournées,
            agissant avec la locale définie.
        </p>

        <pre class="programlisting">
// Initialise le filtre
$filter = new Zend_Filter_NormalizedToLocalized();
$filter-&gt;filter(array('day' =&gt; '12', 'month' =&gt; '04', 'year' =&gt; '2009');
// retoures '12.04.2009'
</pre>

        <p>
            Imaginons que vous ayiez spécifié la locale 'de' au niveau de l'application, celle-ci est alors
            automatiquement détectée et utilisée pour localiser la date.
        </p>

        <p>
            Bien sûr, vous pouvez contrôler le format d'affichage de vos dates, grâce aux paramètres
            <span class="emphasis"><em>date_format</em></span> et <span class="emphasis"><em>locale</em></span>.
        </p>

        <pre class="programlisting">
// Date Filter
$filter = new Zend_Filter_LocalizedToNormalized(
    array('date_format' =&gt; 'ss:mm:HH')
);

$filter-&gt;filter(array('hour' =&gt; '33', 'minute' =&gt; '22', 'second' =&gt; '11'));
// retourne '11:22:33'
</pre>
    </div>

</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.null"></a>Null</h3></div></div></div>
    

    <p>
        Ce filtre retournera la valeur <code class="constant">NULL</code> si des critères précis sont rencontrés.
        C'est souvent nécessaire lorsqu'on travaille avec des bases de données et que l'on souhaite une
        valeur <code class="constant">NULL</code> plutôt qu'un booléen ou tout autre type.
    </p>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.null.default"></a>Comportement par défaut de Zend_Filter_Null</h4></div></div></div>
        

        <p>
            Par défaut, ce filtre fonctionne comme la fonction <acronym class="acronym">PHP</acronym>
            <code class="methodname">empty()</code>. Donc si
            <code class="methodname">empty()</code> retourne true sur la valeur, alors
            <code class="constant">NULL</code> sera retourné par ce filtre
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_Null();
$value  = '';
$result = $filter-&gt;filter($value);
// retourne null plutôt que la chaine vide
</pre>

        <p>
            Ceci signifie qu'en l'absence d'une configuration spéciale,
            <code class="classname">Zend_Filter_Null</code> accepte tout type en entrée et retourne
            <code class="constant">NULL</code> dans les mêmes cas que <code class="methodname">empty()</code>.
        </p>

        <p>
            Toute autre valeur sera retournée telle quelle, sans aucune modification.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.null.types"></a>Changer le comportement de Zend_Filter_Null</h4></div></div></div>
        

        <p>
            Quelques fois ça ne suffit pas de filtrer en se basant sur <code class="methodname">empty()</code>. Ainsi,
            <code class="classname">Zend_Filter_Null</code> permet de déclarer quels types seront convertis.
        </p>

        <p>
            Les types suivants sont gérés:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                <p>
                    <span class="emphasis"><em>booleen</em></span>: Convertit le booléen
                    <span class="emphasis"><em><code class="constant">FALSE</code></em></span> en
                    <code class="constant">NULL</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>entier</em></span>: Convertit l'entier <span class="emphasis"><em>0</em></span> en
                    <code class="constant">NULL</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>tableau_vide</em></span>: Convertit le <span class="emphasis"><em>tableau</em></span> vide
                    en <code class="constant">NULL</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>chaine</em></span>: Convertit la chaine vide <span class="emphasis"><em>''</em></span> en
                    <code class="constant">NULL</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>zero</em></span>: Convertit la chaine zéro
                     (<span class="emphasis"><em>'0'</em></span>) en <code class="constant">NULL</code>.
                </p>
            </li>
<li class="listitem">
                <p>
                    <span class="emphasis"><em>tout</em></span>: Convertit tous les types cités en <code class="constant">NULL</code>.
                    (comportement par défaut).
                </p>
            </li>
</ul></div>

        <p>
            Il existe plusieurs manières de spécifier les types à filtrer, des constantes, des types ajoutés
            à la suite, des chaines de caractères, un tableau... Voyez les exemples suivants:
        </p>

        <pre class="programlisting">
// convertit false en null
$filter = new Zend_Filter_Null(Zend_Filter_Null::BOOLEAN);

// convertit false et 0 en null
$filter = new Zend_Filter_Null(
    Zend_Filter_Null::BOOLEAN + Zend_Filter_Null::INTEGER
);

// convertit false et 0 en null
$filter = new Zend_Filter_Null( array(
    Zend_Filter_Null::BOOLEAN,
    Zend_Filter_Null::INTEGER
));

// convertit false et 0 en null
$filter = new Zend_Filter_Null(array(
    'boolean',
    'integer',
));
</pre>

        <p>
            Un objet <code class="classname">Zend_Config</code> peut aussi être utilisé pour préciser les types.
            La méthode <code class="methodname">setType()</code> existe de même.
        </p>
    </div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.pregreplace"></a>PregReplace</h3></div></div></div>
    

    <p>
        <code class="classname">Zend_Filter_PregReplace</code> performs a search using regular expressions
        and replaces all found elements.
    </p>

    <p>
        The option <span class="property">match</span> has to be given to set the pattern which will be
        searched for. It can be a string for a single pattern, or an array of strings for multiple
        pattern.
    </p>

    <p>
        To set the pattern which will be used as replacement the option <span class="property">replace</span>
        has to be used. It can be a string for a single pattern, or an array of strings for multiple
        pattern.
    </p>

    <pre class="programlisting">
$filter = new Zend_Filter_PregReplace(array('match' =&gt; '/bob/',
                                            'replace' =&gt; 'john'));
$input  = 'Hy bob!';

$filter-&gt;filter($input);
// returns 'Hy john!'
</pre>

    <p>
        You can use <code class="methodname">getMatchPattern()</code> and
        <code class="methodname">setMatchPattern()</code> to set the matching pattern afterwards. To set
        the replacement pattern you can use <code class="methodname">getReplacement()</code> and
        <code class="methodname">setReplacement()</code>.
    </p>

    <pre class="programlisting">
$filter = new Zend_Filter_PregReplace();
$filter-&gt;setMatchPattern(array('bob', 'Hy'))
       -&gt;setReplacement(array('john', 'Bye'));
$input  = 'Hy bob!";

$filter-&gt;filter($input);
// returns 'Bye john!'
</pre>

    <p>
        For a more complex usage take a look into <acronym class="acronym">PHP</acronym>'s <a class="ulink" href="http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php" target="_top">PCRE
            Pattern Chapter</a>.
    </p>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.realpath"></a>RealPath</h3></div></div></div>
    

    <p>
        Ce filtre va résoudre un lien ou un chemin en chemin absolu canonique. Toutes références à
        <code class="filename">'/./'</code>, <code class="filename">'/../'</code> et tout ajout supplémentaire de
        <code class="filename">'/'</code> sera résolu ou supprimé. Aucun caractère de lien symbolique ne sera
        présent dans le résultat (<code class="filename">'/./'</code> ou <code class="filename">'/../'</code>)
    </p>

    <p>
        <code class="classname">Zend_Filter_RealPath</code> retourne <code class="constant">FALSE</code> en cas d'echec
        par exemple si le fichier n'existe pas. Sur les systems BSD,
        <code class="classname">Zend_Filter_RealPath</code> n'échoue pas si seule la dernière partie du chemin
        n'existe pas, les autres systèmes retourneront <code class="constant">FALSE</code>.
    </p>

    <pre class="programlisting">
$filter = new Zend_Filter_RealPath();
$path   = '/www/var/path/../../mypath';
$filtered = $filter-&gt;filter($path);

// retourne '/www/mypath'
</pre>

    <p>
        Il peut être nécessaire quelques fois de vouloir utiliser ce filtre sur des chemins inexistants.
        Par exemple récupérer le realpath d'un chemin à créer. Dans ce cas vous pouvez passer
        <code class="constant">FALSE</code> au constructeur, ou utiliser <code class="methodname">setExists()</code>.
    </p>

    <pre class="programlisting">
$filter = new Zend_Filter_RealPath(false);
$path   = '/www/var/path/../../non/existing/path';
$filtered = $filter-&gt;filter($path);

// retourne '/www/non/existing/path' même si file_exists ou realpath retourneraient false
</pre>

</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.stringtolower"></a>StringToLower</h3></div></div></div>
    

    <p>
        Ce filtre convertit toute entrée vers des caractères minuscules.
    </p>

    <pre class="programlisting">
$filter = new Zend_Filter_StringToLower();

print $filter-&gt;filter('SAMPLE');
// retourne "sample"
</pre>

    <p>
        Par défaut, seul le jeu de caractères de la locale en cours sera utilisé. Les caractères provenant
        d'autres jeux seront ignorés. Cela reste possible de les passer en minuscules si l'extension mbstring
        est présente dans votre environnement PHP. Indiquez l'encodage voulu à la création du filtre
        <code class="classname">StringToLower</code> ou utilisez sa méthode
        <code class="methodname">setEncoding()</code>.
    </p>

    <pre class="programlisting">
// utiliser UTF-8
$filter = new Zend_Filter_StringToLower('UTF-8');

// ou passer un tableau
$filter = new Zend_Filter_StringToLower(array('encoding' =&gt; 'UTF-8'));

// ou encore faire cela après coup
$filter-&gt;setEncoding('ISO-8859-1');
</pre>

    <div class="note"><table border="0" summary="Note: Préciser des mauvais encodages">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Préciser des mauvais encodages</th>
</tr>
<tr><td align="left" valign="top">
        

        <p>
            Attention une exception sera levée si vous précisez un encodage alors que l'extension
            mbstring est absente.
        </p>

        <p>
            Une exception sera de même levée si l'encodage que vous précisez n'est pas pris en compte
            par mbstring.
        </p>
    </td></tr>
</table></div>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.stringtoupper"></a>StringToUpper</h3></div></div></div>
    

    <p>
        Ce filtre convertit toute entrée vers une casse majuscule.
    </p>

    <pre class="programlisting">
$filter = new Zend_Filter_StringToUpper();

print $filter-&gt;filter('Sample');
// retourne "SAMPLE"
</pre>

    <p>
        Tout comme le filtre <code class="classname">StringToLower</code>, seul le jeu de
        caractères de la locale en cours sera utilisé. Son fonctionnement est le même
        que celui de <code class="classname">StringToLower</code>.
    </p>

    <pre class="programlisting">
$filter = new Zend_Filter_StringToUpper(array('encoding' =&gt; 'UTF-8'));

// ou encore
$filter-&gt;setEncoding('ISO-8859-1');
</pre>
</div>
    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.stringtrim"></a>StringTrim</h3></div></div></div>
    

    <p>
        Ce filtre modifie la chaine pour que certains caractères soient supprimés du début et de la
        fin de la chaine.
    </p>

     <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.stringtrim.options"></a>Options supportées par Zend_Filter_StringTrim</h4></div></div></div>
        

        <p>
            Les options suivantes sont gérées par <code class="classname">Zend_Filter_StringTrim</code>:
        </p>

        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    <span class="emphasis"><em><span class="property">charlist</span></em></span>: Liste de caractères à
                    supprimer du début et de la fin de la chaine. Si non précisé, le comportement par
                    défaut sera de supprimer les espaces du début et de la fin de la chaine.
                </p>
            </li></ul></div>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.stringtrim.basic"></a>Utilisation de base</h4></div></div></div>
        

        <p>
            Voici un exemple de base:
        </p>

        <pre class="programlisting">
$filter = new Zend_Filter_StringTrim();

print $filter-&gt;filter(' This is (my) content: ');
</pre>

        <p>
            Ceci affichera 'This is (my) content:'. Notez que les espaces ont été supprimés.
        </p>
    </div>

    <div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.filter.set.stringtrim.types"></a>Comportement par défaut de Zend_Filter_StringTrim</h4></div></div></div>
        

        <pre class="programlisting">
$filter = new Zend_Filter_StringTrim(':');
// ou new Zend_Filter_StringTrim(array('charlist' =&gt; ':'));

print $filter-&gt;filter(' This is (my) content:');
</pre>

        <p>
            Ceci affichera 'This is (my) content'. Notez que les espaces et le double-point ont
            été supprimés. Vous pouvez aussi passer une instance de
            <code class="classname">Zend_Config</code> ou un tableau avec la clé 'charlist'. Les méthodes
            <code class="methodname">setCharList()</code> et <code class="methodname">getCharList()</code> sont
            aussi disponibles.
        </p>
    </div>
</div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.stripnewlines"></a>Int</h3></div></div></div>
        

        <p>
            Retourne la valeur <code class="varname">$value</code> en enlevant les caractères représentant une
            nouvelle ligne.
        </p>
    </div>

    <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.set.striptags"></a>StripTags</h3></div></div></div>
        

        <p>
            Ce filtre retourne une chaîne, où toutes les balises HTML et <acronym class="acronym">PHP</acronym> sont supprimées,
            exceptées celles qui sont explicitement autorisées. En plus de pouvoir spécifier quelles
            balises sont autorisées, les développeurs peuvent spécifier quels attributs sont
            autorisés soit pour toutes les balises autorisées soit pour des balises spécifiques
            seulement.
        </p>
    </div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.filter.introduction.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.filter.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.filter.filter_chains.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Introduction </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Chaînes de filtrage</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
